
# Dosya: pdsXv12c.py
bu asagidaki kodun adi pdsv11c.py

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
from threading import Thread
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh,
            "COSH": math.cosh,
            "TANH": math.tanh,
            "ASINH": math.asinh,
            "ACOSH": math.acosh,
            "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi,
            "E": math.e,
            "BIN": bin,
            "HEX": hex,
            "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.get_ident(),
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {"en": {"PRINT": "Print", "ERROR": "Error"}}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        pass

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+([^\s]+)(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON GOSUB"):
                match = re.match(r"ON GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.gosub_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON GOSUB komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                parts = command[5:].strip().split()
                args = [self.evaluate_expression(arg, scope_name) for arg in parts]
                print(*args)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type.upper() == "STRUCT":
                        self.current_scope()[var_name] = StructInstance([], self.type_table)
                    elif var_type.upper() == "UNION":
                        self.current_scope()[var_name] = UnionInstance([], self.type_table)
                    else:
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition, then_cmd = match.groups()
                    if self.evaluate_expression(condition, scope_name):
                        return self.execute_command(then_cmd, scope_name)
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    loop_info = self.loop_stack[-1]
                    condition = loop_info["condition"]
                    if loop_info["type"] == "WHILE" and not self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL" and self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "NONE":
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("TRY"):
                match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)", command, re.IGNORECASE)
                if match:
                    try_block, error_var, catch_block = match.groups()
                    try:
                        self.execute_command(try_block, scope_name)
                    except Exception as e:
                        self.current_scope()[error_var] = str(e)
                        self.execute_command(catch_block, scope_name)
                    return None
                else:
                    raise Exception("TRY...CATCH komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("PERFORMANCE"):
                process = psutil.Process()
                memory = process.memory_info().rss / 1024 / 1024
                cpu = psutil.cpu_percent()
                elapsed = time.time() - self.performance_metrics["start_time"]
                print(f"Performans: Bellek: {memory:.2f} MB, CPU: {cpu:.2f}%, Süre: {elapsed:.2f}s")
                return None

            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                    else:
                        raise Exception(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("CALL"):
                if command_upper.startswith("CALL API::GET"):
                    match = re.match(r"CALL API::GET\s+(.+)", command, re.IGNORECASE)
                    if match:
                        url = match.group(1)
                        return requests.get(url).json()
                elif command_upper.startswith("CALL"):
                    match = re.match(r"CALL\s+(\w+)::(\w+)\((.*)\)", command, re.IGNORECASE)
                    if match:
                        dll_name, func_name, args = match.groups()
                        dll = self.core.load_dll(dll_name)
                        func = getattr(dll, func_name)
                        arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in args.split(",") if arg.strip()]
                        return func(*arg_list)
                raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("HELP"):
                match = re.match(r"HELP\s*(\w+)?", command, re.IGNORECASE)
                if match:
                    lib_name = match.group(1)
                    self.show_help(lib_name)
                    return None
                else:
                    raise Exception("HELP komutunda sözdizimi hatasý")

            if command_upper.startswith("CORE."):
                func_name = command_upper.split(".")[1]
                args = re.match(r"CORE\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if args:
                    _, arg_str = args.groups()
                    arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in arg_str.split(",") if arg.strip()]
                    return getattr(self.core, func_name.lower())(*arg_list)
                else:
                    return getattr(self.core, func_name.lower())()

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            logging.error(f"Hata: {str(e)}\n{''.join(traceback.format_stack())}")
            if self.error_handler:
                return self.error_handler
            elif self.gosub_handler:
                return self.gosub_handler
            else:
                raise e

    def show_help(self, lib_name=None):
        if lib_name:
            help_file = f"{lib_name}/{lib_name}_help.json"
            if os.path.exists(help_file):
                with open(help_file, "r", encoding="utf-8") as f:
                    help_data = json.load(f)
                for cmd in help_data.get(lib_name, {}).get("commands", []):
                    print(f"Komut: {cmd['name']}")
                    print(f"Kullaným: {cmd['usage']}")
                    print(f"Amaç: {cmd['purpose']}")
                    print(f"Örnek: {cmd['example']}")
                    print("-" * 50)
            else:
                print(f"Yardým dosyasý bulunamadý: {lib_name}")
        else:
            print("Kullaným: HELP [kütüphane_adý]")
            print("Örnek: HELP libx_core")

    def run(self, code):
        self.program = []
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        try:
            while self.running and self.program_counter < len(self.program):
                cmd, scope = self.program[self.program_counter]
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
        except Exception as e:
            if self.error_handler:
                self.program_counter = self.error_handler
            elif self.gosub_handler:
                self.program_counter = self.gosub_handler
            else:
                raise e
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        while True:
            try:
                cmd = input("> ")
                if cmd.upper() == "EXIT":
                    break
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        lines = code.split("\n")
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            tokens = line.split(maxsplit=1)
            opcode = tokens[0].upper()
            operands = tokens[1] if len(tokens) > 1 else ""
            self.bytecode.append({"opcode": opcode, "operands": operands, "line": i + 1})
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            instruction = self.bytecode[pc]
            opcode = instruction["opcode"]
            operands = instruction["operands"]
            try:
                if opcode == "PRINT":
                    print(self.evaluate_expression(operands))
                elif opcode == "LET":
                    var, val = operands.split("=", 1)
                    self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
                elif opcode == "DIM":
                    var_name, var_type = operands.split("AS")
                    self.current_scope()[var_name.strip()] = self.type_table.get(var_type.strip().upper(), object)()
                elif opcode == "IF":
                    condition, then_cmd = operands.split("THEN")
                    if self.evaluate_expression(condition.strip()):
                        self.execute_command(then_cmd.strip())
                elif opcode == "GOTO":
                    label = operands.strip()
                    for i, instr in enumerate(self.bytecode):
                        if instr["opcode"] == "LABEL" and instr["operands"] == label:
                            pc = i
                            break
                pc += 1
            except Exception as e:
                logging.error(f"Bayt kodu hatasý: Satýr {instruction['line']}, {str(e)}")
                if self.error_handler:
                    pc = self.error_handler
                else:
                    raise e
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: PDSV10 XX.py
import sys
import subprocess
import importlib.metadata
import platform
import json
import asyncio
import ast
import math
import re
import logging
import struct as py_struct
from collections import defaultdict
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
import os
import time
import argparse
import psutil
from abc import ABC, abstractmethod

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil'}
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler: {missing}")
        for lib in missing:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])

install_missing_libraries()

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr):
        if ptr in self.ref_counts and self.ref_counts[ptr] > 0:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr):
        return self.heap.get(ptr)

    def set_value(self, ptr, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = py_struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table

    def set_field(self, field_name, value):
        if field_name in self.fields:
            expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
            self.fields[field_name] = expected_type(value) if not isinstance(value, expected_type) else value

    def get_field(self, field_name):
        return self.fields.get(field_name)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        return self.interpreter.memory_pool.get(self.address, {}).get("value")

    def set(self, value):
        if self.address in self.interpreter.memory_pool:
            self.interpreter.memory_pool[self.address]["value"] = value

# Interpreter Çekirdeði
class pdsXv11(ABC):
    def __init__(self):
        self.global_vars = {}
        self.local_scopes = [{}]
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.error_handler = None
        self.debug_mode = False
        self.loop_stack = []
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.modules = {"main": {"program": [], "functions": {}, "subs": {}, "labels": {}}}
        self.current_module = "main"
        self.repl_mode = False
        self.bytecode = []
        self.type_table = {
            "INTEGER": int, "DOUBLE": float, "STRING": str, "LIST": list, "ARRAY": np.ndarray
        }
        self.function_table = {
            "LEN": len, "ABS": abs, "INT": int, "RND": random.random,
            "SQR": math.sqrt, "SIN": math.sin, "COS": math.cos, "TAN": math.tan
        }

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {"program": [], "functions": {}, "subs": {}, "labels": {}}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            else:
                self.program.append((line, module_name))
                self.modules[module_name]["program"].append((line, None))
                i += 1

    def evaluate_expression(self, expr, scope_name=None):
        tree = ast.parse(expr, mode='eval')
        namespace = {**self.global_vars, **self.current_scope(), **self.function_table}
        return eval(compile(tree, '<string>', 'eval'), namespace)

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return
        cmd_upper = command.upper()

        if cmd_upper.startswith("PRINT"):
            value = self.evaluate_expression(command[5:].strip(), scope_name)
            print(value)
        elif cmd_upper.startswith("LET"):
            var_name, expr = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.I).groups()
            value = self.evaluate_expression(expr, scope_name)
            self.current_scope()[var_name] = value
        elif cmd_upper.startswith("DIM"):
            var_name, var_type = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.I).groups()
            if var_type == "STRUCT":
                self.current_scope()[var_name] = StructInstance([], self.type_table)
            else:
                self.current_scope()[var_name] = self.type_table.get(var_type, object)()
        elif cmd_upper.startswith("IF"):
            condition = re.match(r"IF\s+(.+)\s+THEN", command, re.I).group(1)
            if self.evaluate_expression(condition, scope_name):
                return
            else:
                while self.program_counter < len(self.program) and \
                      self.program[self.program_counter][0].upper() != "END IF":
                    self.program_counter += 1
        elif cmd_upper == "END IF":
            return
        elif cmd_upper.startswith("FOR"):
            var_name, start, end = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)", command, re.I).groups()
            self.current_scope()[var_name] = self.evaluate_expression(start, scope_name)
            self.loop_stack.append({
                "start": self.program_counter,
                "var": var_name,
                "end": self.evaluate_expression(end, scope_name),
                "step": 1
            })
        elif cmd_upper.startswith("NEXT"):
            loop = self.loop_stack[-1]
            var_name = loop["var"]
            current = self.current_scope()[var_name] + loop["step"]
            self.current_scope()[var_name] = current
            if current <= loop["end"]:
                self.program_counter = loop["start"]
            else:
                self.loop_stack.pop()
        elif cmd_upper.startswith("GOTO"):
            label = re.match(r"GOTO\s+(\w+)", command, re.I).group(1)
            return self.labels.get(label, self.program_counter + 1)
        elif cmd_upper.startswith("ON ERROR GOTO"):
            label = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.I).group(1)
            self.error_handler = self.labels.get(label)
        else:
            raise Exception(f"Bilinmeyen komut: {command}")

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        while self.running and self.program_counter < len(self.program):
            cmd, scope = self.program[self.program_counter]
            try:
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
            except Exception as e:
                if self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    raise e
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        while True:
            cmd = input("> ")
            if cmd.upper() == "EXIT":
                break
            try:
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        for line in code.split("\n"):
            line = line.strip()
            if line:
                tokens = line.split(maxsplit=1)
                opcode = tokens[0].upper()
                operands = tokens[1] if len(tokens) > 1 else ""
                self.bytecode.append((opcode, operands))
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            opcode, operands = self.bytecode[pc]
            if opcode == "PRINT":
                print(self.evaluate_expression(operands))
            elif opcode == "LET":
                var, val = operands.split("=", 1)
                self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
            pc += 1
        self.running = False

    @abstractmethod
    def abstract_method(self):
        pass

class ConcreteInterpreter(pdsXv11):
    def abstract_method(self):
        print("Soyut metod implementasyonu")

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = ConcreteInterpreter()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsv11.py
# grok yazdirdi. 27.nisan.2025 mete dinler.

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
import threading
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}
        self.bitfields = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]
                self.bitfields.pop(ptr, None)

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()
            elif isinstance(value, (list, np.ndarray)):
                self.heap[ptr][:] = value.tobytes() if hasattr(value, 'tobytes') else bytes(value)

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return sys.getsizeof(obj)

    def set_bitfield(self, ptr: int, field: str, value: int, bits: int):
        if ptr not in self.heap:
            raise ValueError(f"Geçersiz iþaretçi: {ptr}")
        if bits not in (1, 2, 4, 8, 16, 32, 64):
            raise ValueError(f"Geçersiz bit uzunluðu: {bits}")
        self.bitfields.setdefault(ptr, {})[field] = (value, bits)

    def get_bitfield(self, ptr: int, field: str):
        if ptr not in self.bitfields or field not in self.bitfields[ptr]:
            raise ValueError(f"Geçersiz bit alaný: {ptr}.{field}")
        value, _ = self.bitfields[ptr][field]
        return value

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8,
            "BITFIELD": 4, "ENUM": 4
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(max(self._get_size(t) for _, t in fields))
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f", "BITFIELD": "i", "ENUM": "i"}.get(
            self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f", "BITFIELD": "i", "ENUM": "i"}.get(
            self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8,
            "BITFIELD": 4, "ENUM": 4
        }
        return size_map.get(type_name.upper(), 8)

class EnumInstance:
    def __init__(self, values):
        self.values = values
        self.current = None

    def set_value(self, value):
        if value in self.values:
            self.current = value
        else:
            raise ValueError(f"Geçersiz ENUM deðeri: {value}")

    def get_value(self):
        return self.current

    def get_index(self):
        return list(self.values.keys()).index(self.current) if self.current in self.values else -1

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXLowLevel Sýnýfý
class LibXLowLevel:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.memory_manager = interpreter.memory_manager

    def alloc(self, size: int):
        return self.memory_manager.allocate(size)

    def free(self, ptr: int):
        self.memory_manager.release(ptr)

    def bitset(self, ptr: int, field: str, value: int, bits: int):
        self.memory_manager.set_bitfield(ptr, field, value, bits)

    def bitget(self, ptr: int, field: str):
        return self.memory_manager.get_bitfield(ptr, field)

    def memcpy(self, dest_ptr: int, src_ptr: int, size: int):
        if dest_ptr in self.memory_manager.heap and src_ptr in self.memory_manager.heap:
            self.memory_manager.heap[dest_ptr][:size] = self.memory_manager.heap[src_ptr][:size]
        else:
            raise ValueError("Geçersiz iþaretçi")

    def memset(self, ptr: int, value: int, size: int):
        if ptr in self.memory_manager.heap:
            self.memory_manager.heap[ptr][:size] = bytes([value]) * size
        else:
            raise ValueError("Geçersiz iþaretçi")

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        elif isinstance(value, np.ndarray):
            return "ARRAY"
        elif isinstance(value, pd.DataFrame):
            return "DATAFRAME"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.interfaces = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.lowlevel = LibXLowLevel(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0, "cpu_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8",
            "utf-8-sig", "utf-8-bom-less"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh, "COSH": math.cosh, "TANH": math.tanh,
            "ASINH": math.asinh, "ACOSH": math.acosh, "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi, "E": math.e,
            "BIN": bin, "HEX": hex, "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": threading.active_count,
            "CURRENT_THREAD": threading.get_ident,
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce,
            "OMEGA": self.core.omega,
            "LIST_LIB": self.core.list_lib,
            "EACH": self.core.each,
            "SELECT": self.core.select,
            "INSERT": self.core.insert,
            "REMOVE": self.core.remove,
            "POP": self.core.pop,
            "CLEAR": self.core.clear,
            "SLICE": self.core.slice,
            "KEYS": self.core.keys,
            "TIME_NOW": self.core.time_now,
            "DATE_NOW": self.core.date_now,
            "TIMER": self.core.timer,
            "RANDOM_INT": self.core.random_int,
            "ASSERT": self.core.assert_,
            "LOG": self.core.log,
            "IFTHEN": self.core.ifthen,
            "EXISTS": self.core.exists,
            "MKDIR": self.core.mkdir,
            "GETENV": self.core.getenv,
            "EXIT": self.core.exit,
            "JOIN_PATH": self.core.join_path,
            "COPY_FILE": self.core.copy_file,
            "MOVE_FILE": self.core.move_file,
            "DELETE_FILE": self.core.delete_file,
            "FLOOR": self.core.floor,
            "CEIL": self.core.ceil,
            "SPLIT": self.core.split,
            "JOIN": self.core.join,
            "READ_LINES": self.core.read_lines,
            "WRITE_JSON": self.core.write_json,
            "READ_JSON": self.core.read_json,
            "LIST_DIR": self.core.list_dir,
            "PING": self.core.ping,
            "SUM": self.core.sum,
            "MEAN": self.core.mean,
            "MIN": self.core.min,
            "MAX": self.core.max,
            "ROUND": self.core.round,
            "TRIM": self.core.trim,
            "REPLACE": self.core.replace,
            "FORMAT": self.core.format,
            "TRACE": self.core.trace,
            "TRY_CATCH": self.core.try_catch,
            "SLEEP": self.core.sleep,
            "DATE_DIFF": self.core.date_diff,
            "RUN_ASYNC": self.core.run_async,
            "WAIT": self.core.wait,
            "MERGE": self.core.merge,
            "SORT": self.core.sort,
            "MEMORY_USAGE": self.core.memory_usage,
            "CPU_COUNT": self.core.cpu_count,
            "TYPE_OF": self.core.type_of,
            "IS_EMPTY": self.core.is_empty,
            "LEN": self.core.len,
            "VAL": self.core.val,
            "STR": self.core.str,
            "LISTFILE": self.core.listfile,
            "STACK": self.core.stack,
            "PUSH": self.core.push,
            "POP": self.core.pop,
            "QUEUE": self.core.queue,
            "ENQUEUE": self.core.enqueue,
            "DEQUEUE": self.core.dequeue,
            "LOAD_HZ": self.core.load_hz,
            "OPEN": self.core.open,
            "LOAD_DLL": self.core.load_dll,
            "LOAD_API": self.core.load_api,
            "VERSION": self.core.version,
            "REQUIRE_VERSION": self.core.require_version,
            "SET_ENCODING": self.core.set_encoding,
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {
                "en": {"PRINT": "Print", "ERROR": "Error", "LET": "Let", "DIM": "Dim"},
                "tr": {"PRINT": "Yaz", "ERROR": "Hata", "LET": "Atama", "DIM": "Tanýmla"}
            }

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "interfaces": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        current_interface = None
        type_fields = {}
        class_info = {}
        interface_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                match = re.match(r"SUB\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": i + 1, "params": params}
                    self.modules[module_name]["subs"][sub_name] = i + 1
                    current_sub = sub_name
                    i += 1
                else:
                    raise Exception("SUB komutunda sözdizimi hatasý")
            elif line_upper.startswith("FUNCTION "):
                match = re.match(r"FUNCTION\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": i + 1, "params": params}
                    self.modules[module_name]["functions"][func_name] = i + 1
                    current_function = func_name
                    i += 1
                else:
                    raise Exception("FUNCTION komutunda sözdizimi hatasý")
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_type = enum_name
                enum_values[enum_name] = {}
                value_index = 0
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END ENUM"):
                    value_name = lines[i].strip()
                    if value_name:
                        enum_values[enum_name][value_name] = value_index
                        value_index += 1
                    i += 1
                self.types[enum_name] = {"kind": "ENUM", "values": enum_values[enum_name]}
                self.modules[module_name]["types"][enum_name] = self.types[enum_name]
                current_type = None
                i += 1
                continue
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                        if match:
                            field_name, field_type = match.groups()
                            type_fields[struct_name].append((field_name, field_type))
                        else:
                            raise Exception(f"STRUCT tanýmý hatasý: {field_line}")
                    i += 1
                self.types[struct_name] = {"kind": "STRUCT", "fields": type_fields[struct_name]}
                self.modules[module_name]["types"][struct_name] = self.types[struct_name]
                current_type = None
                i += 1
                continue
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?(?:\s+IMPLEMENTS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name, interface_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'interfaces': [interface_name] if interface_name else [],
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?(?:\s+IMPLEMENTS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name, interface_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'interfaces': [interface_name] if interface_name else [],
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("INTERFACE "):
                interface_name = line[10:].strip()
                current_interface = interface_name
                interface_info[interface_name] = {'methods': {}}
                i += 1
            elif line_upper.startswith("END INTERFACE"):
                self.interfaces[current_interface] = interface_info[current_interface]
                self.modules[module_name]["interfaces"][current_interface] = interface_info[current_interface]
                current_interface = None
                i += 1
            elif current_interface and line_upper.startswith("DECLARE "):
                match = re.match(r"DECLARE\s+(SUB|FUNCTION)\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_type, method_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    interface_info[current_interface]['methods'][method_name] = {
                        'type': method_type,
                        'params': params
                    }
                    i += 1
                else:
                    raise Exception("INTERFACE DECLARE komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                interfaces = class_info[current_class]['interfaces']
                for iface in interfaces:
                    if iface in self.interfaces:
                        for method_name, method_info in self.interfaces[iface]['methods'].items():
                            if method_name not in class_info[current_class]['methods'] and \
                               method_name not in class_info[current_class]['private_methods']:
                                raise Exception(f"{current_class} sýnýfý {iface} arayüzündeki {method_name} metodunu uygulamýyor")
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type.upper(), None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type.upper(), None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx", ".libx", ".basx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_interfaces = self.interfaces.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.interfaces.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.interfaces.update(old_interfaces)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            line_upper = line.upper()
            if line_upper.startswith("DECLARE FUNCTION"):
                match = re.match(r"DECLARE FUNCTION\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": None, "params": params}
                    self.modules[module_name]["functions"][func_name] = None
            elif line_upper.startswith("DECLARE SUB"):
                match = re.match(r"DECLARE SUB\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": None, "params": params}
                    self.modules[module_name]["subs"][sub_name] = None

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            try:
                tree = ast.parse(expr, mode='eval')
                self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
            except SyntaxError:
                raise Exception(f"Geçersiz ifade: {expr}")
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        try:
            return eval(self.expr_cache[cache_key], namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, {str(e)}")

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            logging.debug(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper == "CLS":
                os.system('cls' if os.name == 'nt' else 'clear')
                return None

            if command_upper.startswith("BEEP"):
                print("\a")
                return None

            if command_upper.startswith("REM ") or command_upper.startswith("'"):
                return None

            if command_upper == "END":
                self.running = False
                return None

            if command_upper.startswith("STOP"):
                self.running = False
                return None

            if command_upper.startswith("SYSTEM"):
                match = re.match(r"SYSTEM\s+(.+)", command, re.IGNORECASE)
                if match:
                    cmd = match.group(1).strip()
                    os.system(cmd)
                    return None
                else:
                    raise Exception("SYSTEM komutunda sözdizimi hatasý")

            if command_upper.startswith("OPEN"):
                match = re.match(r"OPEN\s+\"([^\"]+)\"\s+FOR\s+(\w+)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_path, mode, file_number = match.groups()
                    file_number = int(file_number)
                    mode_map = {
                        "INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb",
                        "RANDOM": "r+b"
                    }
                    if mode.upper() not in mode_map:
                        raise Exception(f"Geçersiz dosya modu: {mode}")
                    self.file_handles[file_number] = open(file_path, mode_map[mode.upper()], encoding='utf-8' if mode.upper() != "BINARY" else None)
                    return None
                else:
                    raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        self.file_handles[file_number].close()
                        del self.file_handles[file_number]
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, data = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        data_value = self.evaluate_expression(data, scope_name)
                        self.file_handles[file_number].write(str(data_value) + "\n")
                        self.file_handles[file_number].flush()
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_number, var_name = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        line = self.file_handles[file_number].readline().strip()
                        self.current_scope()[var_name] = line
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, position = match.groups()
                    file_number = int(file_number)
                    position = self.evaluate_expression(position, scope_name)
                    if file_number in self.file_handles:
                        self.file_handles[file_number].seek(position)
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_number, var_name = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        data = self.file_handles[file_number].read(8)
                        self.current_scope()[var_name] = struct.unpack('d', data)[0]
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, value = match.groups()
                    file_number = int(file_number)
                    value = self.evaluate_expression(value, scope_name)
                    if file_number in self.file_handles:
                        self.file_handles[file_number].write(struct.pack('d', float(value)))
                        self.file_handles[file_number].flush()
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("Veri listesi sonuna ulaþýldý")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("SWAP"):
                match = re.match(r"SWAP\s+(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    var1, var2 = match.groups()
                    scope = self.current_scope()
                    if var1 in scope and var2 in scope:
                        scope[var1], scope[var2] = scope[var2], scope[var1]
                    else:
                        raise Exception(f"Deðiþkenler bulunamadý: {var1}, {var2}")
                    return None
                else:
                    raise Exception("SWAP komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    if os.path.exists(file_path):
                        os.remove(file_path)
                    else:
                        raise Exception(f"Dosya bulunamadý: {file_path}")
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"([^\"]+)\"\s+AS\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    if os.path.exists(old_name):
                        os.rename(old_name, new_name)
                    else:
                        raise Exception(f"Dosya bulunamadý: {old_name}")
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.makedirs(path, exist_ok=True)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        shutil.rmtree(path, ignore_errors=True)
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        os.chdir(path)
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        print("\n".join(os.listdir(path)))
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHAIN"):
                match = re.match(r"CHAIN\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f:
                            code = f.read()
                        self.run(code)
                        self.running = False
                    else:
                        raise Exception(f"Dosya bulunamadý: {file_path}")
                    return None
                else:
                    raise Exception("CHAIN komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMON"):
                match = re.match(r"COMMON\s+(.+)", command, re.IGNORECASE)
                if match:
                    var_names = [v.strip() for v in match.group(1).split(",")]
                    for var in var_names:
                        if var in self.current_scope():
                            self.shared_vars[var].append(self.current_scope()[var])
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {var}")
                    return None
                else:
                    raise Exception("COMMON komutunda sözdizimi hatasý")

            if command_upper.startswith("DECLARE"):
                match = re.match(r"DECLARE\s+(FUNCTION|SUB)\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    decl_type, name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    if decl_type.upper() == "FUNCTION":
                        self.functions[name] = {"line": None, "params": params}
                    else:
                        self.subs[name] = {"line": None, "params": params}
                    return None
                else:
                    raise Exception("DECLARE komutunda sözdizimi hatasý")

            if command_upper.startswith("DEF"):
                match = re.match(r"DEF\s+(\w+)\((.*)\)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    func_name, params, expr = match.groups()
                    params = [p.strip() for p in params.split(",") if p.strip()]
                    self.functions[func_name] = {
                        "line": None,
                        "params": params,
                        "expr": expr
                    }
                    return None
                else:
                    raise Exception("DEF komutunda sözdizimi hatasý")

            if command_upper.startswith("REDIM"):
                match = re.match(r"REDIM\s+(\w+)\s*\((.+)\)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dims, var_type = match.groups()
                    dims = [self.evaluate_expression(d.strip(), scope_name) for d in dims.split(",")]
                    if var_type.upper() in self.type_table:
                        self.current_scope()[var_name] = np.zeros(dims, dtype=self.type_table[var_type.upper()])
                    else:
                        raise Exception(f"Geçersiz veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("REDIM komutunda sözdizimi hatasý")

            if command_upper.startswith("ERASE"):
                match = re.match(r"ERASE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if var_name in self.current_scope():
                        del self.current_scope()[var_name]
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("ERASE komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE CONNECT"):
                match = re.match(r"SQLITE CONNECT\s+\"([^\"]+)\"\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_path, db_number = match.groups()
                    db_number = int(db_number)
                    self.db_connections[db_number] = sqlite3.connect(db_path)
                    return None
                else:
                    raise Exception("SQLITE CONNECT komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE EXECUTE"):
                match = re.match(r"SQLITE EXECUTE\s+#(\d+),\s*\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    db_number, query = match.groups()
                    db_number = int(db_number)
                    if db_number in self.db_connections:
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute(query)
                        self.db_connections[db_number].commit()
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("SQLITE EXECUTE komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE QUERY"):
                match = re.match(r"SQLITE QUERY\s+#(\d+),\s*\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    db_number, query, var_name = match.groups()
                    db_number = int(db_number)
                    if db_number in self.db_connections:
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute(query)
                        results = cursor.fetchall()
                        self.current_scope()[var_name] = results
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("SQLITE QUERY komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE CLOSE"):
                match = re.match(r"SQLITE CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections:
                        self.db_connections[db_number].close()
                        del self.db_connections[db_number]
                    return None
                else:
                    raise Exception("SQLITE CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections:
                        self.transaction_active[db_number] = True
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute("BEGIN TRANSACTION")
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections and self.transaction_active.get(db_number, False):
                        self.db_connections[db_number].commit()
                        self.transaction_active[db_number] = False
                    else:
                        raise Exception(f"Aktif iþlem yok veya baðlantý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections and self.transaction_active.get(db_number, False):
                        self.db_connections[db_number].rollback()
                        self.transaction_active[db_number] = False
                    else:
                        raise Exception(f"Aktif iþlem yok veya baðlantý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                match = re.match(r"PRINT\s*(.+)?", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    if expr:
                        parts = [part.strip() for part in expr.split(";")]
                        output = []
                        for part in parts:
                            if part:
                                result = self.evaluate_expression(part, scope_name)
                                output.append(str(result))
                            else:
                                output.append(" ")
                        print("".join(output), end="")
                    else:
                        print()
                    return None
                else:
                    raise Exception("PRINT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s*(?:\((.+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dims, var_type = match.groups()
                    if dims:
                        dims = [self.evaluate_expression(d.strip(), scope_name) for d in dims.split(",")]
                        if var_type.upper() in self.type_table:
                            self.current_scope()[var_name] = np.zeros(dims, dtype=self.type_table[var_type.upper()])
                        elif var_type.upper() in self.types:
                            type_info = self.types[var_type.upper()]
                            if type_info["kind"] == "STRUCT":
                                self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "UNION":
                                self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "ENUM":
                                self.current_scope()[var_name] = EnumInstance(type_info["values"])
                        else:
                            raise Exception(f"Geçersiz veri tipi: {var_type}")
                    else:
                        if var_type.upper() in self.type_table:
                            self.current_scope()[var_name] = self.type_table[var_type.upper()]()
                        elif var_type.upper() in self.types:
                            type_info = self.types[var_type.upper()]
                            if type_info["kind"] == "STRUCT":
                                self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "UNION":
                                self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "ENUM":
                                self.current_scope()[var_name] = EnumInstance(type_info["values"])
                        else:
                            raise Exception(f"Geçersiz veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s*(.+)?", command, re.IGNORECASE)
                if match:
                    condition, then_clause = match.groups()
                    condition_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": condition_result, "else": False})
                    if condition_result:
                        if then_clause:
                            return self.execute_command(then_clause, scope_name)
                    else:
                        return self.find_else_or_endif()
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if self.if_stack and not self.if_stack[-1]["else"]:
                    self.if_stack[-1]["else"] = True
                    if self.if_stack[-1]["condition"]:
                        return self.find_endif()
                    return None
                else:
                    raise Exception("ELSE komutu eþleþen IF olmadan kullanýldý")

            if command_upper == "ENDIF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("ENDIF komutu eþleþen IF olmadan kullanýldý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    condition_result = self.evaluate_expression(condition, scope_name)
                    if condition_result:
                        self.loop_stack.append({"type": "WHILE", "start": self.program_counter, "condition": condition})
                    else:
                        return self.find_wend()
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    condition = self.loop_stack[-1]["condition"]
                    condition_result = self.evaluate_expression(condition, scope_name)
                    if condition_result:
                        return self.loop_stack[-1]["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND komutu eþleþen WHILE olmadan kullanýldý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start, end, step = match.groups()
                    start_val = self.evaluate_expression(start, scope_name)
                    end_val = self.evaluate_expression(end, scope_name)
                    step_val = self.evaluate_expression(step, scope_name) if step else 1
                    self.current_scope()[var_name] = start_val
                    self.loop_stack.append({
                        "type": "FOR",
                        "var": var_name,
                        "end": end_val,
                        "step": step_val,
                        "start_line": self.program_counter
                    })
                    if step_val > 0 and start_val > end_val or step_val < 0 and start_val < end_val:
                        return self.find_next()
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper == "NEXT":
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop = self.loop_stack[-1]
                    var_name = loop["var"]
                    current_val = self.current_scope()[var_name]
                    step = loop["step"]
                    end = loop["end"]
                    current_val += step
                    self.current_scope()[var_name] = current_val
                    if step > 0 and current_val <= end or step < 0 and current_val >= end:
                        return loop["start_line"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT komutu eþleþen FOR olmadan kullanýldý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO(?:\s+(.+))?", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if condition and condition.upper().startswith("WHILE"):
                        condition = condition[5:].strip()
                        condition_result = self.evaluate_expression(condition, scope_name)
                        if not condition_result:
                            return self.find_loop()
                        self.loop_stack.append({"type": "DO_WHILE", "start": self.program_counter, "condition": condition})
                    elif condition and condition.upper().startswith("UNTIL"):
                        condition = condition[5:].strip()
                        condition_result = self.evaluate_expression(condition, scope_name)
                        if condition_result:
                            return self.find_loop()
                        self.loop_stack.append({"type": "DO_UNTIL", "start": self.program_counter, "condition": condition})
                    else:
                        self.loop_stack.append({"type": "DO", "start": self.program_counter})
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP(?:\s+(.+))?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop = self.loop_stack[-1]
                    condition = match.group(1)
                    if loop["type"] == "DO":
                        return loop["start"]
                    elif loop["type"] == "DO_WHILE" and (not condition or condition.upper().startswith("WHILE")):
                        loop_condition = loop["condition"]
                        condition_result = self.evaluate_expression(loop_condition, scope_name)
                        if condition_result:
                            return loop["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop["type"] == "DO_UNTIL" and (not condition or condition.upper().startswith("UNTIL")):
                        loop_condition = loop["condition"]
                        condition_result = self.evaluate_expression(loop_condition, scope_name)
                        if not condition_result:
                            return loop["start"]
                        else:
                            self.loop_stack.pop()
                    return None
                else:
                    raise Exception("LOOP komutu eþleþen DO olmadan kullanýldý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                elif scope_name in self.subs or scope_name in self.functions:
                    return None
                else:
                    raise Exception("RETURN komutu eþleþen GOSUB olmadan kullanýldý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper == "RESUME":
                if self.error_handler is not None:
                    return self.error_handler
                else:
                    raise Exception("RESUME komutu ON ERROR GOTO olmadan kullanýldý")

            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if self.select_stack:
                    match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                    if match:
                        case_expr = match.group(1)
                        if case_expr.upper() == "ELSE":
                            if not self.select_stack[-1]["matched"]:
                                self.select_stack[-1]["matched"] = True
                            else:
                                return self.find_end_select()
                        else:
                            case_value = self.evaluate_expression(case_expr, scope_name)
                            if self.select_stack[-1]["value"] == case_value and not self.select_stack[-1]["matched"]:
                                self.select_stack[-1]["matched"] = True
                            else:
                                return self.find_next_case_or_end()
                        return None
                    else:
                        raise Exception("CASE komutunda sözdizimi hatasý")
                else:
                    raise Exception("CASE komutu eþleþen SELECT CASE olmadan kullanýldý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT komutu eþleþen SELECT CASE olmadan kullanýldý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [self.evaluate_expression(p.strip(), scope_name) for p in params.split(",")] if params else []
                    if sub_name in self.subs:
                        sub_info = self.subs[sub_name]
                        if len(params) != len(sub_info["params"]):
                            raise Exception(f"Parametre uyuþmazlýðý: {sub_name}")
                        self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
                        self.call_stack.append(self.program_counter + 1)
                        return sub_info["line"]
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("FUNCTION"):
                match = re.match(r"FUNCTION\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": self.program_counter + 1, "params": params}
                    return self.find_end_function()
                else:
                    raise Exception("FUNCTION komutunda sözdizimi hatasý")

            if command_upper.startswith("SUB"):
                match = re.match(r"SUB\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": self.program_counter + 1, "params": params}
                    return self.find_end_sub()
                else:
                    raise Exception("SUB komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT"):
                match = re.match(r"EXIT\s+(SUB|FUNCTION|FOR|WHILE|DO)", command, re.IGNORECASE)
                if match:
                    exit_type = match.group(1).upper()
                    if exit_type == "SUB" and scope_name in self.subs:
                        return None
                    elif exit_type == "FUNCTION" and scope_name in self.functions:
                        return None
                    elif exit_type == "FOR" and self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                        self.loop_stack.pop()
                        return self.find_next()
                    elif exit_type == "WHILE" and self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                        self.loop_stack.pop()
                        return self.find_wend()
                    elif exit_type == "DO" and self.loop_stack and self.loop_stack[-1]["type"].startswith("DO"):
                        self.loop_stack.pop()
                        return self.find_loop()
                    else:
                        raise Exception(f"EXIT {exit_type} için uygun baðlam bulunamadý")
                else:
                    raise Exception("EXIT komutunda sözdizimi hatasý")

            if command_upper.startswith("TYPE"):
                match = re.match(r"TYPE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    type_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END TYPE"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"TYPE tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[type_name] = {"kind": "STRUCT", "fields": fields}
                    return i
                else:
                    raise Exception("TYPE komutunda sözdizimi hatasý")

            if command_upper.startswith("STRUCT"):
                match = re.match(r"STRUCT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    struct_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END STRUCT"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"STRUCT tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[struct_name] = {"kind": "STRUCT", "fields": fields}
                    return i
                else:
                    raise Exception("STRUCT komutunda sözdizimi hatasý")

            if command_upper.startswith("UNION"):
                match = re.match(r"UNION\s+(\w+)", command, re.IGNORECASE)
                if match:
                    union_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END UNION"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"UNION tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[union_name] = {"kind": "UNION", "fields": fields}
                    return i
                else:
                    raise Exception("UNION komutunda sözdizimi hatasý")

            if command_upper.startswith("ENUM"):
                match = re.match(r"ENUM\s+(\w+)", command, re.IGNORECASE)
                if match:
                    enum_name = match.group(1)
                    values = {}
                    value_index = 0
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END ENUM"):
                        value_name = self.program[i][0].strip()
                        if value_name:
                            values[value_name] = value_index
                            value_index += 1
                        i += 1
                    self.types[enum_name] = {"kind": "ENUM", "values": values}
                    return i
                else:
                    raise Exception("ENUM komutunda sözdizimi hatasý")

            if command_upper.startswith("NEW"):
                match = re.match(r"NEW\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, type_name = match.groups()
                    if type_name.upper() in self.types:
                        type_info = self.types[type_name.upper()]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = EnumInstance(type_info["values"])
                    elif type_name.upper() in self.classes:
                        self.current_scope()[var_name] = self.classes[type_name.upper()]()
                    else:
                        raise Exception(f"Geçersiz tip: {type_name}")
                    return None
                else:
                    raise Exception("NEW komutunda sözdizimi hatasý")

            if command_upper.startswith("SET"):
                match = re.match(r"SET\s+(\w+)\.(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, field_name, value_expr = match.groups()
                    value = self.evaluate_expression(value_expr, scope_name)
                    if var_name in self.current_scope():
                        instance = self.current_scope()[var_name]
                        if isinstance(instance, (StructInstance, UnionInstance)):
                            instance.set_field(field_name, value)
                        elif isinstance(instance, EnumInstance):
                            instance.set_value(value)
                        elif hasattr(instance, field_name):
                            setattr(instance, field_name, value)
                        else:
                            raise Exception(f"Geçersiz alan: {field_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("SET komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+(\w+)\.(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, field_name, target_var = match.groups()
                    if var_name in self.current_scope():
                        instance = self.current_scope()[var_name]
                        if isinstance(instance, (StructInstance, UnionInstance)):
                            self.current_scope()[target_var] = instance.get_field(field_name)
                        elif isinstance(instance, EnumInstance):
                            self.current_scope()[target_var] = instance.get_value()
                        elif hasattr(instance, field_name):
                            self.current_scope()[target_var] = getattr(instance, field_name)
                        else:
                            raise Exception(f"Geçersiz alan: {field_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("CONST"):
                match = re.match(r"CONST\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    const_name, value_expr = match.groups()
                    if const_name in self.global_vars:
                        raise Exception(f"Sabit zaten tanýmlý: {const_name}")
                    value = self.evaluate_expression(value_expr, scope_name)
                    self.global_vars[const_name] = value
                    return None
                else:
                    raise Exception("CONST komutunda sözdizimi hatasý")

            if command_upper.startswith("INCLUDE"):
                match = re.match(r"INCLUDE\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    self.import_module(file_path)
                    return None
                else:
                    raise Exception("INCLUDE komutunda sözdizimi hatasý")

            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"([^\"]+)\"\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_path, module_name = match.groups()
                    self.import_module(file_path, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("TRACE"):
                self.trace_mode = command_upper == "TRACE ON"
                return None

            if command_upper.startswith("DEBUG"):
                self.debug_mode = command_upper == "DEBUG ON"
                return None

            if command_upper.startswith("OPTION"):
                match = re.match(r"OPTION\s+(\w+)\s+(\w+)", command, re.IGNORECASE)
                if match:
                    option, value = match.groups()
                    if option.upper() == "ENCODING":
                        if value.lower() in self.supported_encodings:
                            self.core.set_encoding(value.lower())
                        else:
                            raise Exception(f"Desteklenmeyen kodlama: {value}")
                    elif option.upper() == "LANGUAGE":
                        if value.lower() in self.translations:
                            self.language = value.lower()
                        else:
                            raise Exception(f"Desteklenmeyen dil: {value}")
                    else:
                        raise Exception(f"Geçersiz seçenek: {option}")
                    return None
                else:
                    raise Exception("OPTION komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        self.file_handles[file_number].flush()
                        os.fsync(self.file_handles[file_number].fileno())
                    else:
                        raise Exception(f"Dosya bulunamadý: #{file_number}")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        # Dosya kilidi serbest býrakma (iþletim sistemine baðlý)
                        pass
                    else:
                        raise Exception(f"Dosya bulunamadý: #{file_number}")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("THREAD"):
                match = re.match(r"THREAD\s+(\w+)\s*,\s*(.+)", command, re.IGNORECASE)
                if match:
                    thread_name, sub_name = match.groups()
                    if sub_name in self.subs:
                        sub_info = self.subs[sub_name]
                        thread = threading.Thread(target=self.execute_sub, args=(sub_name, []))
                        self.async_tasks.append(thread)
                        thread.start()
                        self.current_scope()[thread_name] = thread.ident
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                    return None
                else:
                    raise Exception("THREAD komutunda sözdizimi hatasý")

            if command_upper.startswith("ASYNC"):
                match = re.match(r"ASYNC\s+(\w+)\s*,\s*(.+)", command, re.IGNORECASE)
                if match:
                    task_name, sub_name = match.groups()
                    if sub_name in self.subs:
                        task = asyncio.create_task(self.execute_sub_async(sub_name, []))
                        self.async_tasks.append(task)
                        self.current_scope()[task_name] = id(task)
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                    return None
                else:
                    raise Exception("ASYNC komutunda sözdizimi hatasý")

            if command_upper.startswith("WAIT"):
                match = re.match(r"WAIT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    task_name = match.group(1)
                    if task_name in self.current_scope():
                        task_id = self.current_scope()[task_name]
                        for task in self.async_tasks:
                            if id(task) == task_id or task.ident == task_id:
                                if isinstance(task, threading.Thread):
                                    task.join()
                                elif isinstance(task, asyncio.Task):
                                    asyncio.run(task)
                                break
                    else:
                        raise Exception(f"Görev bulunamadý: {task_name}")
                    return None
                else:
                    raise Exception("WAIT komutunda sözdizimi hatasý")

            if command_upper.startswith("BITSET"):
                match = re.match(r"BITSET\s+(\d+)\s*,\s*(\w+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    ptr, field, value, bits = map(int, match.groups())
                    self.lowlevel.bitset(ptr, field, value, bits)
                    return None
                else:
                    raise Exception("BITSET komutunda sözdizimi hatasý")

            if command_upper.startswith("BITGET"):
                match = re.match(r"BITGET\s+(\d+)\s*,\s*(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    ptr, field, var_name = match.groups()
                    ptr = int(ptr)
                    self.current_scope()[var_name] = self.lowlevel.bitget(ptr, field)
                    return None
                else:
                    raise Exception("BITGET komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMCPY"):
                match = re.match(r"MEMCPY\s+(\d+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    dest_ptr, src_ptr, size = map(int, match.groups())
                    self.lowlevel.memcpy(dest_ptr, src_ptr, size)
                    return None
                else:
                    raise Exception("MEMCPY komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMSET"):
                match = re.match(r"MEMSET\s+(\d+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    ptr, value, size = map(int, match.groups())
                    self.lowlevel.memset(ptr, value, size)
                    return None
                else:
                    raise Exception("MEMSET komutunda sözdizimi hatasý")

            if command_upper.startswith("PTR"):
                match = re.match(r"PTR\s+(\w+)\s+AS\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
                if match:
                    var_name, type_name, target = match.groups()
                    target_value = self.evaluate_expression(target, scope_name)
                    address = self.memory_manager.allocate(self.memory_manager.sizeof(target_value))
                    self.memory_manager.set_value(address, target_value)
                    self.current_scope()[var_name] = Pointer(address, type_name, self)
                    return None
                else:
                    raise Exception("PTR komutunda sözdizimi hatasý")

            if command_upper.startswith("DEREF"):
                match = re.match(r"DEREF\s+(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    ptr_name, var_name = match.groups()
                    if ptr_name in self.current_scope():
                        pointer = self.current_scope()[ptr_name]
                        if isinstance(pointer, Pointer):
                            self.current_scope()[var_name] = pointer.dereference()
                        else:
                            raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("DEREF komutunda sözdizimi hatasý")

            # Fonksiyon çaðrýlarý ve deðiþken atamalarý
            match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
            if match:
                var_name, expr = match.groups()
                if var_name.upper() in self.functions:
                    raise Exception(f"{var_name} bir fonksiyon adý, deðiþken olarak kullanýlamaz")
                value = self.evaluate_expression(expr, scope_name)
                self.current_scope()[var_name] = value
                return None

            # Fonksiyon veya alt program çaðrýsý
            match = re.match(r"(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
            if match:
                name, params = match.groups()
                params = [self.evaluate_expression(p.strip(), scope_name) for p in params.split(",")] if params else []
                if name.upper() in self.functions:
                    func_info = self.functions[name.upper()]
                    if func_info.get("expr"):
                        namespace = {p: v for p, v in zip(func_info["params"], params)}
                        return self.evaluate_expression(func_info["expr"], scope_name)
                    if len(params) != len(func_info["params"]):
                        raise Exception(f"Parametre uyuþmazlýðý: {name}")
                    self.local_scopes.append({p: v for p, v in zip(func_info["params"], params)})
                    self.call_stack.append(self.program_counter + 1)
                    return func_info["line"]
                elif name.upper() in self.subs:
                    sub_info = self.subs[name.upper()]
                    if len(params) != len(sub_info["params"]):
                        raise Exception(f"Parametre uyuþmazlýðý: {name}")
                    self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
                    self.call_stack.append(self.program_counter + 1)
                    return sub_info["line"]
                else:
                    raise Exception(f"Bilinmeyen komut veya fonksiyon: {name}")
            else:
                raise Exception(f"Geçersiz komut: {command}")

        except Exception as e:
            if self.error_handler is not None:
                self.current_scope()["ERR"] = str(e)
                return self.error_handler
            else:
                raise Exception(f"Hata: {str(e)}")

    def execute_sub(self, sub_name, params):
        if sub_name in self.subs:
            sub_info = self.subs[sub_name]
            if len(params) != len(sub_info["params"]):
                raise Exception(f"Parametre uyuþmazlýðý: {sub_name}")
            self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
            self.program_counter = sub_info["line"]
            while self.program_counter < len(self.program):
                command, scope = self.program[self.program_counter]
                if command.strip().upper() == "END SUB":
                    break
                next_pc = self.execute_command(command, sub_name)
                if next_pc is not None:
                    self.program_counter = next_pc
                else:
                    self.program_counter += 1
            self.local_scopes.pop()
        else:
            raise Exception(f"Alt program bulunamadý: {sub_name}")

    async def execute_sub_async(self, sub_name, params):
        return self.execute_sub(sub_name, params)

    def find_else_or_endif(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("IF"):
                nesting += 1
            elif cmd == "ENDIF":
                if nesting == 0:
                    return i
                nesting -= 1
            elif cmd == "ELSE" and nesting == 0:
                return i
            i += 1
        raise Exception("Eþleþen ELSE veya ENDIF bulunamadý")

    def find_endif(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("IF"):
                nesting += 1
            elif cmd == "ENDIF":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen ENDIF bulunamadý")

    def find_wend(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("WHILE"):
                nesting += 1
            elif cmd == "WEND":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen WEND bulunamadý")

    def find_next(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("FOR"):
                nesting += 1
            elif cmd == "NEXT":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen NEXT bulunamadý")

    def find_loop(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("DO"):
                nesting += 1
            elif cmd.startswith("LOOP"):
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen LOOP bulunamadý")

    def find_end_select(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("SELECT CASE"):
                nesting += 1
            elif cmd == "END SELECT":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen END SELECT bulunamadý")

    def find_next_case_or_end(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("SELECT CASE"):
                nesting += 1
            elif cmd == "END SELECT":
                if nesting == 0:
                    return i
                nesting -= 1
            elif cmd.startswith("CASE") and nesting == 0:
                return i
            i += 1
        raise Exception("Eþleþen CASE veya END SELECT bulunamadý")

    def find_end_function(self):
        i = self.program_counter + 1
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd == "END FUNCTION":
                return i
            i += 1
        raise Exception("Eþleþen END FUNCTION bulunamadý")

    def find_end_sub(self):
        i = self.program_counter + 1
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd == "END SUB":
                return i
            i += 1
        raise Exception("Eþleþen END SUB bulunamadý")

    def compile_to_bytecode(self, code):
        bytecode = []
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            bytecode.append(("EXEC", line))
        return bytecode

    def run(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkmak için EXIT yazýn")
        while self.repl_mode:
            try:
                command = input(">>> ")
                if command.strip().upper() == "EXIT":
                    self.repl_mode = False
                    break
                self.execute_command(command)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="pdsXv11 Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak BASIC dosyasý")
    parser.add_argument("--repl", action="store_true", help="REPL modunda çalýþtýr")
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.repl:
        interpreter.repl()
    elif args.file:
        with open(args.file, "r", encoding="utf-8") as f:
            code = f.read()
        interpreter.run(code)
    else:
        print("Lütfen bir dosya belirtin veya --repl ile REPL modunu kullanýn")

# Dosya: pdsx chatgpt_grok_manus.py

import re
import logging
import struct as py_struct
from collections import namedtuple

# 1. Temel veri yapýlarý ve sýnýflar
# (StructInstance, UnionInstance, ArrayInstance, Pointer, ClassInstance)
# (Bu kýsým burada yazýlacak - kýsaltýyorum þimdilik, çünkü zaten verdiðinle birebir olacak)
# ---------------
# (KOPYA: senin verdiðin tam StructInstance, UnionInstance, ArrayInstance, Pointer, ClassInstance sýnýflarýný koyacaðýz)
# ---------------

# 2. pdsXInterpreter güncellenmiþ hali
class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.classes = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float, "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        # burada yeni parse programý yazýlacak
        pass

    def current_scope(self):
        return self.scopes[-1]

    def execute_command(self, command, scope_name=None):
        # burada execute komutlarý güncellenecek
        pass

    def evaluate_expression(self, expr, scope_name=None):
        # burada expression evaluate edilecek
        pass

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope_name = self.program[self.program_counter]
            self.execute_command(command, scope_name)
            self.program_counter += 1
            
import re
import logging

from collections import namedtuple
import struct as py_struct

class StructInstance:
    def __init__(self, fields, type_table, types):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Invalid field: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info['kind'] in ('STRUCT', 'CLASS'):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"Expected StructInstance or ClassInstance for {field_name}")
            elif type_info['kind'] == 'UNION':
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"Expected UnionInstance for {field_name}")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except Exception:
                    raise TypeError(f"Type mismatch for {field_name}: expected {expected_type.__name__}")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Invalid field: {field_name}")
        return self.fields[field_name]

class UnionInstance:
    def __init__(self, fields, type_table, types):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.active_field = None
        self.value = bytearray(8)

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Invalid field: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info['kind'] in ('STRUCT', 'CLASS'):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"Expected StructInstance or ClassInstance for {field_name}")
            elif type_info['kind'] == 'UNION':
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"Expected UnionInstance for {field_name}")
            self.active_field = field_name
            self.value = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except Exception:
                    raise TypeError(f"Type mismatch for {field_name}: expected {expected_type.__name__}")
            self.active_field = field_name
            fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
                   "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(field_type, "8s")
            if fmt == "8s":
                value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
            else:
                value = py_struct.pack(fmt, value)
            self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Invalid field: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"Field {field_name} not active")
        return self.value

class ArrayInstance:
    def __init__(self, dimensions, element_type, type_table, types):
        self.dimensions = dimensions
        self.element_type = element_type.upper()
        self.type_table = type_table
        self.types = types
        total_size = 1
        for dim in dimensions:
            total_size *= dim
        self.elements = [None] * total_size

    def set_element(self, indices, value):
        index = self._flatten_index(indices)
        self.elements[index] = value

    def get_element(self, indices):
        index = self._flatten_index(indices)
        return self.elements[index]

    def _flatten_index(self, indices):
        index = 0
        multiplier = 1
        for size, idx in zip(reversed(self.dimensions), reversed(indices)):
            index += idx * multiplier
            multiplier *= size
        return index

class ClassInstance:
    def __init__(self, class_info, type_table, types, interpreter):
        self.class_info = class_info
        self.type_table = type_table
        self.types = types
        self.interpreter = interpreter
        self.fields = {name: None for name, _ in class_info["fields"] if class_info["access"].get(name, "PUBLIC") == "PUBLIC"}
        self.field_types = {name: type_name for name, type_name in class_info["fields"]}
        self.access = class_info["access"]
        self.methods = class_info["methods"]
        self.parent = class_info.get("parent")

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Invalid field: {field_name}")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Invalid field: {field_name}")
        return self.fields[field_name]

    def call_method(self, method_name, args):
        if method_name not in self.methods:
            raise ValueError(f"Invalid method: {method_name}")
        method = self.methods[method_name]
        self.interpreter.current_class = self
        self.interpreter.scopes.append({"SELF": self})
        for param, arg in zip(method["params"], args):
            self.interpreter.current_scope()[param[0]] = arg
        for cmd in method["body"]:
            self.interpreter.execute_command(cmd)
        self.interpreter.scopes.pop()
        del self.interpreter.current_class

# Devam edecek: pdsXInterpreter tam modernize edilmiþ haliyle (parse_program, execute_command, run, evaluate_expression)...
# Burada kaldigimiz yerden, pdsXInterpreter guncel ve gelismis haliyle devam ediyoruz

class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float,
            "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        self.current_class = None
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [], "functions": {}, "subs": {}, "classes": {}, "types": {}, "labels": {}
        }
        current_type = None
        current_enum = None
        current_class = None
        current_sub = None
        type_fields = {}
        enum_values = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()

            if line_upper.startswith("TYPE ") or line_upper.startswith("STRUCT "):
                type_name = line.split()[1]
                current_type = type_name
                type_fields[current_type] = []
            elif line_upper.startswith("END TYPE") or line_upper.startswith("END STRUCT"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                current_type = None
            elif line_upper.startswith("UNION "):
                union_name = line.split()[1]
                current_type = union_name
                type_fields[current_type] = []
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                current_type = None
            elif line_upper.startswith("ENUM "):
                enum_name = line.split()[1]
                current_enum = enum_name
                enum_values[current_enum] = {}
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                current_enum = None
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+(INHERITS|EXTENDS)\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, _, parent_name = match.groups()
                    current_class = class_name
                    class_info[current_class] = {"fields": [], "methods": {}, "access": {}, "parent": parent_name}
            elif line_upper.startswith("END CLASS"):
                self.types[current_class] = {"kind": "CLASS", **class_info[current_class]}
                current_class = None
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
            elif current_enum:
                match = re.match(r"(\w+)(?:\s*=\s*(\d+))?", line, re.IGNORECASE)
                if match:
                    name, value = match.groups()
                    value = int(value) if value else len(enum_values[current_enum])
                    enum_values[current_enum][name] = value
            elif current_class:
                access = "PUBLIC"
                if line_upper.startswith("PUBLIC "):
                    access = "PUBLIC"
                    line = line[len("PUBLIC "):].strip()
                elif line_upper.startswith("PRIVATE "):
                    access = "PRIVATE"
                    line = line[len("PRIVATE "):].strip()
                if line_upper.startswith("SUB "):
                    sub_name = line[4:].split("(")[0].strip()
                    params = []
                    if "(" in line and ")" in line:
                        param_str = line[line.index("(")+1:line.index(")")]
                        if param_str.strip():
                            for param in param_str.split(","):
                                param_name, param_type = [x.strip() for x in param.split("AS")]
                                params.append((param_name, param_type))
                    class_info[current_class]["methods"][sub_name] = {"params": params, "body": []}
                    current_sub = sub_name
                elif line_upper.startswith("END SUB"):
                    current_sub = None
                elif current_sub:
                    class_info[current_class]["methods"][current_sub]["body"].append(line)
                else:
                    match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                    if match:
                        field_name, field_type = match.groups()
                        class_info[current_class]["fields"].append((field_name, field_type))
                        class_info[current_class]["access"][field_name] = access
            else:
                self.program.append((line, None))
                self.modules[module_name]["program"].append((line, None))
            i += 1

# Burada ara veriyorum, birazdan devam edecegim:
# - execute_command
# - evaluate_expression
# - run
# - ileri seviye hata kontrolu
# - pointer, malloc, free, memset, memcpy gibi islemleri destekleyen
# Hepsi tam modern ve uyumlu sekilde yazilacak.

# Devam ettirmemi ister misin?

# Burada kaldigimiz yerden, pdsXInterpreter guncel ve gelismis haliyle devam ediyoruz

class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float,
            "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        self.current_class = None
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [], "functions": {}, "subs": {}, "classes": {}, "types": {}, "labels": {}
        }
        current_type = None
        current_enum = None
        current_class = None
        current_sub = None
        type_fields = {}
        enum_values = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()

            if line_upper.startswith("TYPE ") or line_upper.startswith("STRUCT "):
                type_name = line.split()[1]
                current_type = type_name
                type_fields[current_type] = []
            elif line_upper.startswith("END TYPE") or line_upper.startswith("END STRUCT"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                current_type = None
            elif line_upper.startswith("UNION "):
                union_name = line.split()[1]
                current_type = union_name
                type_fields[current_type] = []
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                current_type = None
            elif line_upper.startswith("ENUM "):
                enum_name = line.split()[1]
                current_enum = enum_name
                enum_values[current_enum] = {}
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                current_enum = None
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+(INHERITS|EXTENDS)\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, _, parent_name = match.groups()
                    current_class = class_name
                    class_info[current_class] = {"fields": [], "methods": {}, "access": {}, "parent": parent_name}
            elif line_upper.startswith("END CLASS"):
                self.types[current_class] = {"kind": "CLASS", **class_info[current_class]}
                current_class = None
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
            elif current_enum:
                match = re.match(r"(\w+)(?:\s*=\s*(\d+))?", line, re.IGNORECASE)
                if match:
                    name, value = match.groups()
                    value = int(value) if value else len(enum_values[current_enum])
                    enum_values[current_enum][name] = value
            elif current_class:
                access = "PUBLIC"
                if line_upper.startswith("PUBLIC "):
                    access = "PUBLIC"
                    line = line[len("PUBLIC "):].strip()
                elif line_upper.startswith("PRIVATE "):
                    access = "PRIVATE"
                    line = line[len("PRIVATE "):].strip()
                if line_upper.startswith("SUB "):
                    sub_name = line[4:].split("(")[0].strip()
                    params = []
                    if "(" in line and ")" in line:
                        param_str = line[line.index("(")+1:line.index(")")]
                        if param_str.strip():
                            for param in param_str.split(","):
                                param_name, param_type = [x.strip() for x in param.split("AS")]
                                params.append((param_name, param_type))
                    class_info[current_class]["methods"][sub_name] = {"params": params, "body": []}
                    current_sub = sub_name
                elif line_upper.startswith("END SUB"):
                    current_sub = None
                elif current_sub:
                    class_info[current_class]["methods"][current_sub]["body"].append(line)
                else:
                    match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                    if match:
                        field_name, field_type = match.groups()
                        class_info[current_class]["fields"].append((field_name, field_type))
                        class_info[current_class]["access"][field_name] = access
            else:
                self.program.append((line, None))
                self.modules[module_name]["program"].append((line, None))
            i += 1

# Burada ara veriyorum, birazdan devam edecegim:
# - execute_command
# - evaluate_expression
# - run
# - ileri seviye hata kontrolu
# - pointer, malloc, free, memset, memcpy gibi islemleri destekleyen
# Hepsi tam modern ve uyumlu sekilde yazilacak.

# Devam ettirmemi ister misin?
    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        try:
            # DIM (Deðiþken tanýmý)
            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)(?:\(([\d, ]+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dim_str, var_type = match.groups()
                    if dim_str:  # Çok boyutlu dizi
                        dimensions = [int(d) for d in dim_str.replace(" ", "").split(",")]
                        self.current_scope()[var_name] = ArrayInstance(dimensions, var_type, self.type_table, self.types)
                    elif var_type.upper() in self.types:
                        type_info = self.types[var_type.upper()]
                        kind = type_info["kind"]
                        if kind == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table, self.types)
                        elif kind == "CLASS":
                            self.current_scope()[var_name] = ClassInstance(type_info, self.type_table, self.types, self)
                        elif kind == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table, self.types)
                        elif kind == "ENUM":
                            self.current_scope()[var_name] = None  # ENUM baþlangýçta None
                        else:
                            raise Exception(f"Desteklenmeyen tür: {var_type}")
                    elif var_type.upper() == "POINTER":
                        # Özel durum: DIM p AS POINTER TO Type
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                        else:
                            raise Exception("POINTER tanýmý hatasý")
                    else:
                        # Basit türler
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            # LET (Deðere atama)
            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(.+?)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    target, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)

                    # Struct, Class veya Union iç alan eriþimi
                    if "." in target:
                        parts = target.split(".")
                        instance = self.current_scope().get(parts[0])
                        for field in parts[1:-1]:
                            instance = instance.get_field(field)
                        field_name = parts[-1]
                        instance.set_field(field_name, value)

                    # Dizi eriþimi
                    elif "(" in target and ")" in target:
                        match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                        if match_array:
                            var_name, indices_str = match_array.groups()
                            indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                            array = self.current_scope().get(var_name)
                            if isinstance(array, ArrayInstance):
                                array.set_element(indices, value)
                            else:
                                raise Exception(f"{var_name} bir dizi deðil")

                    # Pointer (iþaretçi)
                    elif "*" in target:
                        ptr_name = target.replace("*", "").strip()
                        ptr = self.current_scope().get(ptr_name)
                        if isinstance(ptr, Pointer):
                            ptr.set(value)
                        else:
                            raise Exception(f"{ptr_name} bir iþaretçi deðil")

                    # Normal deðiþken atamasý
                    else:
                        if target in self.current_scope():
                            self.current_scope()[target] = value
                        elif target in self.global_vars:
                            self.global_vars[target] = value
                        else:
                            raise Exception(f"Tanýmlanmamýþ deðiþken: {target}")

                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # CALL (Metod çaðrýsý)
            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if match:
                    obj_name, method_name, args_str = match.groups()
                    obj = self.current_scope().get(obj_name)
                    if isinstance(obj, ClassInstance):
                        args = []
                        if args_str.strip():
                            args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",")]
                        obj.call_method(method_name, args)
                    else:
                        raise Exception(f"{obj_name} bir sýnýf nesnesi deðil")
                    return None

            # PRINT (Yazdýrma)
            if command_upper.startswith("PRINT"):
                expr = command[5:].strip()
                value = self.evaluate_expression(expr, scope_name)
                print(value)
                return None

            # Pointer iþlemleri (PTR_SET, MALLOC, FREE vs.)
            if command_upper.startswith("PTR_SET") or command_upper.startswith("MALLOC") or command_upper.startswith("FREE") or command_upper.startswith("MEMCPY") or command_upper.startswith("MEMSET"):
                # Zaten özel iþaretçi fonksiyonlarý ayrý olarak yazýlmýþtý.
                return self.pointer_operations(command, scope_name)

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None
    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()

        # Struct / Class / Union alan eriþimi
        if "." in expr:
            parts = expr.split(".")
            instance = self.current_scope().get(parts[0])
            for field in parts[1:]:
                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                    instance = instance.get_field(field)
                else:
                    raise Exception(f"Geçersiz alan eriþimi: {expr}")
            return instance

        # Dizi eriþimi
        elif "(" in expr and ")" in expr:
            match_array = re.match(r"(\w+)\(([\d, ]+)\)", expr)
            if match_array:
                var_name, indices_str = match_array.groups()
                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                array = self.current_scope().get(var_name)
                if isinstance(array, ArrayInstance):
                    return array.get_element(indices)
                else:
                    raise Exception(f"{var_name} bir dizi deðil")
            else:
                raise Exception("Dizi sözdizimi hatasý")

        # Pointer eriþimi
        elif "*" in expr:
            ptr_name = expr.replace("*", "").strip()
            ptr = self.current_scope().get(ptr_name)
            if isinstance(ptr, Pointer):
                return ptr.dereference()
            else:
                raise Exception(f"{ptr_name} bir iþaretçi deðil")

        # ENUM deðerleri
        elif expr in self.types and self.types[expr]["kind"] == "ENUM":
            return self.types[expr]["values"]

        # Normal deðiþken veya matematiksel ifade
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)

        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")
    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope_name = self.program[self.program_counter]
            self.execute_command(command, scope_name)
            self.program_counter += 1
    def pointer_operations(self, command, scope_name=None):
        command_upper = command.upper()

        if command_upper.startswith("PTR_SET"):
            match = re.match(r"PTR_SET\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
            if match:
                ptr_name, expr = match.groups()
                ptr = self.current_scope().get(ptr_name)
                if not isinstance(ptr, Pointer):
                    raise Exception(f"{ptr_name} bir iþaretçi deðil")

                if expr.startswith("&"):
                    target = expr[1:].strip()
                    if "(" in target and ")" in target:
                        match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                        if match_array:
                            var_name, indices_str = match_array.groups()
                            indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                            array = self.current_scope().get(var_name)
                            if isinstance(array, ArrayInstance):
                                addr = self.next_address
                                self.memory_pool[addr] = {
                                    "value": array.get_element(indices),
                                    "type": array.element_type,
                                    "refs": 1
                                }
                                self.next_address += array.element_size
                                ptr.address = addr
                                ptr.dimensions = array.dimensions
                            else:
                                raise Exception(f"{var_name} bir dizi deðil")
                    else:
                        if target in self.current_scope():
                            addr = self.next_address
                            self.memory_pool[addr] = {
                                "value": self.current_scope()[target],
                                "type": ptr.target_type,
                                "refs": 1
                            }
                            self.next_address += 8
                            ptr.address = addr
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {target}")
                else:
                    addr = self.evaluate_expression(expr, scope_name)
                    if addr in self.memory_pool:
                        ptr.address = addr
                    else:
                        raise Exception(f"Geçersiz adres: {addr}")
            return None

        elif command_upper.startswith("MALLOC"):
            match = re.match(r"MALLOC\s+(\w+)\s+SIZE\s+(\d+)\s+AS\s+(\w+)", command, re.IGNORECASE)
            if match:
                var_name, size, var_type = match.groups()
                size = int(size)
                addr = self.next_address
                self.memory_pool[addr] = {
                    "value": None,
                    "type": var_type,
                    "refs": 1,
                    "size": size
                }
                self.next_address += size
                self.current_scope()[var_name] = Pointer(addr, var_type, self)
            return None

        elif command_upper.startswith("FREE"):
            match = re.match(r"FREE\s+(\w+)", command, re.IGNORECASE)
            if match:
                ptr_name = match.group(1)
                ptr = self.current_scope().get(ptr_name)
                if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                    self.memory_pool[ptr.address]["refs"] -= 1
                    if self.memory_pool[ptr.address]["refs"] <= 0:
                        del self.memory_pool[ptr.address]
                    ptr.address = None
                else:
                    raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
            return None

        elif command_upper.startswith("MEMCPY"):
            match = re.match(r"MEMCPY\s+(\w+)\s+FROM\s+(\w+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
            if match:
                dest_ptr_name, src_ptr_name, size = match.groups()
                size = int(size)
                dest_ptr = self.current_scope().get(dest_ptr_name)
                src_ptr = self.current_scope().get(src_ptr_name)
                if isinstance(dest_ptr, Pointer) and isinstance(src_ptr, Pointer):
                    if src_ptr.address in self.memory_pool and dest_ptr.address in self.memory_pool:
                        self.memory_pool[dest_ptr.address]["value"] = self.memory_pool[src_ptr.address]["value"]
                    else:
                        raise Exception("Geçersiz bellek adresi")
                else:
                    raise Exception("Geçersiz iþaretçi")
            return None

        elif command_upper.startswith("MEMSET"):
            match = re.match(r"MEMSET\s+(\w+)\s+VALUE\s+(.+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
            if match:
                ptr_name, value_expr, size = match.groups()
                size = int(size)
                ptr = self.current_scope().get(ptr_name)
                value = self.evaluate_expression(value_expr, scope_name)
                if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                    self.memory_pool[ptr.address]["value"] = value
                else:
                    raise Exception("Geçersiz iþaretçi")
            return None

        else:
            raise Exception(f"Bilinmeyen pointer komutu: {command}")


#pdfs icin libX_core
import os
import glob
import json
import shutil
import zipfile
import re
import time
import datetime
import subprocess
import numpy as np
from types import SimpleNamespace
from threading import Thread
import ctypes

class Stack:
    """Yýðýn veri yapýsý"""
    def __init__(self):
        self.items = []
    def push(self, item):
        self.items.append(item)
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise Exception("Yýðýn boþ")
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        raise Exception("Yýðýn boþ")
    def is_empty(self):
        return len(self.items) == 0
    def size(self):
        return len(self.items)

class Queue:
    """Kuyruk veri yapýsý"""
    def __init__(self):
        self.items = []
    def enqueue(self, item):
        self.items.append(item)
    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        raise Exception("Kuyruk boþ")
    def peek(self):
        if not self.is_empty():
            return self.items[0]
        raise Exception("Kuyruk boþ")
    def is_empty(self):
        return len(self.items) == 0
    def size(self):
        return len(self.items)

class LibXCore:
    def __init__(self):
        self.default_encoding = "utf-8"
        self.dll_handles = {}
        self.modules = {}
        self.omega_global = None

    # Çekirdek Ýþlevler
    def set_encoding(self, encoding):
        """Varsayýlan dosya kodlamasýný ayarlar."""
        self.default_encoding = encoding

    def load(self, module_path):
        """Modül dosyalarýný yükler (.hz, .hx, .libx, .basx)."""
        if not os.path.exists(module_path):
            raise Exception(f"Modül bulunamadý: {module_path}")
        valid_extensions = (".hz", ".hx", ".libx", ".basx")
        if not module_path.endswith(valid_extensions):
            raise Exception("Geçersiz dosya uzantýsý")
        with open(module_path, "r", encoding=self.default_encoding) as f:
            self.modules[module_path] = f.read()
        return True

    def list_lib(self):
        """Yüklenen modülleri listeler."""
        return list(self.modules.keys())

    def load_dll(self, dll_name):
        """DLL dosyasýný yükler."""
        dll = ctypes.WinDLL(dll_name)
        self.dll_handles[dll_name] = dll
        return SimpleNamespace(call=lambda func_name, *args: getattr(dll, func_name)(*args))

    # Omega ve Kontrol Yapýlarý
    def omega(self):
        """Global omega baðlamýný döndürür veya ayarlar."""
        return self.omega_global

    def ifthen(self, condition, then_value, else_value=None):
        """Ternary benzeri koþullu ifade."""
        return then_value if condition else else_value

    # Koleksiyon Ýþlemleri
    def each(self, iterable, func):
        """Iterable üzerinde fonksiyon uygular."""
        return [func(x) for x in iterable]

    def select(self, iterable, condition):
        """Koþula uyan elemanlarý seçer."""
        return [x for x in iterable if condition(x)]

    def insert(self, collection, index, value):
        """Koleksiyona eleman ekler."""
        collection.insert(index, value)

    def remove(self, collection, value):
        """Koleksiyondan elemaný kaldýrýr."""
        collection.remove(value)

    def pop(self, collection, index=-1):
        """Koleksiyondan eleman çýkarýr."""
        return collection.pop(index)

    def clear(self, collection):
        """Koleksiyonu temizler."""
        collection.clear()

    def slice(self, collection, start, end):
        """Koleksiyondan dilim alýr."""
        return collection[start:end]

    def keys(self, dictionary):
        """Sözlüðün anahtarlarýný döndürür."""
        return list(dictionary.keys())

    # Matematiksel ve Ýstatistiksel Ýþlevler
    def sum(self, iterable=None, *args):
        """Iterable'ýn toplamýný hesaplar."""
        if iterable is not None:
            return np.sum(iterable) if iterable else 0
        return np.sum(args) if args else 0

    def mean(self, iterable=None, *args):
        """Iterable'ýn ortalamasýný hesaplar."""
        if iterable is not None:
            return np.mean(iterable) if iterable else 0
        return np.mean(args) if args else 0

    def min(self, iterable=None, *args):
        """Minimum deðeri bulur."""
        if iterable is not None:
            return min(iterable) if iterable else None
        return min(args) if args else None

    def max(self, iterable=None, *args):
        """Maksimum deðeri bulur."""
        if iterable is not None:
            return max(iterable) if iterable else None
        return max(args) if args else None

    def median(self, iterable):
        """Ortanca deðeri hesaplar."""
        return np.median(iterable)

    def std(self, iterable):
        """Standart sapmayý hesaplar."""
        return np.std(iterable)

    def correlation(self, x, y):
        """Ýki dizi arasýndaki korelasyonu hesaplar."""
        return np.corrcoef(x, y)[0, 1]

    def floor(self, x):
        """Aþaðý yuvarlar."""
        return int(x // 1)

    def ceil(self, x):
        """Yukarý yuvarlar."""
        return int(-(-x // 1))

    def round(self, x, digits=0):
        """Sayýyý yuvarlar."""
        return round(x, digits)

    def random_int(self, start, end):
        """Rastgele tamsayý üretir."""
        import random
        return random.randint(start, end)

    # String Ýþlemleri
    def split(self, s, delimiter):
        """String'i böler."""
        return s.split(delimiter)

    def join(self, items, delimiter):
        """String'leri birleþtirir."""
        return delimiter.join(items)

    def trim(self, s):
        """Baþtaki ve sondaki boþluklarý kaldýrýr."""
        return s.strip()

    def replace(self, s, old, new):
        """String'de deðiþtirme yapar."""
        return s.replace(old, new)

    def format(self, s, *args):
        """String formatlama."""
        return s.format(*args)

    def match_regex(self, s, pattern):
        """Regex eþleþmesini kontrol eder."""
        return bool(re.match(pattern, s))

    def find_regex(self, s, pattern):
        """Regex ile eþleþenleri bulur."""
        return re.findall(pattern, s)

    def len(self, obj):
        """String veya koleksiyon uzunluðunu döndürür."""
        return len(obj)

    def val(self, s):
        """String'i sayýya çevirir."""
        try:
            return float(s) if s.replace(".", "").replace("-", "").isdigit() else 0
        except:
            return 0

    def str(self, value):
        """Deðeri string'e çevirir."""
        return str(value)

    # Dosya Sistemi Ýþlemleri
    def open(self, path, mode):
        """Dosyayý açar."""
        return open(path, mode, encoding=self.default_encoding)

    def read(self, file):
        """Dosyadan okur."""
        return file.read()

    def write(self, file, data):
        """Dosyaya yazar."""
        file.write(data)

    def close(self, file):
        """Dosyayý kapatýr."""
        file.close()

    def read_lines(self, path):
        """Dosyayý satýr satýr okur."""
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        """Nesneyi JSON olarak dosyaya yazar."""
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        """JSON dosyasýný okur."""
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        """Dizindeki dosyalarý listeler."""
        return os.listdir(path)

    def exists(self, path):
        """Dosyanýn varlýðýný kontrol eder."""
        return os.path.exists(path)

    def mkdir(self, path):
        """Dizin oluþturur."""
        os.makedirs(path, exist_ok=True)

    def join_path(self, *paths):
        """Dosya yollarýný birleþtirir."""
        return os.path.join(*paths)

    def copy_file(self, src, dst):
        """Dosyayý kopyalar."""
        shutil.copy2(src, dst)

    def move_file(self, src, dst):
        """Dosyayý taþýr."""
        shutil.move(src, dst)

    def delete_file(self, path):
        """Dosyayý siler."""
        os.remove(path)

    def file_size(self, path):
        """Dosyanýn bayt cinsinden boyutunu döndürür."""
        return os.path.getsize(path)

    def file_mtime(self, path):
        """Dosyanýn son deðiþtirilme zamanýný döndürür."""
        return datetime.datetime.fromtimestamp(os.path.getmtime(path)).strftime("%Y-%m-%d %H:%M:%S")

    def file_exists(self, path):
        """Dosyanýn varlýðýný kontrol eder (exists alias'ý)."""
        return os.path.exists(path)

    def dir_copy(self, src, dst):
        """Dizini kopyalar."""
        shutil.copytree(src, dst, dirs_exist_ok=True)

    def dir_remove(self, path):
        """Dizini ve içeriðini siler."""
        shutil.rmtree(path)

    def compress_zip(self, files, output):
        """Dosyalarý ZIP'e sýkýþtýrýr."""
        with zipfile.ZipFile(output, "w", zipfile.ZIP_DEFLATED) as zf:
            for file in files:
                zf.write(file)

    def extract_zip(self, zip_file, output_dir):
        """ZIP dosyasýný çýkarýr."""
        with zipfile.ZipFile(zip_file, "r") as zf:
            zf.extractall(output_dir)

    def find_files(self, path, pattern):
        """Kalýpla eþleþen dosyalarý bulur."""
        return glob.glob(os.path.join(path, pattern), recursive=True)

    # Að Ýþlemleri
    def download(self, url, path):
        """URL'den dosya indirir."""
        import requests
        response = requests.get(url)
        with open(path, "wb") as f:
            f.write(response.content)

    def ping(self, host):
        """Host'un eriþilebilirliðini kontrol eder."""
        import socket
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    # Zaman ve Tarih Ýþlemleri
    def time_now(self):
        """Geçerli saati döndürür."""
        return time.strftime("%H:%M:%S")

    def date_now(self):
        """Geçerli tarihi döndürür."""
        return time.strftime("%Y-%m-%d")

    def timer(self):
        """Geçerli zaman damgasýný döndürür."""
        return time.time()

    def sleep(self, seconds):
        """Programý duraklatýr."""
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        """Tarihler arasýndaki farký hesaplar."""
        d1 = datetime.datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    # Hata Yönetimi ve Debugging
    def assert(self, condition, message="Assertion failed"):
        """Koþulu kontrol eder, baþarýsýzsa hata fýrlatýr."""
        if not condition:
            raise Exception(message)

    def log(self, message):
        """Mesajý loglar."""
        print(f"LOG: {message}")

    def trace(self):
        """Çalýþma zamaný yýðýn izini döndürür."""
        import traceback
        return traceback.format_stack()

    def try_catch(self, block, handler):
        """Hata yakalama mekanizmasý."""
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    # Asenkron Ýþlemler
    def run_async(self, func):
        """Fonksiyonu asenkron çalýþtýrýr."""
        t = Thread(target=func)
        t.start()
        return t

    def wait(self, tasks):
        """Asenkron görevleri bekler."""
        for t in tasks:
            t.join()

    # Veri Yapýsý Ýþlemleri
    def create_stack(self):
        """Yeni yýðýn oluþturur."""
        return Stack()

    def push(self, stack, item):
        """Yýðýna eleman ekler."""
        stack.push(item)

    def pop_stack(self, stack):
        """Yýðýndan eleman çýkarýr."""
        return stack.pop()

    def peek(self, stack):
        """Yýðýnýn en üstteki elemanýný okur."""
        return stack.peek()

    def stack_is_empty(self, stack):
        """Yýðýnýn boþ olup olmadýðýný kontrol eder."""
        return stack.is_empty()

    def stack_size(self, stack):
        """Yýðýndaki eleman sayýsýný döndürür."""
        return stack.size()

    def create_queue(self):
        """Yeni kuyruk oluþturur."""
        return Queue()

    def enqueue(self, queue, item):
        """Kuyruða eleman ekler."""
        queue.enqueue(item)

    def dequeue(self, queue):
        """Kuyruktan eleman çýkarýr."""
        return queue.dequeue()

    def queue_peek(self, queue):
        """Kuyruðun baþýndaki elemaný okur."""
        return queue.peek()

    def queue_is_empty(self, queue):
        """Kuyruðun boþ olup olmadýðýný kontrol eder."""
        return queue.is_empty()

    def queue_size(self, queue):
        """Kuyruktaki eleman sayýsýný döndürür."""
        return queue.size()

    def merge(self, col1, col2):
        """Koleksiyonlarý birleþtirir."""
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        """Iterable'ý sýralar."""
        return sorted(iterable, key=key)

    def set_union(self, set1, set2):
        """Kümelerin birleþimini döndürür."""
        return set1 | set2

    def set_intersection(self, set1, set2):
        """Kümelerin kesiþimini döndürür."""
        return set1 & set2

    def set_difference(self, set1, set2):
        """Kümelerin farkýný döndürür."""
        return set1 - set2

    def set_add(self, set_obj, item):
        """Kümeye eleman ekler."""
        set_obj.add(item)

    def set_remove(self, set_obj, item):
        """Kümeden elemaný kaldýrýr."""
        set_obj.discard(item)

    # Sistem ve Performans Ýzleme
    def memory_usage(self):
        """Programýn bellek kullanýmýný döndürür."""
        import psutil
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024  # MB cinsinden

    def cpu_count(self):
        """CPU çekirdek sayýsýný döndürür."""
        import multiprocessing
        return multiprocessing.cpu_count()

    def shell(self, cmd):
        """Sistem komutu çalýþtýrýr."""
        return subprocess.getoutput(cmd)

    def get_cwd(self):
        """Geçerli çalýþma dizinini döndürür."""
        return os.getcwd()

    # Yardýmcý Ýþlevler
    def type_of(self, value):
        """Deðiþkenin tipini döndürür."""
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        elif isinstance(value, set):
            return "SET"
        elif isinstance(value, Stack):
            return "STACK"
        elif isinstance(value, Queue):
            return "QUEUE"
        return "UNKNOWN"

    def is_empty(self, collection):
        """Koleksiyonun boþ olup olmadýðýný kontrol eder."""
        return len(collection) == 0

    def getenv(self, var):
        """Çevresel deðiþkeni döndürür."""
        return os.getenv(var, "")

    def exit(self, code=0):
        """Programý sonlandýrýr."""
        import sys
        sys.exit(code)
        
pdsx v10m interpreterimde asagida ekledigim kodun getirdigi ozelikller bulunuyormu?

import re
import logging
import struct as py_struct
from collections import namedtuple

# Sýnýflar
class StructInstance:
    def __init__(self, fields, type_table, types):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table, types):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.active_field = field_name
            self.value = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.active_field = field_name
            fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
                   "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(field_type, "8s")
            if fmt == "8s":
                value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
            else:
                value = py_struct.pack(fmt, value)
            self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        if self.field_types[field_name].upper() in self.types:
            return self.value
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ArrayInstance:
    def __init__(self, dimensions, element_type, type_table, types):
        self.dimensions = dimensions
        self.element_type = element_type.upper()
        self.type_table = type_table
        self.types = types
        self.element_size = self._get_size(element_type)
        total_size = 1
        for dim in dimensions:
            total_size *= dim
        self.elements = [None] * total_size
        self.strides = []
        stride = self.element_size
        for dim in reversed(dimensions):
            self.strides.insert(0, stride)
            stride *= dim

    def set_element(self, indices, value):
        index = self._get_index(indices)
        if self.element_type in self.types:
            type_info = self.types[self.element_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"Dizi elemaný için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"Dizi elemaný için UnionInstance bekleniyor")
            self.elements[index] = value
        else:
            expected_type = self.type_table.get(self.element_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Dizi elemaný için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.elements[index] = value

    def get_element(self, indices):
        index = self._get_index(indices)
        return self.elements[index]

    def _get_index(self, indices):
        if len(indices) != len(self.dimensions):
            raise ValueError(f"Beklenen {len(self.dimensions)} indeks, ancak {len(indices)} alýndý")
        for i, idx in enumerate(indices):
            if not 0 <= idx < self.dimensions[i]:
                raise ValueError(f"Geçersiz indeks: {idx}")
        index = 0
        for i, idx in enumerate(indices):
            index += idx * self.strides[i] // self.element_size
        return index

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter, dimensions=None):
        self.address = address
        self.target_type = target_type.upper()
        self.interpreter = interpreter
        self.dimensions = dimensions
        self.element_size = self._get_size(target_type)
        self.strides = None
        if dimensions:
            self.strides = []
            stride = self.element_size
            for dim in reversed(dimensions):
                self.strides.insert(0, stride)
                stride *= dim

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        if self.dimensions and self.strides:
            new_address = self.address + offset * self.strides[-1]
        else:
            new_address = self.address + offset * self.element_size
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter, self.dimensions)

    def _get_size(self, type_name):
        if type_name.upper() in self.interpreter.types:
            type_info = self.interpreter.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ClassInstance:
    def __init__(self, class_info, type_table, types, interpreter):
        self.class_info = class_info
        self.type_table = type_table
        self.types = types
        self.interpreter = interpreter
        self.fields = {name: None for name, _ in class_info["fields"] if class_info["access"].get(name, "PUBLIC") == "PUBLIC"}
        self.field_types = {name: type_name for name, type_name in class_info["fields"]}
        self.access = class_info["access"]
        self.methods = class_info["methods"]
        self.parent = class_info.get("parent")

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        return self.fields[field_name]

    def call_method(self, method_name, args):
        if method_name not in self.methods:
            raise ValueError(f"Geçersiz metod: {method_name}")
        method = self.methods[method_name]
        self.interpreter.current_class = self
        self.interpreter.scopes.append({"SELF": self})
        for param, arg in zip(method["params"], args):
            self.interpreter.current_scope()[param[0]] = arg
        for cmd in method["body"]:
            self.interpreter.execute_command(cmd)
        self.interpreter.scopes.pop()
        del self.interpreter.current_class

# pdsXInterpreter sýnýfý
class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float, "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [], "functions": {}, "subs": {}, "classes": {}, "types": {}, "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        current_enum = None
        type_fields = {}
        enum_values = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            # TYPE
            if line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # STRUCT
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
            elif line_upper.startswith("END STRUCT"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[struct_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # UNION
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[union_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # ENUM
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            # CLASS
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+INHERITS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        "fields": [], "methods": {}, "access": {}, "parent": parent_name
                    }
                i += 1
            elif line_upper.startswith("END CLASS"):
                self.types[current_class] = {"kind": "CLASS", **class_info[current_class]}
                self.modules[module_name]["types"][current_class] = self.types[current_class]
                current_class = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"Taným hatasý: {line}")
                i += 1
            elif current_enum:
                match = re.match(r"(\w+)(?:\s*=\s*(\d+))?", line, re.IGNORECASE)
                if match:
                    name, value = match.groups()
                    value = int(value) if value else len(enum_values[current_enum])
                    enum_values[current_enum][name] = value
                else:
                    raise Exception(f"ENUM tanýmý hatasý: {line}")
                i += 1
            elif current_class:
                if line_upper.startswith(("PUBLIC ", "PRIVATE ")):
                    access = "PUBLIC" if line_upper.startswith("PUBLIC ") else "PRIVATE"
                    line = line[len(access):].strip()
                    line_upper = line.upper()
                else:
                    access = "PUBLIC"
                if line_upper.startswith("SUB "):
                    sub_name = line[4:].split("(")[0].strip()
                    params = []
                    if "(" in line and ")" in line:
                        param_str = line[line.index("(")+1:line.index(")")]
                        if param_str.strip():
                            for param in param_str.split(","):
                                param_name, param_type = [x.strip() for x in param.split("AS")]
                                params.append((param_name, param_type))
                    class_info[current_class]["methods"][sub_name] = {"params": params, "body": []}
                    current_sub = sub_name
                    i += 1
                elif line_upper.startswith("END SUB"):
                    current_sub = None
                    i += 1
                elif current_sub:
                    class_info[current_class]["methods"][current_sub]["body"].append(line)
                    i += 1
                else:
                    match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                    if match:
                        field_name, field_type = match.groups()
                        class_info[current_class]["fields"].append((field_name, field_type))
                        class_info[current_class]["access"][field_name] = access
                    else:
                        raise Exception(f"Sýnýf tanýmý hatasý: {line}")
                    i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def current_scope(self):
        return self.scopes[-1]

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        try:
            # DIM
            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)(?:\(([\d, ]+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dim_str, var_type = match.groups()
                    if dim_str:  # Dizi tanýmlama
                        dimensions = [int(d) for d in dim_str.replace(" ", "").split(",")]
                        self.current_scope()[var_name] = ArrayInstance(dimensions, var_type, self.type_table, self.types)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] in ("STRUCT", "CLASS"):
                            self.current_scope()[var_name] = (
                                StructInstance(type_info["fields"], self.type_table, self.types)
                                if type_info["kind"] == "STRUCT"
                                else ClassInstance(type_info, self.type_table, self.types, self)
                            )
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table, self.types)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                        else:
                            raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                        else:
                            raise Exception("POINTER tanýmý hatasý")
                    else:
                        self.current_scope()[var_name] = None
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            # LET
            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(.+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    target, expr = match.groups()
                    if "." in target:
                        parts = target.split(".")
                        instance = self.current_scope().get(parts[0])
                        for field in parts[1:-1]:
                            if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                instance = instance.get_field(field)
                            else:
                                raise Exception(f"Geçersiz alan eriþimi: {target}")
                        field_name = parts[-1]
                        if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                            value = self.evaluate_expression(expr, scope_name)
                            instance.set_field(field_name, value)
                        else:
                            raise Exception(f"{parts[0]} bir struct, union veya sýnýf deðil")
                    elif "*" in target:
                        ptr_name = target.replace("*", "").strip()
                        if ptr_name in self.current_scope():
                            ptr = self.current_scope()[ptr_name]
                            if isinstance(ptr, Pointer):
                                value = self.evaluate_expression(expr, scope_name)
                                ptr.set(value)
                            else:
                                raise Exception(f"{ptr_name} bir iþaretçi deðil")
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    elif "(" in target and ")" in target:
                        match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                        if match_array:
                            var_name, indices_str = match_array.groups()
                            indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                            if var_name in self.current_scope():
                                array = self.current_scope()[var_name]
                                if isinstance(array, ArrayInstance):
                                    value = self.evaluate_expression(expr, scope_name)
                                    array.set_element(indices, value)
                                else:
                                    raise Exception(f"{var_name} bir dizi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {var_name}")
                        else:
                            raise Exception("Dizi eriþiminde sözdizimi hatasý")
                    else:
                        value = self.evaluate_expression(expr, scope_name)
                        if target in self.types and self.types[target]["kind"] == "ENUM":
                            if value in self.types[target]["values"].values():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Geçersiz ENUM deðeri: {value}")
                        else:
                            if target in self.global_vars:
                                self.global_vars[target] = value
                            elif target in self.current_scope():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Tanýmlanmamýþ deðiþken: {target}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # CALL
            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if match:
                    obj_name, method_name, args_str = match.groups()
                    if obj_name in self.current_scope():
                        obj = self.current_scope()[obj_name]
                        if isinstance(obj, ClassInstance):
                            args = []
                            if args_str.strip():
                                args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",")]
                            obj.call_method(method_name, args)
                        else:
                            raise Exception(f"{obj_name} bir sýnýf nesnesi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {obj_name}")
                    return None
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # PRINT
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        if "." in arg:
                            parts_arg = arg.split(".")
                            instance = self.current_scope().get(parts_arg[0])
                            for field in parts_arg[1:]:
                                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                    instance = instance.get_field(field)
                                else:
                                    raise Exception(f"Geçersiz alan eriþimi: {arg}")
                            output += str(instance)
                        elif "*" in arg:
                            ptr_name = arg.replace("*", "").strip()
                            if ptr_name in self.current_scope():
                                ptr = self.current_scope()[ptr_name]
                                if isinstance(ptr, Pointer):
                                    output += str(ptr.dereference())
                                else:
                                    raise Exception(f"{ptr_name} bir iþaretçi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                        elif "(" in arg and ")" in arg:
                            match_array = re.match(r"(\w+)\(([\d, ]+)\)", arg)
                            if match_array:
                                var_name, indices_str = match_array.groups()
                                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                if var_name in self.current_scope():
                                    array = self.current_scope()[var_name]
                                    if isinstance(array, ArrayInstance):
                                        output += str(array.get_element(indices))
                                    else:
                                        raise Exception(f"{var_name} bir dizi deðil")
                                else:
                                    raise Exception(f"Deðiþken bulunamadý: {var_name}")
                            else:
                                raise Exception("Dizi eriþiminde sözdizimi hatasý")
                        else:
                            value = self.evaluate_expression(arg, scope_name)
                            output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            # Ýþaretçi Operasyonlarý
            if command_upper.startswith("PTR_SET"):
                match = re.match(r"PTR_SET\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
                if match:
                    ptr_name, expr = match.groups()
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer):
                            if expr.startswith("&"):
                                target = expr[1:].strip()
                                if "(" in target and ")" in target:
                                    match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                                    if match_array:
                                        var_name, indices_str = match_array.groups()
                                        indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                        if var_name in self.current_scope():
                                            array = self.current_scope()[var_name]
                                            if isinstance(array, ArrayInstance):
                                                addr = self.next_address
                                                self.memory_pool[addr] = {
                                                    "value": array.get_element(indices),
                                                    "type": array.element_type,
                                                    "refs": 1
                                                }
                                                self.next_address += array.element_size
                                                ptr.address = addr
                                                ptr.dimensions = array.dimensions
                                            else:
                                                raise Exception(f"{var_name} bir dizi deðil")
                                        else:
                                            raise Exception(f"Deðiþken bulunamadý: {var_name}")
                                    else:
                                        raise Exception("Dizi eriþiminde sözdizimi hatasý")
                                else:
                                    if target in self.current_scope():
                                        addr = self.next_address
                                        self.memory_pool[addr] = {
                                            "value": self.current_scope()[target],
                                            "type": ptr.target_type,
                                            "refs": 1
                                        }
                                        self.next_address += 8
                                        ptr.address = addr
                                    else:
                                        raise Exception(f"Deðiþken bulunamadý: {target}")
                            else:
                                addr = self.evaluate_expression(expr, scope_name)
                                if addr in self.memory_pool:
                                    ptr.address = addr
                                else:
                                    raise Exception(f"Geçersiz adres: {addr}")
                        else:
                            raise Exception(f"{ptr_name} bir iþaretçi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("PTR_SET komutunda sözdizimi hatasý")

            # Bellek Yönetimi
            if command_upper.startswith("MALLOC"):
                match = re.match(r"MALLOC\s+(\w+)\s+SIZE\s+(\d+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, size, var_type = match.groups()
                    size = int(size)
                    addr = self.next_address
                    self.memory_pool[addr] = {
                        "value": None,
                        "type": var_type,
                        "refs": 1,
                        "size": size
                    }
                    self.next_address += size
                    self.current_scope()[var_name] = Pointer(addr, var_type, self)
                    return None
                else:
                    raise Exception("MALLOC komutunda sözdizimi hatasý")

            if command_upper.startswith("FREE"):
                match = re.match(r"FREE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    ptr_name = match.group(1)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["refs"] -= 1
                            if self.memory_pool[ptr.address]["refs"] <= 0:
                                del self.memory_pool[ptr.address]
                            ptr.address = None
                        else:
                            raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("FREE komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMCPY"):
                match = re.match(r"MEMCPY\s+(\w+)\s+FROM\s+(\w+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    dest_ptr, src_ptr, size = match.groups()
                    size = int(size)
                    if dest_ptr in self.current_scope() and src_ptr in self.current_scope():
                        dest = self.current_scope()[dest_ptr]
                        src = self.current_scope()[src_ptr]
                        if isinstance(dest, Pointer) and isinstance(src, Pointer):
                            if src.address in self.memory_pool and dest.address in self.memory_pool:
                                self.memory_pool[dest.address]["value"] = self.memory_pool[src.address]["value"]
                            else:
                                raise Exception("Geçersiz bellek adresi")
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception("Deðiþken bulunamadý")
                    return None
                else:
                    raise Exception("MEMCPY komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMSET"):
                match = re.match(r"MEMSET\s+(\w+)\s+VALUE\s+(.+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    ptr_name, value_expr, size = match.groups()
                    size = int(size)
                    value = self.evaluate_expression(value_expr, scope_name)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["value"] = value
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("MEMSET komutunda sözdizimi hatasý")

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        if "." in expr:
            parts = expr.split(".")
            instance = self.current_scope().get(parts[0])
            for field in parts[1:]:
                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                    instance = instance.get_field(field)
                else:
                    raise Exception(f"Geçersiz alan eriþimi: {expr}")
            return instance
        elif "*" in expr:
            ptr_name = expr.replace("*", "").strip()
            if ptr_name in self.current_scope():
                ptr = self.current_scope()[ptr_name]
                if isinstance(ptr, Pointer):
                    return ptr.dereference()
            raise Exception(f"Geçersiz iþaretçi: {expr}")
        elif "(" in expr and ")" in expr:
            match_array = re.match(r"(\w+)\(([\d, ]+)\)", expr)
            if match_array:
                var_name, indices_str = match_array.groups()
                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                if var_name in self.current_scope():
                    array = self.current_scope()[var_name]
                    if isinstance(array, ArrayInstance):
                        return array.get_element(indices)
                raise Exception(f"Geçersiz dizi eriþimi: {expr}")
            else:
                raise Exception("Dizi eriþiminde sözdizimi hatasý")
        elif expr in self.types and self.types[expr]["kind"] == "ENUM":
            return self.types[expr]["values"]
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope_name = self.program[self.program_counter]
            self.execute_command(command, scope_name)
            self.program_counter += 1



Yeni Kodun Entegrasyonu:
Sýnýf Tanýmlama:
Orijinal CLASS ayrýþtýrmasýný koruyarak, yeni kodun PUBLIC, PRIVATE, ve INHERITS desteðini ekleyin. Örneðin, parse_program içinde:
python

Kopyala
elif line_upper.startswith("CLASS "):
    match = re.match(r"CLASS\s+(\w+)(?:\s+INHERITS\s+(\w+))?", line, re.IGNORECASE)
    if match:
        class_name, parent_name = match.groups()
        current_class = class_name
        class_info[class_name] = {
            "fields": [], "methods": {}, "access": {}, "parent": parent_name
        }
Orijinal kodda CLASS içinde sadece alanlar varsa, yeni kodun metod desteðini (SUB) ekleyin.
Nesne Oluþturma:
Orijinal DIM obj AS ClassName mantýðýný koruyun, ancak ClassInstance sýnýfýný kullanacak þekilde güncelleyin:
python

Kopyala
if type_info["kind"] == "CLASS":
    self.current_scope()[var_name] = ClassInstance(type_info, self.type_table, self.types, self)
Metod Çaðrýlarý:
Orijinal CALL komutunu koruyun, ancak yeni call_method mantýðýný entegre edin:
python

Kopyala
if command_upper.startswith("CALL"):
    match = re.match(r"CALL\s+(\w+)\.(\w+)\((.*)\)", command, re.IGNORECASE)
    if match:
        obj_name, method_name, args_str = match.groups()
        obj = self.current_scope()[obj_name]
        if isinstance(obj, ClassInstance):
            args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",") if arg.strip()]
            obj.call_method(method_name, args)
Kalýtým ve Eriþim Kontrolü:
Orijinal kodda INHERITS yoksa, yeni kodun kalýtým desteðini opsiyonel olarak ekleyin (kullanýlmazsa hata vermez).
PUBLIC/PRIVATE için, orijinal kodda eriþim kontrolü yoksa, varsayýlan olarak tüm alanlarý PUBLIC kabul edin.
Geri Uyumluluk:
Orijinal CLASS sözdizimini desteklemek için, yeni kodun parse_program ve execute_command bölümlerinde orijinal sözdizimini tanýyacak koþullu mantýk ekleyin:
python

Kopyala
if line_upper.startswith("CLASS ") and "INHERITS" not in line_upper:
    # Orijinal CLASS ayrýþtýrma mantýðý
Orijinal nesne oluþturma ve metod çaðrýlarýný bozmadan, yeni ClassInstance sýnýfýný kullanýn.
Çok Boyutlu Dizilerle Uyumluluk:
Orijinal CLASS içinde dizi kullanýmý varsa, yeni ArrayInstance sýnýfýný kullanarak çok boyutlu dizileri destekleyin:
basX

Kopyala
CLASS MyClass
    matrix AS ARRAY(10, 5) AS DOUBLE
END CLASS
3. Zotero ve Veri Bilimi Baðlamýnda Kullaným
Yeni CLASS komutu, Zotero ve veri bilimi senaryolarýnda orijinaline göre daha güçlü. Örnek:

basX

Kopyala
CLASS ZoteroAnalyzer
    PRIVATE docs AS ARRAY(100, 2) AS DOUBLE  ' Çok boyutlu dizi
    PUBLIC SUB LoadDocuments(path AS STRING)
        LET SELF.docs = ARRAY(PDF_EXTRACT_TABLES(path))  ' Zotero PDF'den tablo
    END SUB
    PUBLIC SUB Analyze()
        DIM ptr AS POINTER TO DOUBLE
        PTR_SET ptr TO &SELF.docs(0, 0)
        PRINT "First cell: "; *ptr
    END SUB
END CLASS

CLASS ExtendedAnalyzer INHERITS ZoteroAnalyzer
    PUBLIC meta AS DICT
    PUBLIC SUB AddMeta(key AS STRING, value AS STRING)
        LET SELF.meta = DICT(key, value)
    END SUB
END CLASS

DIM analyzer AS ExtendedAnalyzer
CALL analyzer.LoadDocuments("C:\Users\mete\Zotero\zotasistan\zapata_m6h\belge.pdf")
CALL analyzer.AddMeta("author", "Ali")
CALL analyzer.Analyze()
Faydalar:

Orijinalden Fark: Orijinal CLASS muhtemelen PRIVATE veya INHERITS desteklemiyordu, bu da modülerliði sýnýrlýyordu. Yeni sürüm, Zotero verilerini daha güvenli ve yeniden kullanýlabilir þekilde organize eder.
Çok Boyutlu Diziler: Tablo verileri için docs(100, 2) gibi yapýlar, iþaretçi aritmetiðiyle (ptr + 1) kolayca iþlenebilir.
4. Test ve Entegrasyon
Test Programý
Orijinal ve yeni CLASS özelliklerini test eden bir program:

basX

Kopyala
' Orijinal tarz CLASS
CLASS SimpleClass
    x AS INTEGER
    SUB PrintX()
        PRINT x
    END SUB
END CLASS

' Yeni tarz CLASS
CLASS ZoteroDocument
    PUBLIC baslik AS STRING
    PRIVATE tablo AS ARRAY(2, 3) AS DOUBLE
    SUB SetTable(i AS INTEGER, j AS INTEGER, value AS DOUBLE)
        LET SELF.tablo(i, j) = value
    END SUB
END CLASS

CLASS ExtendedDocument INHERITS ZoteroDocument
    PUBLIC SUB PrintTable()
        PRINT SELF.tablo(0, 0)
    END SUB
END CLASS

DIM simple AS SimpleClass
LET simple.x = 42
CALL simple.PrintX()

DIM doc AS ExtendedDocument
LET doc.baslik = "Test"
CALL doc.SetTable(0, 0, 1.23)
CALL doc.PrintTable()


Entegrasyon Önerileri
Orijinal PDSX kodunu bozmadan yeni CLASS ve çok boyutlu dizi desteðini entegre etmek için:

Yedek Alma:
pdsX.py dosyasýný yedekleyin (pdsX_backup.py).
Yeni Sýnýflarý Ekleme:
ClassInstance, ArrayInstance, Pointer, StructInstance, UnionInstance sýnýflarýný dosyanýn baþýna ekleyin.
CLASS Ayrýþtýrmasýný Güncelleme:
parse_program içindeki CLASS bloðunu, hem orijinal (EXTENDS, STATIC) hem yeni (INHERITS, PUBLIC/PRIVATE) sözdizimini destekleyecek þekilde birleþtirin:
python

Kopyala
elif line_upper.startswith("CLASS "):
    match = re.match(r"CLASS\s+(\w+)(?:\s+(EXTENDS|INHERITS)\s+(\w+))?", line, re.IGNORECASE)
    if match:
        class_name, inherit_keyword, parent_name = match.groups()
        current_class = class_name
        class_info[class_name] = {
            'fields': [], 'methods': {}, 'private_methods': {}, 'static_vars': {}, 'access': {}, 'parent': parent_name
        }
Alanlar için PUBLIC/PRIVATE ve DIM desteði:
python

Kopyala
elif current_class:
    if line_upper.startswith(("PUBLIC ", "PRIVATE ")):
        access = "PUBLIC" if line_upper.startswith("PUBLIC ") else "PRIVATE"
        line = line[len(access):].strip()
        line_upper = line.upper()
    else:
        access = "PUBLIC"
    if line_upper.startswith("DIM ") or re.match(r"\w+\s+AS\s+\w+", line_upper):
        match = re.match(r"(?:DIM\s+)?(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
        if match:
            field_name, field_type = match.groups()
            class_info[current_class]['fields'].append((field_name, field_type))
            class_info[current_class]['access'][field_name] = access
Statik deðiþkenler için:
python

Kopyala
elif line_upper.startswith("STATIC "):
    match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
    if match:
        var_name, var_type = match.groups()
        class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
Nesne Oluþturma ve Metod Çaðrýlarý:
execute_command içindeki DIM ve CALL bölümlerini güncelleyin:
python

Kopyala
if command_upper.startswith("DIM"):
    match = re.match(r"DIM\s+(\w+)(?:\(([\d, ]+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
    if match:
        var_name, dim_str, var_type = match.groups()
        if dim_str:  # Çok boyutlu dizi
            dimensions = [int(d) for d in dim_str.replace(" ", "").split(",")]
            self.current_scope()[var_name] = ArrayInstance(dimensions, var_type, self.type_table, self.types)
        elif var_type in self.classes:
            self.current_scope()[var_name] = ClassInstance(self.types[var_type], self.type_table, self.types, self)
python

Kopyala
if command_upper.startswith("CALL"):
    match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
    if match:
        target, method_name, args_str = match.groups()
        if method_name:
            obj = self.current_scope()[target]
            if isinstance(obj, ClassInstance):
                args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",") if arg.strip()]
                obj.call_method(method_name, args)
            elif hasattr(obj, method_name):
                args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                args = args if isinstance(args, (list, tuple)) else [args]
                method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                method(obj, *args)
Çok Boyutlu Diziler:
ArrayInstance sýnýfýný ekleyin ve execute_command içinde dizi eriþimini destekleyin:
python

Kopyala
elif "(" in target and ")" in target:
    match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
    if match_array:
        var_name, indices_str = match_array.groups()
        indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
        array = self.current_scope()[var_name]
        if isinstance(array, ArrayInstance):
            value = self.evaluate_expression(expr, scope_name)
            array.set_element(indices, value)
Veri Bilimi Fonksiyonlarýný Taþýma:
Orijinal function_table içindeki veri bilimi fonksiyonlarýný (MEAN, DESCRIBE, PIVOT_TABLE) yeni koda ekleyin:
python

Kopyala
self.function_table.update({
    "MEAN": np.mean, "DESCRIBE": lambda df: df.describe(), ...
})
Test Programý:
basX

Kopyala
CLASS ZoteroDoc
    PUBLIC title AS STRING
    PRIVATE data AS ARRAY(2, 3) AS DOUBLE
    SUB LoadData(path AS STRING)
        LET SELF.data(0, 0) = PDF_EXTRACT_TABLES(path)[0][0][0]
        LET SELF.title = "Test"
    END SUB
END CLASS
DIM doc AS ZoteroDoc
CALL doc.LoadData("belge.pdf")
PRINT doc.title; doc.data(0, 0)

pdsx v10m interpreterimde asagida ekledigim kodun getirdigi ozelikller bulunuyormu?

import re
import logging
import struct as py_struct
from collections import namedtuple

# Sýnýflar
class StructInstance:
    def __init__(self, fields, type_table, types):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table, types):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.active_field = field_name
            self.value = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.active_field = field_name
            fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
                   "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(field_type, "8s")
            if fmt == "8s":
                value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
            else:
                value = py_struct.pack(fmt, value)
            self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        if self.field_types[field_name].upper() in self.types:
            return self.value
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ArrayInstance:
    def __init__(self, dimensions, element_type, type_table, types):
        self.dimensions = dimensions
        self.element_type = element_type.upper()
        self.type_table = type_table
        self.types = types
        self.element_size = self._get_size(element_type)
        total_size = 1
        for dim in dimensions:
            total_size *= dim
        self.elements = [None] * total_size
        self.strides = []
        stride = self.element_size
        for dim in reversed(dimensions):
            self.strides.insert(0, stride)
            stride *= dim

    def set_element(self, indices, value):
        index = self._get_index(indices)
        if self.element_type in self.types:
            type_info = self.types[self.element_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"Dizi elemaný için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"Dizi elemaný için UnionInstance bekleniyor")
            self.elements[index] = value
        else:
            expected_type = self.type_table.get(self.element_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Dizi elemaný için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.elements[index] = value

    def get_element(self, indices):
        index = self._get_index(indices)
        return self.elements[index]

    def _get_index(self, indices):
        if len(indices) != len(self.dimensions):
            raise ValueError(f"Beklenen {len(self.dimensions)} indeks, ancak {len(indices)} alýndý")
        for i, idx in enumerate(indices):
            if not 0 <= idx < self.dimensions[i]:
                raise ValueError(f"Geçersiz indeks: {idx}")
        index = 0
        for i, idx in enumerate(indices):
            index += idx * self.strides[i] // self.element_size
        return index

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter, dimensions=None):
        self.address = address
        self.target_type = target_type.upper()
        self.interpreter = interpreter
        self.dimensions = dimensions
        self.element_size = self._get_size(target_type)
        self.strides = None
        if dimensions:
            self.strides = []
            stride = self.element_size
            for dim in reversed(dimensions):
                self.strides.insert(0, stride)
                stride *= dim

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        if self.dimensions and self.strides:
            new_address = self.address + offset * self.strides[-1]
        else:
            new_address = self.address + offset * self.element_size
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter, self.dimensions)

    def _get_size(self, type_name):
        if type_name.upper() in self.interpreter.types:
            type_info = self.interpreter.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ClassInstance:
    def __init__(self, class_info, type_table, types, interpreter):
        self.class_info = class_info
        self.type_table = type_table
        self.types = types
        self.interpreter = interpreter
        self.fields = {name: None for name, _ in class_info["fields"] if class_info["access"].get(name, "PUBLIC") == "PUBLIC"}
        self.field_types = {name: type_name for name, type_name in class_info["fields"]}
        self.access = class_info["access"]
        self.methods = class_info["methods"]
        self.parent = class_info.get("parent")

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        return self.fields[field_name]

    def call_method(self, method_name, args):
        if method_name not in self.methods:
            raise ValueError(f"Geçersiz metod: {method_name}")
        method = self.methods[method_name]
        self.interpreter.current_class = self
        self.interpreter.scopes.append({"SELF": self})
        for param, arg in zip(method["params"], args):
            self.interpreter.current_scope()[param[0]] = arg
        for cmd in method["body"]:
            self.interpreter.execute_command(cmd)
        self.interpreter.scopes.pop()
        del self.interpreter.current_class

# pdsXInterpreter sýnýfý
class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float, "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [], "functions": {}, "subs": {}, "classes": {}, "types": {}, "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        current_enum = None
        type_fields = {}
        enum_values = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            # TYPE
            if line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # STRUCT
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
            elif line_upper.startswith("END STRUCT"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[struct_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # UNION
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[union_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # ENUM
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            # CLASS
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+INHERITS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        "fields": [], "methods": {}, "access": {}, "parent": parent_name
                    }
                i += 1
            elif line_upper.startswith("END CLASS"):
                self.types[current_class] = {"kind": "CLASS", **class_info[current_class]}
                self.modules[module_name]["types"][current_class] = self.types[current_class]
                current_class = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"Taným hatasý: {line}")
                i += 1
            elif current_enum:
                match = re.match(r"(\w+)(?:\s*=\s*(\d+))?", line, re.IGNORECASE)
                if match:
                    name, value = match.groups()
                    value = int(value) if value else len(enum_values[current_enum])
                    enum_values[current_enum][name] = value
                else:
                    raise Exception(f"ENUM tanýmý hatasý: {line}")
                i += 1
            elif current_class:
                if line_upper.startswith(("PUBLIC ", "PRIVATE ")):
                    access = "PUBLIC" if line_upper.startswith("PUBLIC ") else "PRIVATE"
                    line = line[len(access):].strip()
                    line_upper = line.upper()
                else:
                    access = "PUBLIC"
                if line_upper.startswith("SUB "):
                    sub_name = line[4:].split("(")[0].strip()
                    params = []
                    if "(" in line and ")" in line:
                        param_str = line[line.index("(")+1:line.index(")")]
                        if param_str.strip():
                            for param in param_str.split(","):
                                param_name, param_type = [x.strip() for x in param.split("AS")]
                                params.append((param_name, param_type))
                    class_info[current_class]["methods"][sub_name] = {"params": params, "body": []}
                    current_sub = sub_name
                    i += 1
                elif line_upper.startswith("END SUB"):
                    current_sub = None
                    i += 1
                elif current_sub:
                    class_info[current_class]["methods"][current_sub]["body"].append(line)
                    i += 1
                else:
                    match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                    if match:
                        field_name, field_type = match.groups()
                        class_info[current_class]["fields"].append((field_name, field_type))
                        class_info[current_class]["access"][field_name] = access
                    else:
                        raise Exception(f"Sýnýf tanýmý hatasý: {line}")
                    i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def current_scope(self):
        return self.scopes[-1]

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        try:
            # DIM
            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)(?:\(([\d, ]+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dim_str, var_type = match.groups()
                    if dim_str:  # Dizi tanýmlama
                        dimensions = [int(d) for d in dim_str.replace(" ", "").split(",")]
                        self.current_scope()[var_name] = ArrayInstance(dimensions, var_type, self.type_table, self.types)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] in ("STRUCT", "CLASS"):
                            self.current_scope()[var_name] = (
                                StructInstance(type_info["fields"], self.type_table, self.types)
                                if type_info["kind"] == "STRUCT"
                                else ClassInstance(type_info, self.type_table, self.types, self)
                            )
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table, self.types)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                        else:
                            raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                        else:
                            raise Exception("POINTER tanýmý hatasý")
                    else:
                        self.current_scope()[var_name] = None
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            # LET
            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(.+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    target, expr = match.groups()
                    if "." in target:
                        parts = target.split(".")
                        instance = self.current_scope().get(parts[0])
                        for field in parts[1:-1]:
                            if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                instance = instance.get_field(field)
                            else:
                                raise Exception(f"Geçersiz alan eriþimi: {target}")
                        field_name = parts[-1]
                        if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                            value = self.evaluate_expression(expr, scope_name)
                            instance.set_field(field_name, value)
                        else:
                            raise Exception(f"{parts[0]} bir struct, union veya sýnýf deðil")
                    elif "*" in target:
                        ptr_name = target.replace("*", "").strip()
                        if ptr_name in self.current_scope():
                            ptr = self.current_scope()[ptr_name]
                            if isinstance(ptr, Pointer):
                                value = self.evaluate_expression(expr, scope_name)
                                ptr.set(value)
                            else:
                                raise Exception(f"{ptr_name} bir iþaretçi deðil")
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    elif "(" in target and ")" in target:
                        match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                        if match_array:
                            var_name, indices_str = match_array.groups()
                            indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                            if var_name in self.current_scope():
                                array = self.current_scope()[var_name]
                                if isinstance(array, ArrayInstance):
                                    value = self.evaluate_expression(expr, scope_name)
                                    array.set_element(indices, value)
                                else:
                                    raise Exception(f"{var_name} bir dizi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {var_name}")
                        else:
                            raise Exception("Dizi eriþiminde sözdizimi hatasý")
                    else:
                        value = self.evaluate_expression(expr, scope_name)
                        if target in self.types and self.types[target]["kind"] == "ENUM":
                            if value in self.types[target]["values"].values():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Geçersiz ENUM deðeri: {value}")
                        else:
                            if target in self.global_vars:
                                self.global_vars[target] = value
                            elif target in self.current_scope():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Tanýmlanmamýþ deðiþken: {target}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # CALL
            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if match:
                    obj_name, method_name, args_str = match.groups()
                    if obj_name in self.current_scope():
                        obj = self.current_scope()[obj_name]
                        if isinstance(obj, ClassInstance):
                            args = []
                            if args_str.strip():
                                args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",")]
                            obj.call_method(method_name, args)
                        else:
                            raise Exception(f"{obj_name} bir sýnýf nesnesi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {obj_name}")
                    return None
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # PRINT
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        if "." in arg:
                            parts_arg = arg.split(".")
                            instance = self.current_scope().get(parts_arg[0])
                            for field in parts_arg[1:]:
                                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                    instance = instance.get_field(field)
                                else:
                                    raise Exception(f"Geçersiz alan eriþimi: {arg}")
                            output += str(instance)
                        elif "*" in arg:
                            ptr_name = arg.replace("*", "").strip()
                            if ptr_name in self.current_scope():
                                ptr = self.current_scope()[ptr_name]
                                if isinstance(ptr, Pointer):
                                    output += str(ptr.dereference())
                                else:
                                    raise Exception(f"{ptr_name} bir iþaretçi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                        elif "(" in arg and ")" in arg:
                            match_array = re.match(r"(\w+)\(([\d, ]+)\)", arg)
                            if match_array:
                                var_name, indices_str = match_array.groups()
                                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                if var_name in self.current_scope():
                                    array = self.current_scope()[var_name]
                                    if isinstance(array, ArrayInstance):
                                        output += str(array.get_element(indices))
                                    else:
                                        raise Exception(f"{var_name} bir dizi deðil")
                                else:
                                    raise Exception(f"Deðiþken bulunamadý: {var_name}")
                            else:
                                raise Exception("Dizi eriþiminde sözdizimi hatasý")
                        else:
                            value = self.evaluate_expression(arg, scope_name)
                            output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            # Ýþaretçi Operasyonlarý
            if command_upper.startswith("PTR_SET"):
                match = re.match(r"PTR_SET\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
                if match:
                    ptr_name, expr = match.groups()
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer):
                            if expr.startswith("&"):
                                target = expr[1:].strip()
                                if "(" in target and ")" in target:
                                    match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                                    if match_array:
                                        var_name, indices_str = match_array.groups()
                                        indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                        if var_name in self.current_scope():
                                            array = self.current_scope()[var_name]
                                            if isinstance(array, ArrayInstance):
                                                addr = self.next_address
                                                self.memory_pool[addr] = {
                                                    "value": array.get_element(indices),
                                                    "type": array.element_type,
                                                    "refs": 1
                                                }
                                                self.next_address += array.element_size
                                                ptr.address = addr
                                                ptr.dimensions = array.dimensions
                                            else:
                                                raise Exception(f"{var_name} bir dizi deðil")
                                        else:
                                            raise Exception(f"Deðiþken bulunamadý: {var_name}")
                                    else:
                                        raise Exception("Dizi eriþiminde sözdizimi hatasý")
                                else:
                                    if target in self.current_scope():
                                        addr = self.next_address
                                        self.memory_pool[addr] = {
                                            "value": self.current_scope()[target],
                                            "type": ptr.target_type,
                                            "refs": 1
                                        }
                                        self.next_address += 8
                                        ptr.address = addr
                                    else:
                                        raise Exception(f"Deðiþken bulunamadý: {target}")
                            else:
                                addr = self.evaluate_expression(expr, scope_name)
                                if addr in self.memory_pool:
                                    ptr.address = addr
                                else:
                                    raise Exception(f"Geçersiz adres: {addr}")
                        else:
                            raise Exception(f"{ptr_name} bir iþaretçi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("PTR_SET komutunda sözdizimi hatasý")

            # Bellek Yönetimi
            if command_upper.startswith("MALLOC"):
                match = re.match(r"MALLOC\s+(\w+)\s+SIZE\s+(\d+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, size, var_type = match.groups()
                    size = int(size)
                    addr = self.next_address
                    self.memory_pool[addr] = {
                        "value": None,
                        "type": var_type,
                        "refs": 1,
                        "size": size
                    }
                    self.next_address += size
                    self.current_scope()[var_name] = Pointer(addr, var_type, self)
                    return None
                else:
                    raise Exception("MALLOC komutunda sözdizimi hatasý")

            if command_upper.startswith("FREE"):
                match = re.match(r"FREE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    ptr_name = match.group(1)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["refs"] -= 1
                            if self.memory_pool[ptr.address]["refs"] <= 0:
                                del self.memory_pool[ptr.address]
                            ptr.address = None
                        else:
                            raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("FREE komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMCPY"):
                match = re.match(r"MEMCPY\s+(\w+)\s+FROM\s+(\w+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    dest_ptr, src_ptr, size = match.groups()
                    size = int(size)
                    if dest_ptr in self.current_scope() and src_ptr in self.current_scope():
                        dest = self.current_scope()[dest_ptr]
                        src = self.current_scope()[src_ptr]
                        if isinstance(dest, Pointer) and isinstance(src, Pointer):
                            if src.address in self.memory_pool and dest.address in self.memory_pool:
                                self.memory_pool[dest.address]["value"] = self.memory_pool[src.address]["value"]
                            else:
                                raise Exception("Geçersiz bellek adresi")
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception("Deðiþken bulunamadý")
                    return None
                else:
                    raise Exception("MEMCPY komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMSET"):
                match = re.match(r"MEMSET\s+(\w+)\s+VALUE\s+(.+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    ptr_name, value_expr, size = match.groups()
                    size = int(size)
                    value = self.evaluate_expression(value_expr, scope_name)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["value"] = value
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("MEMSET komutunda sözdizimi hatasý")

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        if "." in expr:
            parts = expr.split(".")
            instance = self.current_scope().get(parts[0])
            for field in parts[1:]:
                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                    instance = instance.get_field(field)
                else:
                    raise Exception(f"Geçersiz alan eriþimi: {expr}")
            return instance
        elif "*" in expr:
            ptr_name = expr.replace("*", "").strip()
            if ptr_name in self.current_scope():
                ptr = self.current_scope()[ptr_name]
                if isinstance(ptr, Pointer):
                    return ptr.dereference()
            raise Exception(f"Geçersiz iþaretçi: {expr}")
        elif "(" in expr and ")" in expr:
            match_array = re.match(r"(\w+)\(([\d, ]+)\)", expr)
            if match_array:
                var_name, indices_str = match_array.groups()
                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                if var_name in self.current_scope():
                    array = self.current_scope()[var_name]
                    if isinstance(array, ArrayInstance):
                        return array.get_element(indices)
                raise Exception(f"Geçersiz dizi eriþimi: {expr}")
            else:
                raise Exception("Dizi eriþiminde sözdizimi hatasý")
        elif expr in self.types and self.types[expr]["kind"] == "ENUM":
            return self.types[expr]["values"]
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope_name = self.program[self.program_counter]
            self.execute_command(command, scope_name)
            self.program_counter += 1
            
            pdsx v10m interpreterimde asagida ekledigim kodun getirdigi ozelikller bulunuyormu?

import re
import logging
import struct as py_struct
from collections import namedtuple

# Sýnýflar
class StructInstance:
    def __init__(self, fields, type_table, types):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table, types):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.types = types
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.active_field = field_name
            self.value = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.active_field = field_name
            fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
                   "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(field_type, "8s")
            if fmt == "8s":
                value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
            else:
                value = py_struct.pack(fmt, value)
            self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        if self.field_types[field_name].upper() in self.types:
            return self.value
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ArrayInstance:
    def __init__(self, dimensions, element_type, type_table, types):
        self.dimensions = dimensions
        self.element_type = element_type.upper()
        self.type_table = type_table
        self.types = types
        self.element_size = self._get_size(element_type)
        total_size = 1
        for dim in dimensions:
            total_size *= dim
        self.elements = [None] * total_size
        self.strides = []
        stride = self.element_size
        for dim in reversed(dimensions):
            self.strides.insert(0, stride)
            stride *= dim

    def set_element(self, indices, value):
        index = self._get_index(indices)
        if self.element_type in self.types:
            type_info = self.types[self.element_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"Dizi elemaný için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"Dizi elemaný için UnionInstance bekleniyor")
            self.elements[index] = value
        else:
            expected_type = self.type_table.get(self.element_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Dizi elemaný için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.elements[index] = value

    def get_element(self, indices):
        index = self._get_index(indices)
        return self.elements[index]

    def _get_index(self, indices):
        if len(indices) != len(self.dimensions):
            raise ValueError(f"Beklenen {len(self.dimensions)} indeks, ancak {len(indices)} alýndý")
        for i, idx in enumerate(indices):
            if not 0 <= idx < self.dimensions[i]:
                raise ValueError(f"Geçersiz indeks: {idx}")
        index = 0
        for i, idx in enumerate(indices):
            index += idx * self.strides[i] // self.element_size
        return index

    def _get_size(self, type_name):
        if type_name.upper() in self.types:
            type_info = self.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter, dimensions=None):
        self.address = address
        self.target_type = target_type.upper()
        self.interpreter = interpreter
        self.dimensions = dimensions
        self.element_size = self._get_size(target_type)
        self.strides = None
        if dimensions:
            self.strides = []
            stride = self.element_size
            for dim in reversed(dimensions):
                self.strides.insert(0, stride)
                stride *= dim

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        if self.target_type in self.interpreter.types:
            type_info = self.interpreter.types[self.target_type]
            if type_info["kind"] in ("STRUCT", "CLASS") and not isinstance(value, (StructInstance, ClassInstance)):
                raise TypeError(f"StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION" and not isinstance(value, UnionInstance):
                raise TypeError(f"UnionInstance bekleniyor")
        else:
            expected_type = self.interpreter.type_table.get(self.target_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        if self.dimensions and self.strides:
            new_address = self.address + offset * self.strides[-1]
        else:
            new_address = self.address + offset * self.element_size
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter, self.dimensions)

    def _get_size(self, type_name):
        if type_name.upper() in self.interpreter.types:
            type_info = self.interpreter.types[type_name.upper()]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                return sum(self._get_size(f[1]) for f in type_info["fields"])
            elif type_info["kind"] == "UNION":
                return max(self._get_size(f[1]) for f in type_info["fields"])
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class ClassInstance:
    def __init__(self, class_info, type_table, types, interpreter):
        self.class_info = class_info
        self.type_table = type_table
        self.types = types
        self.interpreter = interpreter
        self.fields = {name: None for name, _ in class_info["fields"] if class_info["access"].get(name, "PUBLIC") == "PUBLIC"}
        self.field_types = {name: type_name for name, type_name in class_info["fields"]}
        self.access = class_info["access"]
        self.methods = class_info["methods"]
        self.parent = class_info.get("parent")

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        field_type = self.field_types[field_name].upper()
        if field_type in self.types:
            type_info = self.types[field_type]
            if type_info["kind"] in ("STRUCT", "CLASS"):
                if not isinstance(value, (StructInstance, ClassInstance)):
                    raise TypeError(f"{field_name} için StructInstance veya ClassInstance bekleniyor")
            elif type_info["kind"] == "UNION":
                if not isinstance(value, UnionInstance):
                    raise TypeError(f"{field_name} için UnionInstance bekleniyor")
            self.fields[field_name] = value
        else:
            expected_type = self.type_table.get(field_type, object)
            if not isinstance(value, expected_type):
                try:
                    value = expected_type(value)
                except:
                    raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
            self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.access.get(field_name, "PUBLIC") == "PRIVATE" and not hasattr(self.interpreter, "current_class"):
            raise ValueError(f"{field_name} özel bir alan")
        return self.fields[field_name]

    def call_method(self, method_name, args):
        if method_name not in self.methods:
            raise ValueError(f"Geçersiz metod: {method_name}")
        method = self.methods[method_name]
        self.interpreter.current_class = self
        self.interpreter.scopes.append({"SELF": self})
        for param, arg in zip(method["params"], args):
            self.interpreter.current_scope()[param[0]] = arg
        for cmd in method["body"]:
            self.interpreter.execute_command(cmd)
        self.interpreter.scopes.pop()
        del self.interpreter.current_class

# pdsXInterpreter sýnýfý
class pdsXInterpreter:
    def __init__(self):
        self.program = []
        self.program_counter = 0
        self.global_vars = {}
        self.scopes = [{}]
        self.running = False
        self.modules = {}
        self.current_module = "main"
        self.types = {}
        self.type_table = {
            "STRING": str, "INTEGER": int, "DOUBLE": float, "BYTE": int,
            "SHORT": int, "LONG": int, "SINGLE": float, "LIST": list, "ARRAY": list, "DICT": dict,
            "POINTER": lambda x: Pointer(None, x, self)
        }
        self.function_table = {}
        self.error_handler = None
        self.repl_mode = False
        self.expr_cache = {}
        self.memory_pool = {}
        self.next_address = 1000
        logging.basicConfig(level=logging.INFO)

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [], "functions": {}, "subs": {}, "classes": {}, "types": {}, "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        current_enum = None
        type_fields = {}
        enum_values = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            # TYPE
            if line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # STRUCT
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
            elif line_upper.startswith("END STRUCT"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[struct_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # UNION
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[union_name]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            # ENUM
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            # CLASS
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+INHERITS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        "fields": [], "methods": {}, "access": {}, "parent": parent_name
                    }
                i += 1
            elif line_upper.startswith("END CLASS"):
                self.types[current_class] = {"kind": "CLASS", **class_info[current_class]}
                self.modules[module_name]["types"][current_class] = self.types[current_class]
                current_class = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"Taným hatasý: {line}")
                i += 1
            elif current_enum:
                match = re.match(r"(\w+)(?:\s*=\s*(\d+))?", line, re.IGNORECASE)
                if match:
                    name, value = match.groups()
                    value = int(value) if value else len(enum_values[current_enum])
                    enum_values[current_enum][name] = value
                else:
                    raise Exception(f"ENUM tanýmý hatasý: {line}")
                i += 1
            elif current_class:
                if line_upper.startswith(("PUBLIC ", "PRIVATE ")):
                    access = "PUBLIC" if line_upper.startswith("PUBLIC ") else "PRIVATE"
                    line = line[len(access):].strip()
                    line_upper = line.upper()
                else:
                    access = "PUBLIC"
                if line_upper.startswith("SUB "):
                    sub_name = line[4:].split("(")[0].strip()
                    params = []
                    if "(" in line and ")" in line:
                        param_str = line[line.index("(")+1:line.index(")")]
                        if param_str.strip():
                            for param in param_str.split(","):
                                param_name, param_type = [x.strip() for x in param.split("AS")]
                                params.append((param_name, param_type))
                    class_info[current_class]["methods"][sub_name] = {"params": params, "body": []}
                    current_sub = sub_name
                    i += 1
                elif line_upper.startswith("END SUB"):
                    current_sub = None
                    i += 1
                elif current_sub:
                    class_info[current_class]["methods"][current_sub]["body"].append(line)
                    i += 1
                else:
                    match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                    if match:
                        field_name, field_type = match.groups()
                        class_info[current_class]["fields"].append((field_name, field_type))
                        class_info[current_class]["access"][field_name] = access
                    else:
                        raise Exception(f"Sýnýf tanýmý hatasý: {line}")
                    i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def current_scope(self):
        return self.scopes[-1]

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        try:
            # DIM
            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)(?:\(([\d, ]+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dim_str, var_type = match.groups()
                    if dim_str:  # Dizi tanýmlama
                        dimensions = [int(d) for d in dim_str.replace(" ", "").split(",")]
                        self.current_scope()[var_name] = ArrayInstance(dimensions, var_type, self.type_table, self.types)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] in ("STRUCT", "CLASS"):
                            self.current_scope()[var_name] = (
                                StructInstance(type_info["fields"], self.type_table, self.types)
                                if type_info["kind"] == "STRUCT"
                                else ClassInstance(type_info, self.type_table, self.types, self)
                            )
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table, self.types)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                        else:
                            raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                        else:
                            raise Exception("POINTER tanýmý hatasý")
                    else:
                        self.current_scope()[var_name] = None
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            # LET
            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(.+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    target, expr = match.groups()
                    if "." in target:
                        parts = target.split(".")
                        instance = self.current_scope().get(parts[0])
                        for field in parts[1:-1]:
                            if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                instance = instance.get_field(field)
                            else:
                                raise Exception(f"Geçersiz alan eriþimi: {target}")
                        field_name = parts[-1]
                        if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                            value = self.evaluate_expression(expr, scope_name)
                            instance.set_field(field_name, value)
                        else:
                            raise Exception(f"{parts[0]} bir struct, union veya sýnýf deðil")
                    elif "*" in target:
                        ptr_name = target.replace("*", "").strip()
                        if ptr_name in self.current_scope():
                            ptr = self.current_scope()[ptr_name]
                            if isinstance(ptr, Pointer):
                                value = self.evaluate_expression(expr, scope_name)
                                ptr.set(value)
                            else:
                                raise Exception(f"{ptr_name} bir iþaretçi deðil")
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    elif "(" in target and ")" in target:
                        match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                        if match_array:
                            var_name, indices_str = match_array.groups()
                            indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                            if var_name in self.current_scope():
                                array = self.current_scope()[var_name]
                                if isinstance(array, ArrayInstance):
                                    value = self.evaluate_expression(expr, scope_name)
                                    array.set_element(indices, value)
                                else:
                                    raise Exception(f"{var_name} bir dizi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {var_name}")
                        else:
                            raise Exception("Dizi eriþiminde sözdizimi hatasý")
                    else:
                        value = self.evaluate_expression(expr, scope_name)
                        if target in self.types and self.types[target]["kind"] == "ENUM":
                            if value in self.types[target]["values"].values():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Geçersiz ENUM deðeri: {value}")
                        else:
                            if target in self.global_vars:
                                self.global_vars[target] = value
                            elif target in self.current_scope():
                                self.current_scope()[target] = value
                            else:
                                raise Exception(f"Tanýmlanmamýþ deðiþken: {target}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # CALL
            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if match:
                    obj_name, method_name, args_str = match.groups()
                    if obj_name in self.current_scope():
                        obj = self.current_scope()[obj_name]
                        if isinstance(obj, ClassInstance):
                            args = []
                            if args_str.strip():
                                args = [self.evaluate_expression(arg.strip(), scope_name) for arg in args_str.split(",")]
                            obj.call_method(method_name, args)
                        else:
                            raise Exception(f"{obj_name} bir sýnýf nesnesi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {obj_name}")
                    return None
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # PRINT
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        if "." in arg:
                            parts_arg = arg.split(".")
                            instance = self.current_scope().get(parts_arg[0])
                            for field in parts_arg[1:]:
                                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                                    instance = instance.get_field(field)
                                else:
                                    raise Exception(f"Geçersiz alan eriþimi: {arg}")
                            output += str(instance)
                        elif "*" in arg:
                            ptr_name = arg.replace("*", "").strip()
                            if ptr_name in self.current_scope():
                                ptr = self.current_scope()[ptr_name]
                                if isinstance(ptr, Pointer):
                                    output += str(ptr.dereference())
                                else:
                                    raise Exception(f"{ptr_name} bir iþaretçi deðil")
                            else:
                                raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                        elif "(" in arg and ")" in arg:
                            match_array = re.match(r"(\w+)\(([\d, ]+)\)", arg)
                            if match_array:
                                var_name, indices_str = match_array.groups()
                                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                if var_name in self.current_scope():
                                    array = self.current_scope()[var_name]
                                    if isinstance(array, ArrayInstance):
                                        output += str(array.get_element(indices))
                                    else:
                                        raise Exception(f"{var_name} bir dizi deðil")
                                else:
                                    raise Exception(f"Deðiþken bulunamadý: {var_name}")
                            else:
                                raise Exception("Dizi eriþiminde sözdizimi hatasý")
                        else:
                            value = self.evaluate_expression(arg, scope_name)
                            output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            # Ýþaretçi Operasyonlarý
            if command_upper.startswith("PTR_SET"):
                match = re.match(r"PTR_SET\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
                if match:
                    ptr_name, expr = match.groups()
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer):
                            if expr.startswith("&"):
                                target = expr[1:].strip()
                                if "(" in target and ")" in target:
                                    match_array = re.match(r"(\w+)\(([\d, ]+)\)", target)
                                    if match_array:
                                        var_name, indices_str = match_array.groups()
                                        indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                                        if var_name in self.current_scope():
                                            array = self.current_scope()[var_name]
                                            if isinstance(array, ArrayInstance):
                                                addr = self.next_address
                                                self.memory_pool[addr] = {
                                                    "value": array.get_element(indices),
                                                    "type": array.element_type,
                                                    "refs": 1
                                                }
                                                self.next_address += array.element_size
                                                ptr.address = addr
                                                ptr.dimensions = array.dimensions
                                            else:
                                                raise Exception(f"{var_name} bir dizi deðil")
                                        else:
                                            raise Exception(f"Deðiþken bulunamadý: {var_name}")
                                    else:
                                        raise Exception("Dizi eriþiminde sözdizimi hatasý")
                                else:
                                    if target in self.current_scope():
                                        addr = self.next_address
                                        self.memory_pool[addr] = {
                                            "value": self.current_scope()[target],
                                            "type": ptr.target_type,
                                            "refs": 1
                                        }
                                        self.next_address += 8
                                        ptr.address = addr
                                    else:
                                        raise Exception(f"Deðiþken bulunamadý: {target}")
                            else:
                                addr = self.evaluate_expression(expr, scope_name)
                                if addr in self.memory_pool:
                                    ptr.address = addr
                                else:
                                    raise Exception(f"Geçersiz adres: {addr}")
                        else:
                            raise Exception(f"{ptr_name} bir iþaretçi deðil")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("PTR_SET komutunda sözdizimi hatasý")

            # Bellek Yönetimi
            if command_upper.startswith("MALLOC"):
                match = re.match(r"MALLOC\s+(\w+)\s+SIZE\s+(\d+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, size, var_type = match.groups()
                    size = int(size)
                    addr = self.next_address
                    self.memory_pool[addr] = {
                        "value": None,
                        "type": var_type,
                        "refs": 1,
                        "size": size
                    }
                    self.next_address += size
                    self.current_scope()[var_name] = Pointer(addr, var_type, self)
                    return None
                else:
                    raise Exception("MALLOC komutunda sözdizimi hatasý")

            if command_upper.startswith("FREE"):
                match = re.match(r"FREE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    ptr_name = match.group(1)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["refs"] -= 1
                            if self.memory_pool[ptr.address]["refs"] <= 0:
                                del self.memory_pool[ptr.address]
                            ptr.address = None
                        else:
                            raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("FREE komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMCPY"):
                match = re.match(r"MEMCPY\s+(\w+)\s+FROM\s+(\w+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    dest_ptr, src_ptr, size = match.groups()
                    size = int(size)
                    if dest_ptr in self.current_scope() and src_ptr in self.current_scope():
                        dest = self.current_scope()[dest_ptr]
                        src = self.current_scope()[src_ptr]
                        if isinstance(dest, Pointer) and isinstance(src, Pointer):
                            if src.address in self.memory_pool and dest.address in self.memory_pool:
                                self.memory_pool[dest.address]["value"] = self.memory_pool[src.address]["value"]
                            else:
                                raise Exception("Geçersiz bellek adresi")
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception("Deðiþken bulunamadý")
                    return None
                else:
                    raise Exception("MEMCPY komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMSET"):
                match = re.match(r"MEMSET\s+(\w+)\s+VALUE\s+(.+)\s+SIZE\s+(\d+)", command, re.IGNORECASE)
                if match:
                    ptr_name, value_expr, size = match.groups()
                    size = int(size)
                    value = self.evaluate_expression(value_expr, scope_name)
                    if ptr_name in self.current_scope():
                        ptr = self.current_scope()[ptr_name]
                        if isinstance(ptr, Pointer) and ptr.address in self.memory_pool:
                            self.memory_pool[ptr.address]["value"] = value
                        else:
                            raise Exception("Geçersiz iþaretçi")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("MEMSET komutunda sözdizimi hatasý")

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        if "." in expr:
            parts = expr.split(".")
            instance = self.current_scope().get(parts[0])
            for field in parts[1:]:
                if isinstance(instance, (StructInstance, UnionInstance, ClassInstance)):
                    instance = instance.get_field(field)
                else:
                    raise Exception(f"Geçersiz alan eriþimi: {expr}")
            return instance
        elif "*" in expr:
            ptr_name = expr.replace("*", "").strip()
            if ptr_name in self.current_scope():
                ptr = self.current_scope()[ptr_name]
                if isinstance(ptr, Pointer):
                    return ptr.dereference()
            raise Exception(f"Geçersiz iþaretçi: {expr}")
        elif "(" in expr and ")" in expr:
            match_array = re.match(r"(\w+)\(([\d, ]+)\)", expr)
            if match_array:
                var_name, indices_str = match_array.groups()
                indices = [int(i) for i in indices_str.replace(" ", "").split(",")]
                if var_name in self.current_scope():
                    array = self.current_scope()[var_name]
                    if isinstance(array, ArrayInstance):
                        return array.get_element(indices)
                raise Exception(f"Geçersiz dizi eriþimi: {expr}")
            else:
                raise Exception("Dizi eriþiminde sözdizimi hatasý")
        elif expr in self.types and self.types[expr]["kind"] == "ENUM":
            return self.types[expr]["values"]
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope_name = self.program[self.program_counter]
            self.execute_command(command, scope_name)
            self.program_counter += 1
            
            

# Dosya: pdsX v11C -m.py
import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
from threading import Thread
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh,
            "COSH": math.cosh,
            "TANH": math.tanh,
            "ASINH": math.asinh,
            "ACOSH": math.acosh,
            "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi,
            "E": math.e,
            "BIN": bin,
            "HEX": hex,
            "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.get_ident(),
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {"en": {"PRINT": "Print", "ERROR": "Error"}}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        pass

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+([^\s]+)(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON GOSUB"):
                match = re.match(r"ON GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.gosub_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON GOSUB komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                parts = command[5:].strip().split()
                args = [self.evaluate_expression(arg, scope_name) for arg in parts]
                print(*args)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type.upper() == "STRUCT":
                        self.current_scope()[var_name] = StructInstance([], self.type_table)
                    elif var_type.upper() == "UNION":
                        self.current_scope()[var_name] = UnionInstance([], self.type_table)
                    else:
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition, then_cmd = match.groups()
                    if self.evaluate_expression(condition, scope_name):
                        return self.execute_command(then_cmd, scope_name)
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    loop_info = self.loop_stack[-1]
                    condition = loop_info["condition"]
                    if loop_info["type"] == "WHILE" and not self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL" and self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "NONE":
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("TRY"):
                match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)", command, re.IGNORECASE)
                if match:
                    try_block, error_var, catch_block = match.groups()
                    try:
                        self.execute_command(try_block, scope_name)
                    except Exception as e:
                        self.current_scope()[error_var] = str(e)
                        self.execute_command(catch_block, scope_name)
                    return None
                else:
                    raise Exception("TRY...CATCH komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("PERFORMANCE"):
                process = psutil.Process()
                memory = process.memory_info().rss / 1024 / 1024
                cpu = psutil.cpu_percent()
                elapsed = time.time() - self.performance_metrics["start_time"]
                print(f"Performans: Bellek: {memory:.2f} MB, CPU: {cpu:.2f}%, Süre: {elapsed:.2f}s")
                return None

            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                    else:
                        raise Exception(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("CALL"):
                if command_upper.startswith("CALL API::GET"):
                    match = re.match(r"CALL API::GET\s+(.+)", command, re.IGNORECASE)
                    if match:
                        url = match.group(1)
                        return requests.get(url).json()
                elif command_upper.startswith("CALL"):
                    match = re.match(r"CALL\s+(\w+)::(\w+)\((.*)\)", command, re.IGNORECASE)
                    if match:
                        dll_name, func_name, args = match.groups()
                        dll = self.core.load_dll(dll_name)
                        func = getattr(dll, func_name)
                        arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in args.split(",") if arg.strip()]
                        return func(*arg_list)
                raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("HELP"):
                match = re.match(r"HELP\s*(\w+)?", command, re.IGNORECASE)
                if match:
                    lib_name = match.group(1)
                    self.show_help(lib_name)
                    return None
                else:
                    raise Exception("HELP komutunda sözdizimi hatasý")

            if command_upper.startswith("CORE."):
                func_name = command_upper.split(".")[1]
                args = re.match(r"CORE\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if args:
                    _, arg_str = args.groups()
                    arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in arg_str.split(",") if arg.strip()]
                    return getattr(self.core, func_name.lower())(*arg_list)
                else:
                    return getattr(self.core, func_name.lower())()

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            logging.error(f"Hata: {str(e)}\n{''.join(traceback.format_stack())}")
            if self.error_handler:
                return self.error_handler
            elif self.gosub_handler:
                return self.gosub_handler
            else:
                raise e

    def show_help(self, lib_name=None):
        if lib_name:
            help_file = f"{lib_name}/{lib_name}_help.json"
            if os.path.exists(help_file):
                with open(help_file, "r", encoding="utf-8") as f:
                    help_data = json.load(f)
                for cmd in help_data.get(lib_name, {}).get("commands", []):
                    print(f"Komut: {cmd['name']}")
                    print(f"Kullaným: {cmd['usage']}")
                    print(f"Amaç: {cmd['purpose']}")
                    print(f"Örnek: {cmd['example']}")
                    print("-" * 50)
            else:
                print(f"Yardým dosyasý bulunamadý: {lib_name}")
        else:
            print("Kullaným: HELP [kütüphane_adý]")
            print("Örnek: HELP libx_core")

    def run(self, code):
        self.program = []
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        try:
            while self.running and self.program_counter < len(self.program):
                cmd, scope = self.program[self.program_counter]
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
        except Exception as e:
            if self.error_handler:
                self.program_counter = self.error_handler
            elif self.gosub_handler:
                self.program_counter = self.gosub_handler
            else:
                raise e
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        while True:
            try:
                cmd = input("> ")
                if cmd.upper() == "EXIT":
                    break
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        lines = code.split("\n")
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            tokens = line.split(maxsplit=1)
            opcode = tokens[0].upper()
            operands = tokens[1] if len(tokens) > 1 else ""
            self.bytecode.append({"opcode": opcode, "operands": operands, "line": i + 1})
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            instruction = self.bytecode[pc]
            opcode = instruction["opcode"]
            operands = instruction["operands"]
            try:
                if opcode == "PRINT":
                    print(self.evaluate_expression(operands))
                elif opcode == "LET":
                    var, val = operands.split("=", 1)
                    self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
                elif opcode == "DIM":
                    var_name, var_type = operands.split("AS")
                    self.current_scope()[var_name.strip()] = self.type_table.get(var_type.strip().upper(), object)()
                elif opcode == "IF":
                    condition, then_cmd = operands.split("THEN")
                    if self.evaluate_expression(condition.strip()):
                        self.execute_command(then_cmd.strip())
                elif opcode == "GOTO":
                    label = operands.strip()
                    for i, instr in enumerate(self.bytecode):
                        if instr["opcode"] == "LABEL" and instr["operands"] == label:
                            pc = i
                            break
                pc += 1
            except Exception as e:
                logging.error(f"Bayt kodu hatasý: Satýr {instruction['line']}, {str(e)}")
                if self.error_handler:
                    pc = self.error_handler
                else:
                    raise e
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsx_v10_manus.py
import sys
import subprocess
import importlib.metadata
import platform
import json  # Çoklu dil desteði için gerekli
import threading  # Paralel programlama için gerekli
import asyncio  # Asenkron programlama için gerekli
import ast  # AST modülü ifadeleri önbelleðe almak için kullanýlacak
import math  # Matematiksel fonksiyonlar için gerekli
import re
import logging
import struct as py_struct
from collections import namedtuple

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4',
        'readline': 'pyreadline3' if platform.system() == 'Windows' else 'readline'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    if platform.system() == 'Windows':
        import pyreadline3 as readline
    else:
        import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için
import time  # Performans ölçümü için gerekli
import struct as py_struct
from collections import namedtuple
# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)  # Maksimum alan boyutu
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = py_struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }
        self.memory_manager = MemoryManager()
        self.operator_table = self._init_operator_table()
        self.function_table = self._init_function_table()
        self.memory_pool = {}  # Sanal bellek havuzu
        self.next_address = 1000  # Baþlangýç adresi
        self.expr_cache = {}  # Ýfade önbelleði
        self.variable_cache = {}  # Deðiþken eriþim önbelleði
        self.language = "en"  # Varsayýlan dil
        self.translations = self.load_translations("lang.json")
        self.bytecode = []  # Bayt kodu depolamak için

    def load_translations(self, file_path):
        """Dil dosyasýný yükler."""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {}

    def translate(self, key):
        """Anahtar kelimeleri ve mesajlarý çevirir."""
        return self.translations.get(self.language, {}).get(key, key)

    def _init_operator_table(self):
        """C tarzý operatörleri içeren tablo"""
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _init_function_table(self):
        """Matematiksel ve diðer fonksiyonlar"""
        funcs = {
            'SINH': math.sinh,
            'COSH': math.cosh,
            'TANH': math.tanh,
            'ASINH': math.asinh,
            'ACOSH': math.acosh,
            'ATANH': math.atanh,
            'SIND': lambda x: math.sin(math.radians(x)),
            'COSD': lambda x: math.cos(math.radians(x)),
            'TAND': lambda x: math.tan(math.radians(x)),
            'PI': math.pi,
            'E': math.e,
            'BIN': bin,
            'HEX': hex,
            'OCT': oct,
            'ADDR': lambda x: id(x),
            'SIZEOF': lambda x: self.memory_manager.sizeof(x),
            'NEW': self.memory_manager.allocate,
            'DELETE': self.memory_manager.release
        }
        for name in ['sin', 'cos', 'tan', 'log', 'exp', 'sqrt', 'ceil', 'floor']:
            funcs[name.upper()] = getattr(math, name)
        return funcs

    def _increment(self, x):
        """Bir deðeri bir artýrýr."""
        if isinstance(x, (int, float)):
            return x + 1
        raise TypeError("_increment sadece sayýsal deðerler için geçerlidir.")

    def _decrement(self, x):
        """Bir deðeri bir azaltýr."""
        if isinstance(x, (int, float)):
            return x - 1
        raise TypeError("_decrement sadece sayýsal deðerler için geçerlidir.")

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        """Ýfadeleri AST ile önbelleðe alarak deðerlendirir."""
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        # Deðiþken eriþimlerini optimize etmek için mevcut kapsamý önbelleðe al
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types and self.types[var_type]["kind"] == "STRUCT":
                        self.current_scope()[var_name] = StructInstance(self.types[var_type]["fields"], self.type_table)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            # Komut bulunamadý
            raise Exception(f"Tanýnmayan komut: {command}")

        except Exception as e:
            if self.error_handler:
                if self.error_handler == "RESUME":
                    print(f"Hata: {e}")
                    return None
                else:
                    print(f"Hata: {e}")
                    return self.error_handler
            else:
                raise

    def run(self, code=None):
        """Programý çalýþtýrýr."""
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                input("Devam için Enter...")
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def repl(self):
        """Etkileþimli yorumlayýcý."""
        self.repl_mode = True
        print("pdsX Etkileþimli Yorumlayýcý v1.0")
        print("Çýkýþ için 'EXIT' yazýn.")
        while True:
            try:
                command = input("> ")
                if command.upper() == "EXIT":
                    break
                result = self.execute_command(command)
                if result is not None and result != self.program_counter + 1:
                    print(f"Sonuç: {result}")
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        """Kodu bayt koduna derler."""
        bytecode = []
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # Basit bir bayt kodu oluþturma
            tokens = line.split()
            if tokens:
                opcode = tokens[0].upper()
                operands = tokens[1:] if len(tokens) > 1 else []
                bytecode.append((opcode, operands))
        return bytecode

    def execute_bytecode(self):
        """Bayt kodunu çalýþtýrýr."""
        if not self.bytecode:
            raise Exception("Bayt kodu bulunamadý")
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.bytecode):
            opcode, operands = self.bytecode[self.program_counter]
            # Bayt kodu iþleme
            if opcode == "PRINT":
                print(" ".join(operands))
            elif opcode == "LET":
                var_name = operands[0]
                value = " ".join(operands[2:])
                self.current_scope()[var_name] = self.evaluate_expression(value)
            # Diðer opcode'lar...
            self.program_counter += 1
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsX Yorumlayýcý')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    parser.add_argument('-d', '--debug', action='store_true', help='Hata ayýklama modu')
    parser.add_argument('-t', '--trace', action='store_true', help='Ýzleme modu')
    parser.add_argument('-c', '--compile', action='store_true', help='Derleme modu')
    args = parser.parse_args()

    interpreter = pdsXInterpreter()
    
    if args.debug:
        interpreter.debug_mode = True
    
    if args.trace:
        interpreter.trace_mode = True
    
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        if args.compile:
            interpreter.bytecode = interpreter.compile_to_bytecode(code)
            interpreter.execute_bytecode()
        else:
            interpreter.run(code)
    
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()


# Dosya: pdsX_v12chatgpt.py
bu asagidaki kodun adi pdsv11c.py

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
from threading import Thread
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata
import readline


# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

# SQLite Ýþlemleri için
class LibDB:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)
        self.cur = self.conn.cursor()

    def execute(self, query, params=()):
        self.cur.execute(query, params)
        self.conn.commit()

    def fetchall(self, query, params=()):
        self.cur.execute(query, params)
        return self.cur.fetchall()

    def close(self):
        self.conn.close()


# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}
    
    @staticmethod
    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})
    
    @classmethod
    def omega_cls(cls, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh,
            "COSH": math.cosh,
            "TANH": math.tanh,
            "ASINH": math.asinh,
            "ACOSH": math.acosh,
            "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi,
            "E": math.e,
            "BIN": bin,
            "HEX": hex,
            "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.get_ident(),
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def save_bytecode(self, path):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(self.bytecode, f, indent=2)

    def load_bytecode(self, path):
    with open(path, "r", encoding="utf-8") as f:
        self.bytecode = json.load(f)

    
    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {"en": {"PRINT": "Print", "ERROR": "Error"}}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
            # mevcut kodun baþýna þunu ekle:
        if not file_name.endswith(('.basx', '.libx', '.hx', '.hz')):
            raise Exception("Yalnýzca .basX, .libX, .hX ve .hz dosyalarý destekleniyor")
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        pass

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        # ?? execute_command fonksiyonunun BAÞINA ekle (ilk satýra):

# Çoklu komut ayýrýcý (: ayracý destekli)
if ':' in command and not command.strip().startswith(('PRINT', 'INPUT', 'LET', 'DIM', 'IF', 'FOR', 'WHILE', 'DO', 'GOTO', 'GOSUB', 'TRY', 'CALL', 'HELP', 'CORE.', 'DEBUG', 'TRACE', 'STEP', 'PERFORMANCE', 'SET LANGUAGE')):
    subcommands = command.split(':')
    for subcmd in subcommands:
        subcmd = subcmd.strip()
        if subcmd:
            self.execute_command(subcmd, scope_name)
    return None

        
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+([^\s]+)(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON GOSUB"):
                match = re.match(r"ON GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.gosub_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON GOSUB komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                parts = command[5:].strip().split()
                args = [self.evaluate_expression(arg, scope_name) for arg in parts]
                print(*args)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type.upper() == "STRUCT":
                        self.current_scope()[var_name] = StructInstance([], self.type_table)
                    elif var_type.upper() == "UNION":
                        self.current_scope()[var_name] = UnionInstance([], self.type_table)
                    else:
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition, then_cmd = match.groups()
                    if self.evaluate_expression(condition, scope_name):
                        return self.execute_command(then_cmd, scope_name)
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    loop_info = self.loop_stack[-1]
                    condition = loop_info["condition"]
                    if loop_info["type"] == "WHILE" and not self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL" and self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "NONE":
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("TRY"):
                match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)(?:\s+FINALLY\s+(.+))?", command, re.IGNORECASE)
                if match:
                    try_block, error_var, catch_block, finally_block = match.groups()
                    try:
                        self.execute_command(try_block, scope_name)
                    except Exception as e:
                        self.current_scope()[error_var] = str(e)
                        self.execute_command(catch_block, scope_name)
                    finally:
                        if finally_block:
                            self.execute_command(finally_block, scope_name)
                    return None
                else:
                    raise Exception("TRY...CATCH...FINALLY komutunda sözdizimi hatasý")

#             if command_upper.startswith("TRY"):
#                 match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)", command, re.IGNORECASE)
#                 if match:
#                     try_block, error_var, catch_block = match.groups()
#                     try:
#                         self.execute_command(try_block, scope_name)
#                     except Exception as e:
#                         self.current_scope()[error_var] = str(e)
#                         self.execute_command(catch_block, scope_name)
#                     return None
#                 else:
#                     raise Exception("TRY...CATCH komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("PERFORMANCE"):
                process = psutil.Process()
                memory = process.memory_info().rss / 1024 / 1024
                cpu = psutil.cpu_percent()
                elapsed = time.time() - self.performance_metrics["start_time"]
                print(f"Performans: Bellek: {memory:.2f} MB, CPU: {cpu:.2f}%, Süre: {elapsed:.2f}s")
                return None

            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                    else:
                        raise Exception(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("CALL"):
                if command_upper.startswith("CALL API::GET"):
                    match = re.match(r"CALL API::GET\s+(.+)", command, re.IGNORECASE)
                    if match:
                        url = match.group(1)
                        return requests.get(url).json()
                elif command_upper.startswith("CALL"):
                    match = re.match(r"CALL\s+(\w+)::(\w+)\((.*)\)", command, re.IGNORECASE)
                    if match:
                        dll_name, func_name, args = match.groups()
                        dll = self.core.load_dll(dll_name)
                        func = getattr(dll, func_name)
                        arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in args.split(",") if arg.strip()]
                        return func(*arg_list)
                raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("HELP"):
                match = re.match(r"HELP\s*(\w+)?", command, re.IGNORECASE)
                if match:
                    lib_name = match.group(1)
                    self.show_help(lib_name)
                    return None
                else:
                    raise Exception("HELP komutunda sözdizimi hatasý")

            if command_upper.startswith("CORE."):
                func_name = command_upper.split(".")[1]
                args = re.match(r"CORE\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if args:
                    _, arg_str = args.groups()
                    arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in arg_str.split(",") if arg.strip()]
                    return getattr(self.core, func_name.lower())(*arg_list)
                else:
                    return getattr(self.core, func_name.lower())()

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            logging.error(f"Hata: {str(e)}\n{''.join(traceback.format_stack())}")
            if self.error_handler:
                return self.error_handler
            elif self.gosub_handler:
                return self.gosub_handler
            else:
                raise e

    def show_help(self, lib_name=None):
        if lib_name:
            help_file = f"{lib_name}/{lib_name}_help.json"
            if os.path.exists(help_file):
                with open(help_file, "r", encoding="utf-8") as f:
                    help_data = json.load(f)
                for cmd in help_data.get(lib_name, {}).get("commands", []):
                    print(f"Komut: {cmd['name']}")
                    print(f"Kullaným: {cmd['usage']}")
                    print(f"Amaç: {cmd['purpose']}")
                    print(f"Örnek: {cmd['example']}")
                    print("-" * 50)
            else:
                print(f"Yardým dosyasý bulunamadý: {lib_name}")
        else:
            print("Kullaným: HELP [kütüphane_adý]")
            print("Örnek: HELP libx_core")

    def run(self, code):
        self.program = []
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        try:
            while self.running and self.program_counter < len(self.program):
                cmd, scope = self.program[self.program_counter]
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
        except Exception as e:
            if self.error_handler:
                self.program_counter = self.error_handler
            elif self.gosub_handler:
                self.program_counter = self.gosub_handler
            else:
                raise e
        self.running = False

    

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        commands = list(self.function_table.keys()) + ['PRINT', 'LET', 'INPUT', 'IMPORT']
        readline.set_completer(lambda text, state: [cmd for cmd in commands if cmd.startswith(text.upper())][state] if state < len([cmd for cmd in commands if cmd.startswith(text.upper())]) else None)
        readline.parse_and_bind('tab: complete')
        while True:
            try:
                cmd = input("> ")
                if cmd.upper() == "EXIT":
                    break
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False


#     def repl(self):
#         self.repl_mode = True
#         print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
#         while True:
#             try:
#                 cmd = input("> ")
#                 if cmd.upper() == "EXIT":
#                     break
#                 self.execute_command(cmd)
#             except Exception as e:
#                 print(f"Hata: {e}")
#         self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        lines = code.split("\n")
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            tokens = line.split(maxsplit=1)
            opcode = tokens[0].upper()
            operands = tokens[1] if len(tokens) > 1 else ""
            self.bytecode.append({"opcode": opcode, "operands": operands, "line": i + 1})
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            instruction = self.bytecode[pc]
            opcode = instruction["opcode"]
            operands = instruction["operands"]
            try:
                if opcode == "PRINT":
                    print(self.evaluate_expression(operands))
                elif opcode == "LET":
                    var, val = operands.split("=", 1)
                    self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
                elif opcode == "DIM":
                    var_name, var_type = operands.split("AS")
                    self.current_scope()[var_name.strip()] = self.type_table.get(var_type.strip().upper(), object)()
                elif opcode == "IF":
                    condition, then_cmd = operands.split("THEN")
                    if self.evaluate_expression(condition.strip()):
                        self.execute_command(then_cmd.strip())
                elif opcode == "GOTO":
                    label = operands.strip()
                    for i, instr in enumerate(self.bytecode):
                        if instr["opcode"] == "LABEL" and instr["operands"] == label:
                            pc = i
                            break
                pc += 1
            except Exception as e:
                logging.error(f"Bayt kodu hatasý: Satýr {instruction['line']}, {str(e)}")
                if self.error_handler:
                    pc = self.error_handler
                else:
                    raise e
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()


# Dosya: pdsXv11c.py
bu asagidaki kodun adi pdsv11c.py

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
from threading import Thread
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh,
            "COSH": math.cosh,
            "TANH": math.tanh,
            "ASINH": math.asinh,
            "ACOSH": math.acosh,
            "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi,
            "E": math.e,
            "BIN": bin,
            "HEX": hex,
            "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.get_ident(),
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {"en": {"PRINT": "Print", "ERROR": "Error"}}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        pass

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+([^\s]+)(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON GOSUB"):
                match = re.match(r"ON GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.gosub_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON GOSUB komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                parts = command[5:].strip().split()
                args = [self.evaluate_expression(arg, scope_name) for arg in parts]
                print(*args)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type.upper() == "STRUCT":
                        self.current_scope()[var_name] = StructInstance([], self.type_table)
                    elif var_type.upper() == "UNION":
                        self.current_scope()[var_name] = UnionInstance([], self.type_table)
                    else:
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition, then_cmd = match.groups()
                    if self.evaluate_expression(condition, scope_name):
                        return self.execute_command(then_cmd, scope_name)
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    loop_info = self.loop_stack[-1]
                    condition = loop_info["condition"]
                    if loop_info["type"] == "WHILE" and not self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL" and self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "NONE":
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("TRY"):
                match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)", command, re.IGNORECASE)
                if match:
                    try_block, error_var, catch_block = match.groups()
                    try:
                        self.execute_command(try_block, scope_name)
                    except Exception as e:
                        self.current_scope()[error_var] = str(e)
                        self.execute_command(catch_block, scope_name)
                    return None
                else:
                    raise Exception("TRY...CATCH komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("PERFORMANCE"):
                process = psutil.Process()
                memory = process.memory_info().rss / 1024 / 1024
                cpu = psutil.cpu_percent()
                elapsed = time.time() - self.performance_metrics["start_time"]
                print(f"Performans: Bellek: {memory:.2f} MB, CPU: {cpu:.2f}%, Süre: {elapsed:.2f}s")
                return None

            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                    else:
                        raise Exception(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("CALL"):
                if command_upper.startswith("CALL API::GET"):
                    match = re.match(r"CALL API::GET\s+(.+)", command, re.IGNORECASE)
                    if match:
                        url = match.group(1)
                        return requests.get(url).json()
                elif command_upper.startswith("CALL"):
                    match = re.match(r"CALL\s+(\w+)::(\w+)\((.*)\)", command, re.IGNORECASE)
                    if match:
                        dll_name, func_name, args = match.groups()
                        dll = self.core.load_dll(dll_name)
                        func = getattr(dll, func_name)
                        arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in args.split(",") if arg.strip()]
                        return func(*arg_list)
                raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("HELP"):
                match = re.match(r"HELP\s*(\w+)?", command, re.IGNORECASE)
                if match:
                    lib_name = match.group(1)
                    self.show_help(lib_name)
                    return None
                else:
                    raise Exception("HELP komutunda sözdizimi hatasý")

            if command_upper.startswith("CORE."):
                func_name = command_upper.split(".")[1]
                args = re.match(r"CORE\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if args:
                    _, arg_str = args.groups()
                    arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in arg_str.split(",") if arg.strip()]
                    return getattr(self.core, func_name.lower())(*arg_list)
                else:
                    return getattr(self.core, func_name.lower())()

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            logging.error(f"Hata: {str(e)}\n{''.join(traceback.format_stack())}")
            if self.error_handler:
                return self.error_handler
            elif self.gosub_handler:
                return self.gosub_handler
            else:
                raise e

    def show_help(self, lib_name=None):
        if lib_name:
            help_file = f"{lib_name}/{lib_name}_help.json"
            if os.path.exists(help_file):
                with open(help_file, "r", encoding="utf-8") as f:
                    help_data = json.load(f)
                for cmd in help_data.get(lib_name, {}).get("commands", []):
                    print(f"Komut: {cmd['name']}")
                    print(f"Kullaným: {cmd['usage']}")
                    print(f"Amaç: {cmd['purpose']}")
                    print(f"Örnek: {cmd['example']}")
                    print("-" * 50)
            else:
                print(f"Yardým dosyasý bulunamadý: {lib_name}")
        else:
            print("Kullaným: HELP [kütüphane_adý]")
            print("Örnek: HELP libx_core")

    def run(self, code):
        self.program = []
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        try:
            while self.running and self.program_counter < len(self.program):
                cmd, scope = self.program[self.program_counter]
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
        except Exception as e:
            if self.error_handler:
                self.program_counter = self.error_handler
            elif self.gosub_handler:
                self.program_counter = self.gosub_handler
            else:
                raise e
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        while True:
            try:
                cmd = input("> ")
                if cmd.upper() == "EXIT":
                    break
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        lines = code.split("\n")
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            tokens = line.split(maxsplit=1)
            opcode = tokens[0].upper()
            operands = tokens[1] if len(tokens) > 1 else ""
            self.bytecode.append({"opcode": opcode, "operands": operands, "line": i + 1})
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            instruction = self.bytecode[pc]
            opcode = instruction["opcode"]
            operands = instruction["operands"]
            try:
                if opcode == "PRINT":
                    print(self.evaluate_expression(operands))
                elif opcode == "LET":
                    var, val = operands.split("=", 1)
                    self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
                elif opcode == "DIM":
                    var_name, var_type = operands.split("AS")
                    self.current_scope()[var_name.strip()] = self.type_table.get(var_type.strip().upper(), object)()
                elif opcode == "IF":
                    condition, then_cmd = operands.split("THEN")
                    if self.evaluate_expression(condition.strip()):
                        self.execute_command(then_cmd.strip())
                elif opcode == "GOTO":
                    label = operands.strip()
                    for i, instr in enumerate(self.bytecode):
                        if instr["opcode"] == "LABEL" and instr["operands"] == label:
                            pc = i
                            break
                pc += 1
            except Exception as e:
                logging.error(f"Bayt kodu hatasý: Satýr {instruction['line']}, {str(e)}")
                if self.error_handler:
                    pc = self.error_handler
                else:
                    raise e
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsXv11grok.py
# grok yazdirdi. 27.nisan.2025 mete dinler.

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
import threading
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}
        self.bitfields = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]
                self.bitfields.pop(ptr, None)

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()
            elif isinstance(value, (list, np.ndarray)):
                self.heap[ptr][:] = value.tobytes() if hasattr(value, 'tobytes') else bytes(value)

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return sys.getsizeof(obj)

    def set_bitfield(self, ptr: int, field: str, value: int, bits: int):
        if ptr not in self.heap:
            raise ValueError(f"Geçersiz iþaretçi: {ptr}")
        if bits not in (1, 2, 4, 8, 16, 32, 64):
            raise ValueError(f"Geçersiz bit uzunluðu: {bits}")
        self.bitfields.setdefault(ptr, {})[field] = (value, bits)

    def get_bitfield(self, ptr: int, field: str):
        if ptr not in self.bitfields or field not in self.bitfields[ptr]:
            raise ValueError(f"Geçersiz bit alaný: {ptr}.{field}")
        value, _ = self.bitfields[ptr][field]
        return value

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8,
            "BITFIELD": 4, "ENUM": 4
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(max(self._get_size(t) for _, t in fields))
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f", "BITFIELD": "i", "ENUM": "i"}.get(
            self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f", "BITFIELD": "i", "ENUM": "i"}.get(
            self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8,
            "BITFIELD": 4, "ENUM": 4
        }
        return size_map.get(type_name.upper(), 8)

class EnumInstance:
    def __init__(self, values):
        self.values = values
        self.current = None

    def set_value(self, value):
        if value in self.values:
            self.current = value
        else:
            raise ValueError(f"Geçersiz ENUM deðeri: {value}")

    def get_value(self):
        return self.current

    def get_index(self):
        return list(self.values.keys()).index(self.current) if self.current in self.values else -1

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXLowLevel Sýnýfý
class LibXLowLevel:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.memory_manager = interpreter.memory_manager

    def alloc(self, size: int):
        return self.memory_manager.allocate(size)

    def free(self, ptr: int):
        self.memory_manager.release(ptr)

    def bitset(self, ptr: int, field: str, value: int, bits: int):
        self.memory_manager.set_bitfield(ptr, field, value, bits)

    def bitget(self, ptr: int, field: str):
        return self.memory_manager.get_bitfield(ptr, field)

    def memcpy(self, dest_ptr: int, src_ptr: int, size: int):
        if dest_ptr in self.memory_manager.heap and src_ptr in self.memory_manager.heap:
            self.memory_manager.heap[dest_ptr][:size] = self.memory_manager.heap[src_ptr][:size]
        else:
            raise ValueError("Geçersiz iþaretçi")

    def memset(self, ptr: int, value: int, size: int):
        if ptr in self.memory_manager.heap:
            self.memory_manager.heap[ptr][:size] = bytes([value]) * size
        else:
            raise ValueError("Geçersiz iþaretçi")

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        elif isinstance(value, np.ndarray):
            return "ARRAY"
        elif isinstance(value, pd.DataFrame):
            return "DATAFRAME"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.interfaces = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.lowlevel = LibXLowLevel(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0, "cpu_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8",
            "utf-8-sig", "utf-8-bom-less"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh, "COSH": math.cosh, "TANH": math.tanh,
            "ASINH": math.asinh, "ACOSH": math.acosh, "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi, "E": math.e,
            "BIN": bin, "HEX": hex, "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": threading.active_count,
            "CURRENT_THREAD": threading.get_ident,
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce,
            "OMEGA": self.core.omega,
            "LIST_LIB": self.core.list_lib,
            "EACH": self.core.each,
            "SELECT": self.core.select,
            "INSERT": self.core.insert,
            "REMOVE": self.core.remove,
            "POP": self.core.pop,
            "CLEAR": self.core.clear,
            "SLICE": self.core.slice,
            "KEYS": self.core.keys,
            "TIME_NOW": self.core.time_now,
            "DATE_NOW": self.core.date_now,
            "TIMER": self.core.timer,
            "RANDOM_INT": self.core.random_int,
            "ASSERT": self.core.assert_,
            "LOG": self.core.log,
            "IFTHEN": self.core.ifthen,
            "EXISTS": self.core.exists,
            "MKDIR": self.core.mkdir,
            "GETENV": self.core.getenv,
            "EXIT": self.core.exit,
            "JOIN_PATH": self.core.join_path,
            "COPY_FILE": self.core.copy_file,
            "MOVE_FILE": self.core.move_file,
            "DELETE_FILE": self.core.delete_file,
            "FLOOR": self.core.floor,
            "CEIL": self.core.ceil,
            "SPLIT": self.core.split,
            "JOIN": self.core.join,
            "READ_LINES": self.core.read_lines,
            "WRITE_JSON": self.core.write_json,
            "READ_JSON": self.core.read_json,
            "LIST_DIR": self.core.list_dir,
            "PING": self.core.ping,
            "SUM": self.core.sum,
            "MEAN": self.core.mean,
            "MIN": self.core.min,
            "MAX": self.core.max,
            "ROUND": self.core.round,
            "TRIM": self.core.trim,
            "REPLACE": self.core.replace,
            "FORMAT": self.core.format,
            "TRACE": self.core.trace,
            "TRY_CATCH": self.core.try_catch,
            "SLEEP": self.core.sleep,
            "DATE_DIFF": self.core.date_diff,
            "RUN_ASYNC": self.core.run_async,
            "WAIT": self.core.wait,
            "MERGE": self.core.merge,
            "SORT": self.core.sort,
            "MEMORY_USAGE": self.core.memory_usage,
            "CPU_COUNT": self.core.cpu_count,
            "TYPE_OF": self.core.type_of,
            "IS_EMPTY": self.core.is_empty,
            "LEN": self.core.len,
            "VAL": self.core.val,
            "STR": self.core.str,
            "LISTFILE": self.core.listfile,
            "STACK": self.core.stack,
            "PUSH": self.core.push,
            "POP": self.core.pop,
            "QUEUE": self.core.queue,
            "ENQUEUE": self.core.enqueue,
            "DEQUEUE": self.core.dequeue,
            "LOAD_HZ": self.core.load_hz,
            "OPEN": self.core.open,
            "LOAD_DLL": self.core.load_dll,
            "LOAD_API": self.core.load_api,
            "VERSION": self.core.version,
            "REQUIRE_VERSION": self.core.require_version,
            "SET_ENCODING": self.core.set_encoding,
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {
                "en": {"PRINT": "Print", "ERROR": "Error", "LET": "Let", "DIM": "Dim"},
                "tr": {"PRINT": "Yaz", "ERROR": "Hata", "LET": "Atama", "DIM": "Tanýmla"}
            }

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "interfaces": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        current_interface = None
        type_fields = {}
        class_info = {}
        interface_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                match = re.match(r"SUB\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": i + 1, "params": params}
                    self.modules[module_name]["subs"][sub_name] = i + 1
                    current_sub = sub_name
                    i += 1
                else:
                    raise Exception("SUB komutunda sözdizimi hatasý")
            elif line_upper.startswith("FUNCTION "):
                match = re.match(r"FUNCTION\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": i + 1, "params": params}
                    self.modules[module_name]["functions"][func_name] = i + 1
                    current_function = func_name
                    i += 1
                else:
                    raise Exception("FUNCTION komutunda sözdizimi hatasý")
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_type = enum_name
                enum_values[enum_name] = {}
                value_index = 0
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END ENUM"):
                    value_name = lines[i].strip()
                    if value_name:
                        enum_values[enum_name][value_name] = value_index
                        value_index += 1
                    i += 1
                self.types[enum_name] = {"kind": "ENUM", "values": enum_values[enum_name]}
                self.modules[module_name]["types"][enum_name] = self.types[enum_name]
                current_type = None
                i += 1
                continue
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                        if match:
                            field_name, field_type = match.groups()
                            type_fields[struct_name].append((field_name, field_type))
                        else:
                            raise Exception(f"STRUCT tanýmý hatasý: {field_line}")
                    i += 1
                self.types[struct_name] = {"kind": "STRUCT", "fields": type_fields[struct_name]}
                self.modules[module_name]["types"][struct_name] = self.types[struct_name]
                current_type = None
                i += 1
                continue
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?(?:\s+IMPLEMENTS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name, interface_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'interfaces': [interface_name] if interface_name else [],
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?(?:\s+IMPLEMENTS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name, interface_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'interfaces': [interface_name] if interface_name else [],
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("INTERFACE "):
                interface_name = line[10:].strip()
                current_interface = interface_name
                interface_info[interface_name] = {'methods': {}}
                i += 1
            elif line_upper.startswith("END INTERFACE"):
                self.interfaces[current_interface] = interface_info[current_interface]
                self.modules[module_name]["interfaces"][current_interface] = interface_info[current_interface]
                current_interface = None
                i += 1
            elif current_interface and line_upper.startswith("DECLARE "):
                match = re.match(r"DECLARE\s+(SUB|FUNCTION)\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_type, method_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    interface_info[current_interface]['methods'][method_name] = {
                        'type': method_type,
                        'params': params
                    }
                    i += 1
                else:
                    raise Exception("INTERFACE DECLARE komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                interfaces = class_info[current_class]['interfaces']
                for iface in interfaces:
                    if iface in self.interfaces:
                        for method_name, method_info in self.interfaces[iface]['methods'].items():
                            if method_name not in class_info[current_class]['methods'] and \
                               method_name not in class_info[current_class]['private_methods']:
                                raise Exception(f"{current_class} sýnýfý {iface} arayüzündeki {method_name} metodunu uygulamýyor")
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type.upper(), None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type.upper(), None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx", ".libx", ".basx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_interfaces = self.interfaces.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.interfaces.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.interfaces.update(old_interfaces)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            line_upper = line.upper()
            if line_upper.startswith("DECLARE FUNCTION"):
                match = re.match(r"DECLARE FUNCTION\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": None, "params": params}
                    self.modules[module_name]["functions"][func_name] = None
            elif line_upper.startswith("DECLARE SUB"):
                match = re.match(r"DECLARE SUB\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": None, "params": params}
                    self.modules[module_name]["subs"][sub_name] = None

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            try:
                tree = ast.parse(expr, mode='eval')
                self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
            except SyntaxError:
                raise Exception(f"Geçersiz ifade: {expr}")
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        try:
            return eval(self.expr_cache[cache_key], namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, {str(e)}")

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            logging.debug(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper == "CLS":
                os.system('cls' if os.name == 'nt' else 'clear')
                return None

            if command_upper.startswith("BEEP"):
                print("\a")
                return None

            if command_upper.startswith("REM ") or command_upper.startswith("'"):
                return None

            if command_upper == "END":
                self.running = False
                return None

            if command_upper.startswith("STOP"):
                self.running = False
                return None

            if command_upper.startswith("SYSTEM"):
                match = re.match(r"SYSTEM\s+(.+)", command, re.IGNORECASE)
                if match:
                    cmd = match.group(1).strip()
                    os.system(cmd)
                    return None
                else:
                    raise Exception("SYSTEM komutunda sözdizimi hatasý")

            if command_upper.startswith("OPEN"):
                match = re.match(r"OPEN\s+\"([^\"]+)\"\s+FOR\s+(\w+)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_path, mode, file_number = match.groups()
                    file_number = int(file_number)
                    mode_map = {
                        "INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb",
                        "RANDOM": "r+b"
                    }
                    if mode.upper() not in mode_map:
                        raise Exception(f"Geçersiz dosya modu: {mode}")
                    self.file_handles[file_number] = open(file_path, mode_map[mode.upper()], encoding='utf-8' if mode.upper() != "BINARY" else None)
                    return None
                else:
                    raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        self.file_handles[file_number].close()
                        del self.file_handles[file_number]
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, data = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        data_value = self.evaluate_expression(data, scope_name)
                        self.file_handles[file_number].write(str(data_value) + "\n")
                        self.file_handles[file_number].flush()
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_number, var_name = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        line = self.file_handles[file_number].readline().strip()
                        self.current_scope()[var_name] = line
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, position = match.groups()
                    file_number = int(file_number)
                    position = self.evaluate_expression(position, scope_name)
                    if file_number in self.file_handles:
                        self.file_handles[file_number].seek(position)
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_number, var_name = match.groups()
                    file_number = int(file_number)
                    if file_number in self.file_handles:
                        data = self.file_handles[file_number].read(8)
                        self.current_scope()[var_name] = struct.unpack('d', data)[0]
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_number, value = match.groups()
                    file_number = int(file_number)
                    value = self.evaluate_expression(value, scope_name)
                    if file_number in self.file_handles:
                        self.file_handles[file_number].write(struct.pack('d', float(value)))
                        self.file_handles[file_number].flush()
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("Veri listesi sonuna ulaþýldý")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("SWAP"):
                match = re.match(r"SWAP\s+(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    var1, var2 = match.groups()
                    scope = self.current_scope()
                    if var1 in scope and var2 in scope:
                        scope[var1], scope[var2] = scope[var2], scope[var1]
                    else:
                        raise Exception(f"Deðiþkenler bulunamadý: {var1}, {var2}")
                    return None
                else:
                    raise Exception("SWAP komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    if os.path.exists(file_path):
                        os.remove(file_path)
                    else:
                        raise Exception(f"Dosya bulunamadý: {file_path}")
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"([^\"]+)\"\s+AS\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    if os.path.exists(old_name):
                        os.rename(old_name, new_name)
                    else:
                        raise Exception(f"Dosya bulunamadý: {old_name}")
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.makedirs(path, exist_ok=True)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        shutil.rmtree(path, ignore_errors=True)
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        os.chdir(path)
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    if os.path.exists(path):
                        print("\n".join(os.listdir(path)))
                    else:
                        raise Exception(f"Dizin bulunamadý: {path}")
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHAIN"):
                match = re.match(r"CHAIN\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    if os.path.exists(file_path):
                        with open(file_path, 'r', encoding='utf-8') as f:
                            code = f.read()
                        self.run(code)
                        self.running = False
                    else:
                        raise Exception(f"Dosya bulunamadý: {file_path}")
                    return None
                else:
                    raise Exception("CHAIN komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMON"):
                match = re.match(r"COMMON\s+(.+)", command, re.IGNORECASE)
                if match:
                    var_names = [v.strip() for v in match.group(1).split(",")]
                    for var in var_names:
                        if var in self.current_scope():
                            self.shared_vars[var].append(self.current_scope()[var])
                        else:
                            raise Exception(f"Deðiþken bulunamadý: {var}")
                    return None
                else:
                    raise Exception("COMMON komutunda sözdizimi hatasý")

            if command_upper.startswith("DECLARE"):
                match = re.match(r"DECLARE\s+(FUNCTION|SUB)\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    decl_type, name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    if decl_type.upper() == "FUNCTION":
                        self.functions[name] = {"line": None, "params": params}
                    else:
                        self.subs[name] = {"line": None, "params": params}
                    return None
                else:
                    raise Exception("DECLARE komutunda sözdizimi hatasý")

            if command_upper.startswith("DEF"):
                match = re.match(r"DEF\s+(\w+)\((.*)\)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    func_name, params, expr = match.groups()
                    params = [p.strip() for p in params.split(",") if p.strip()]
                    self.functions[func_name] = {
                        "line": None,
                        "params": params,
                        "expr": expr
                    }
                    return None
                else:
                    raise Exception("DEF komutunda sözdizimi hatasý")

            if command_upper.startswith("REDIM"):
                match = re.match(r"REDIM\s+(\w+)\s*\((.+)\)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dims, var_type = match.groups()
                    dims = [self.evaluate_expression(d.strip(), scope_name) for d in dims.split(",")]
                    if var_type.upper() in self.type_table:
                        self.current_scope()[var_name] = np.zeros(dims, dtype=self.type_table[var_type.upper()])
                    else:
                        raise Exception(f"Geçersiz veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("REDIM komutunda sözdizimi hatasý")

            if command_upper.startswith("ERASE"):
                match = re.match(r"ERASE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if var_name in self.current_scope():
                        del self.current_scope()[var_name]
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("ERASE komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE CONNECT"):
                match = re.match(r"SQLITE CONNECT\s+\"([^\"]+)\"\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_path, db_number = match.groups()
                    db_number = int(db_number)
                    self.db_connections[db_number] = sqlite3.connect(db_path)
                    return None
                else:
                    raise Exception("SQLITE CONNECT komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE EXECUTE"):
                match = re.match(r"SQLITE EXECUTE\s+#(\d+),\s*\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    db_number, query = match.groups()
                    db_number = int(db_number)
                    if db_number in self.db_connections:
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute(query)
                        self.db_connections[db_number].commit()
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("SQLITE EXECUTE komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE QUERY"):
                match = re.match(r"SQLITE QUERY\s+#(\d+),\s*\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    db_number, query, var_name = match.groups()
                    db_number = int(db_number)
                    if db_number in self.db_connections:
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute(query)
                        results = cursor.fetchall()
                        self.current_scope()[var_name] = results
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("SQLITE QUERY komutunda sözdizimi hatasý")

            if command_upper.startswith("SQLITE CLOSE"):
                match = re.match(r"SQLITE CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections:
                        self.db_connections[db_number].close()
                        del self.db_connections[db_number]
                    return None
                else:
                    raise Exception("SQLITE CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections:
                        self.transaction_active[db_number] = True
                        cursor = self.db_connections[db_number].cursor()
                        cursor.execute("BEGIN TRANSACTION")
                    else:
                        raise Exception(f"Veritabaný baðlantýsý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections and self.transaction_active.get(db_number, False):
                        self.db_connections[db_number].commit()
                        self.transaction_active[db_number] = False
                    else:
                        raise Exception(f"Aktif iþlem yok veya baðlantý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_number = int(match.group(1))
                    if db_number in self.db_connections and self.transaction_active.get(db_number, False):
                        self.db_connections[db_number].rollback()
                        self.transaction_active[db_number] = False
                    else:
                        raise Exception(f"Aktif iþlem yok veya baðlantý bulunamadý: #{db_number}")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                match = re.match(r"PRINT\s*(.+)?", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    if expr:
                        parts = [part.strip() for part in expr.split(";")]
                        output = []
                        for part in parts:
                            if part:
                                result = self.evaluate_expression(part, scope_name)
                                output.append(str(result))
                            else:
                                output.append(" ")
                        print("".join(output), end="")
                    else:
                        print()
                    return None
                else:
                    raise Exception("PRINT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s*(?:\((.+)\))?\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, dims, var_type = match.groups()
                    if dims:
                        dims = [self.evaluate_expression(d.strip(), scope_name) for d in dims.split(",")]
                        if var_type.upper() in self.type_table:
                            self.current_scope()[var_name] = np.zeros(dims, dtype=self.type_table[var_type.upper()])
                        elif var_type.upper() in self.types:
                            type_info = self.types[var_type.upper()]
                            if type_info["kind"] == "STRUCT":
                                self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "UNION":
                                self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "ENUM":
                                self.current_scope()[var_name] = EnumInstance(type_info["values"])
                        else:
                            raise Exception(f"Geçersiz veri tipi: {var_type}")
                    else:
                        if var_type.upper() in self.type_table:
                            self.current_scope()[var_name] = self.type_table[var_type.upper()]()
                        elif var_type.upper() in self.types:
                            type_info = self.types[var_type.upper()]
                            if type_info["kind"] == "STRUCT":
                                self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "UNION":
                                self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                            elif type_info["kind"] == "ENUM":
                                self.current_scope()[var_name] = EnumInstance(type_info["values"])
                        else:
                            raise Exception(f"Geçersiz veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s*(.+)?", command, re.IGNORECASE)
                if match:
                    condition, then_clause = match.groups()
                    condition_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": condition_result, "else": False})
                    if condition_result:
                        if then_clause:
                            return self.execute_command(then_clause, scope_name)
                    else:
                        return self.find_else_or_endif()
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if self.if_stack and not self.if_stack[-1]["else"]:
                    self.if_stack[-1]["else"] = True
                    if self.if_stack[-1]["condition"]:
                        return self.find_endif()
                    return None
                else:
                    raise Exception("ELSE komutu eþleþen IF olmadan kullanýldý")

            if command_upper == "ENDIF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("ENDIF komutu eþleþen IF olmadan kullanýldý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    condition_result = self.evaluate_expression(condition, scope_name)
                    if condition_result:
                        self.loop_stack.append({"type": "WHILE", "start": self.program_counter, "condition": condition})
                    else:
                        return self.find_wend()
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    condition = self.loop_stack[-1]["condition"]
                    condition_result = self.evaluate_expression(condition, scope_name)
                    if condition_result:
                        return self.loop_stack[-1]["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND komutu eþleþen WHILE olmadan kullanýldý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start, end, step = match.groups()
                    start_val = self.evaluate_expression(start, scope_name)
                    end_val = self.evaluate_expression(end, scope_name)
                    step_val = self.evaluate_expression(step, scope_name) if step else 1
                    self.current_scope()[var_name] = start_val
                    self.loop_stack.append({
                        "type": "FOR",
                        "var": var_name,
                        "end": end_val,
                        "step": step_val,
                        "start_line": self.program_counter
                    })
                    if step_val > 0 and start_val > end_val or step_val < 0 and start_val < end_val:
                        return self.find_next()
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper == "NEXT":
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop = self.loop_stack[-1]
                    var_name = loop["var"]
                    current_val = self.current_scope()[var_name]
                    step = loop["step"]
                    end = loop["end"]
                    current_val += step
                    self.current_scope()[var_name] = current_val
                    if step > 0 and current_val <= end or step < 0 and current_val >= end:
                        return loop["start_line"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT komutu eþleþen FOR olmadan kullanýldý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO(?:\s+(.+))?", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if condition and condition.upper().startswith("WHILE"):
                        condition = condition[5:].strip()
                        condition_result = self.evaluate_expression(condition, scope_name)
                        if not condition_result:
                            return self.find_loop()
                        self.loop_stack.append({"type": "DO_WHILE", "start": self.program_counter, "condition": condition})
                    elif condition and condition.upper().startswith("UNTIL"):
                        condition = condition[5:].strip()
                        condition_result = self.evaluate_expression(condition, scope_name)
                        if condition_result:
                            return self.find_loop()
                        self.loop_stack.append({"type": "DO_UNTIL", "start": self.program_counter, "condition": condition})
                    else:
                        self.loop_stack.append({"type": "DO", "start": self.program_counter})
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP(?:\s+(.+))?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop = self.loop_stack[-1]
                    condition = match.group(1)
                    if loop["type"] == "DO":
                        return loop["start"]
                    elif loop["type"] == "DO_WHILE" and (not condition or condition.upper().startswith("WHILE")):
                        loop_condition = loop["condition"]
                        condition_result = self.evaluate_expression(loop_condition, scope_name)
                        if condition_result:
                            return loop["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop["type"] == "DO_UNTIL" and (not condition or condition.upper().startswith("UNTIL")):
                        loop_condition = loop["condition"]
                        condition_result = self.evaluate_expression(loop_condition, scope_name)
                        if not condition_result:
                            return loop["start"]
                        else:
                            self.loop_stack.pop()
                    return None
                else:
                    raise Exception("LOOP komutu eþleþen DO olmadan kullanýldý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                elif scope_name in self.subs or scope_name in self.functions:
                    return None
                else:
                    raise Exception("RETURN komutu eþleþen GOSUB olmadan kullanýldý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper == "RESUME":
                if self.error_handler is not None:
                    return self.error_handler
                else:
                    raise Exception("RESUME komutu ON ERROR GOTO olmadan kullanýldý")

            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if self.select_stack:
                    match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                    if match:
                        case_expr = match.group(1)
                        if case_expr.upper() == "ELSE":
                            if not self.select_stack[-1]["matched"]:
                                self.select_stack[-1]["matched"] = True
                            else:
                                return self.find_end_select()
                        else:
                            case_value = self.evaluate_expression(case_expr, scope_name)
                            if self.select_stack[-1]["value"] == case_value and not self.select_stack[-1]["matched"]:
                                self.select_stack[-1]["matched"] = True
                            else:
                                return self.find_next_case_or_end()
                        return None
                    else:
                        raise Exception("CASE komutunda sözdizimi hatasý")
                else:
                    raise Exception("CASE komutu eþleþen SELECT CASE olmadan kullanýldý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT komutu eþleþen SELECT CASE olmadan kullanýldý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [self.evaluate_expression(p.strip(), scope_name) for p in params.split(",")] if params else []
                    if sub_name in self.subs:
                        sub_info = self.subs[sub_name]
                        if len(params) != len(sub_info["params"]):
                            raise Exception(f"Parametre uyuþmazlýðý: {sub_name}")
                        self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
                        self.call_stack.append(self.program_counter + 1)
                        return sub_info["line"]
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("FUNCTION"):
                match = re.match(r"FUNCTION\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    func_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.functions[func_name] = {"line": self.program_counter + 1, "params": params}
                    return self.find_end_function()
                else:
                    raise Exception("FUNCTION komutunda sözdizimi hatasý")

            if command_upper.startswith("SUB"):
                match = re.match(r"SUB\s+(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    sub_name, params = match.groups()
                    params = [p.strip() for p in params.split(",")] if params else []
                    self.subs[sub_name] = {"line": self.program_counter + 1, "params": params}
                    return self.find_end_sub()
                else:
                    raise Exception("SUB komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT"):
                match = re.match(r"EXIT\s+(SUB|FUNCTION|FOR|WHILE|DO)", command, re.IGNORECASE)
                if match:
                    exit_type = match.group(1).upper()
                    if exit_type == "SUB" and scope_name in self.subs:
                        return None
                    elif exit_type == "FUNCTION" and scope_name in self.functions:
                        return None
                    elif exit_type == "FOR" and self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                        self.loop_stack.pop()
                        return self.find_next()
                    elif exit_type == "WHILE" and self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                        self.loop_stack.pop()
                        return self.find_wend()
                    elif exit_type == "DO" and self.loop_stack and self.loop_stack[-1]["type"].startswith("DO"):
                        self.loop_stack.pop()
                        return self.find_loop()
                    else:
                        raise Exception(f"EXIT {exit_type} için uygun baðlam bulunamadý")
                else:
                    raise Exception("EXIT komutunda sözdizimi hatasý")

            if command_upper.startswith("TYPE"):
                match = re.match(r"TYPE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    type_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END TYPE"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"TYPE tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[type_name] = {"kind": "STRUCT", "fields": fields}
                    return i
                else:
                    raise Exception("TYPE komutunda sözdizimi hatasý")

            if command_upper.startswith("STRUCT"):
                match = re.match(r"STRUCT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    struct_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END STRUCT"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"STRUCT tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[struct_name] = {"kind": "STRUCT", "fields": fields}
                    return i
                else:
                    raise Exception("STRUCT komutunda sözdizimi hatasý")

            if command_upper.startswith("UNION"):
                match = re.match(r"UNION\s+(\w+)", command, re.IGNORECASE)
                if match:
                    union_name = match.group(1)
                    fields = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END UNION"):
                        field_line = self.program[i][0].strip()
                        if field_line:
                            field_match = re.match(r"(\w+)\s+AS\s+(\w+)", field_line, re.IGNORECASE)
                            if field_match:
                                fields.append(field_match.groups())
                            else:
                                raise Exception(f"UNION tanýmýnda hata: {field_line}")
                        i += 1
                    self.types[union_name] = {"kind": "UNION", "fields": fields}
                    return i
                else:
                    raise Exception("UNION komutunda sözdizimi hatasý")

            if command_upper.startswith("ENUM"):
                match = re.match(r"ENUM\s+(\w+)", command, re.IGNORECASE)
                if match:
                    enum_name = match.group(1)
                    values = {}
                    value_index = 0
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].strip().upper().startswith("END ENUM"):
                        value_name = self.program[i][0].strip()
                        if value_name:
                            values[value_name] = value_index
                            value_index += 1
                        i += 1
                    self.types[enum_name] = {"kind": "ENUM", "values": values}
                    return i
                else:
                    raise Exception("ENUM komutunda sözdizimi hatasý")

            if command_upper.startswith("NEW"):
                match = re.match(r"NEW\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, type_name = match.groups()
                    if type_name.upper() in self.types:
                        type_info = self.types[type_name.upper()]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = EnumInstance(type_info["values"])
                    elif type_name.upper() in self.classes:
                        self.current_scope()[var_name] = self.classes[type_name.upper()]()
                    else:
                        raise Exception(f"Geçersiz tip: {type_name}")
                    return None
                else:
                    raise Exception("NEW komutunda sözdizimi hatasý")

            if command_upper.startswith("SET"):
                match = re.match(r"SET\s+(\w+)\.(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, field_name, value_expr = match.groups()
                    value = self.evaluate_expression(value_expr, scope_name)
                    if var_name in self.current_scope():
                        instance = self.current_scope()[var_name]
                        if isinstance(instance, (StructInstance, UnionInstance)):
                            instance.set_field(field_name, value)
                        elif isinstance(instance, EnumInstance):
                            instance.set_value(value)
                        elif hasattr(instance, field_name):
                            setattr(instance, field_name, value)
                        else:
                            raise Exception(f"Geçersiz alan: {field_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("SET komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+(\w+)\.(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, field_name, target_var = match.groups()
                    if var_name in self.current_scope():
                        instance = self.current_scope()[var_name]
                        if isinstance(instance, (StructInstance, UnionInstance)):
                            self.current_scope()[target_var] = instance.get_field(field_name)
                        elif isinstance(instance, EnumInstance):
                            self.current_scope()[target_var] = instance.get_value()
                        elif hasattr(instance, field_name):
                            self.current_scope()[target_var] = getattr(instance, field_name)
                        else:
                            raise Exception(f"Geçersiz alan: {field_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {var_name}")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("CONST"):
                match = re.match(r"CONST\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    const_name, value_expr = match.groups()
                    if const_name in self.global_vars:
                        raise Exception(f"Sabit zaten tanýmlý: {const_name}")
                    value = self.evaluate_expression(value_expr, scope_name)
                    self.global_vars[const_name] = value
                    return None
                else:
                    raise Exception("CONST komutunda sözdizimi hatasý")

            if command_upper.startswith("INCLUDE"):
                match = re.match(r"INCLUDE\s+\"([^\"]+)\"", command, re.IGNORECASE)
                if match:
                    file_path = match.group(1)
                    self.import_module(file_path)
                    return None
                else:
                    raise Exception("INCLUDE komutunda sözdizimi hatasý")

            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"([^\"]+)\"\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_path, module_name = match.groups()
                    self.import_module(file_path, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("TRACE"):
                self.trace_mode = command_upper == "TRACE ON"
                return None

            if command_upper.startswith("DEBUG"):
                self.debug_mode = command_upper == "DEBUG ON"
                return None

            if command_upper.startswith("OPTION"):
                match = re.match(r"OPTION\s+(\w+)\s+(\w+)", command, re.IGNORECASE)
                if match:
                    option, value = match.groups()
                    if option.upper() == "ENCODING":
                        if value.lower() in self.supported_encodings:
                            self.core.set_encoding(value.lower())
                        else:
                            raise Exception(f"Desteklenmeyen kodlama: {value}")
                    elif option.upper() == "LANGUAGE":
                        if value.lower() in self.translations:
                            self.language = value.lower()
                        else:
                            raise Exception(f"Desteklenmeyen dil: {value}")
                    else:
                        raise Exception(f"Geçersiz seçenek: {option}")
                    return None
                else:
                    raise Exception("OPTION komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        self.file_handles[file_number].flush()
                        os.fsync(self.file_handles[file_number].fileno())
                    else:
                        raise Exception(f"Dosya bulunamadý: #{file_number}")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_number = int(match.group(1))
                    if file_number in self.file_handles:
                        # Dosya kilidi serbest býrakma (iþletim sistemine baðlý)
                        pass
                    else:
                        raise Exception(f"Dosya bulunamadý: #{file_number}")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("THREAD"):
                match = re.match(r"THREAD\s+(\w+)\s*,\s*(.+)", command, re.IGNORECASE)
                if match:
                    thread_name, sub_name = match.groups()
                    if sub_name in self.subs:
                        sub_info = self.subs[sub_name]
                        thread = threading.Thread(target=self.execute_sub, args=(sub_name, []))
                        self.async_tasks.append(thread)
                        thread.start()
                        self.current_scope()[thread_name] = thread.ident
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                    return None
                else:
                    raise Exception("THREAD komutunda sözdizimi hatasý")

            if command_upper.startswith("ASYNC"):
                match = re.match(r"ASYNC\s+(\w+)\s*,\s*(.+)", command, re.IGNORECASE)
                if match:
                    task_name, sub_name = match.groups()
                    if sub_name in self.subs:
                        task = asyncio.create_task(self.execute_sub_async(sub_name, []))
                        self.async_tasks.append(task)
                        self.current_scope()[task_name] = id(task)
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                    return None
                else:
                    raise Exception("ASYNC komutunda sözdizimi hatasý")

            if command_upper.startswith("WAIT"):
                match = re.match(r"WAIT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    task_name = match.group(1)
                    if task_name in self.current_scope():
                        task_id = self.current_scope()[task_name]
                        for task in self.async_tasks:
                            if id(task) == task_id or task.ident == task_id:
                                if isinstance(task, threading.Thread):
                                    task.join()
                                elif isinstance(task, asyncio.Task):
                                    asyncio.run(task)
                                break
                    else:
                        raise Exception(f"Görev bulunamadý: {task_name}")
                    return None
                else:
                    raise Exception("WAIT komutunda sözdizimi hatasý")

            if command_upper.startswith("BITSET"):
                match = re.match(r"BITSET\s+(\d+)\s*,\s*(\w+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    ptr, field, value, bits = map(int, match.groups())
                    self.lowlevel.bitset(ptr, field, value, bits)
                    return None
                else:
                    raise Exception("BITSET komutunda sözdizimi hatasý")

            if command_upper.startswith("BITGET"):
                match = re.match(r"BITGET\s+(\d+)\s*,\s*(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    ptr, field, var_name = match.groups()
                    ptr = int(ptr)
                    self.current_scope()[var_name] = self.lowlevel.bitget(ptr, field)
                    return None
                else:
                    raise Exception("BITGET komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMCPY"):
                match = re.match(r"MEMCPY\s+(\d+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    dest_ptr, src_ptr, size = map(int, match.groups())
                    self.lowlevel.memcpy(dest_ptr, src_ptr, size)
                    return None
                else:
                    raise Exception("MEMCPY komutunda sözdizimi hatasý")

            if command_upper.startswith("MEMSET"):
                match = re.match(r"MEMSET\s+(\d+)\s*,\s*(\d+)\s*,\s*(\d+)", command, re.IGNORECASE)
                if match:
                    ptr, value, size = map(int, match.groups())
                    self.lowlevel.memset(ptr, value, size)
                    return None
                else:
                    raise Exception("MEMSET komutunda sözdizimi hatasý")

            if command_upper.startswith("PTR"):
                match = re.match(r"PTR\s+(\w+)\s+AS\s+(\w+)\s+TO\s+(.+)", command, re.IGNORECASE)
                if match:
                    var_name, type_name, target = match.groups()
                    target_value = self.evaluate_expression(target, scope_name)
                    address = self.memory_manager.allocate(self.memory_manager.sizeof(target_value))
                    self.memory_manager.set_value(address, target_value)
                    self.current_scope()[var_name] = Pointer(address, type_name, self)
                    return None
                else:
                    raise Exception("PTR komutunda sözdizimi hatasý")

            if command_upper.startswith("DEREF"):
                match = re.match(r"DEREF\s+(\w+)\s*,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    ptr_name, var_name = match.groups()
                    if ptr_name in self.current_scope():
                        pointer = self.current_scope()[ptr_name]
                        if isinstance(pointer, Pointer):
                            self.current_scope()[var_name] = pointer.dereference()
                        else:
                            raise Exception(f"Geçersiz iþaretçi: {ptr_name}")
                    else:
                        raise Exception(f"Deðiþken bulunamadý: {ptr_name}")
                    return None
                else:
                    raise Exception("DEREF komutunda sözdizimi hatasý")

            # Fonksiyon çaðrýlarý ve deðiþken atamalarý
            match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
            if match:
                var_name, expr = match.groups()
                if var_name.upper() in self.functions:
                    raise Exception(f"{var_name} bir fonksiyon adý, deðiþken olarak kullanýlamaz")
                value = self.evaluate_expression(expr, scope_name)
                self.current_scope()[var_name] = value
                return None

            # Fonksiyon veya alt program çaðrýsý
            match = re.match(r"(\w+)(?:\((.*)\))?", command, re.IGNORECASE)
            if match:
                name, params = match.groups()
                params = [self.evaluate_expression(p.strip(), scope_name) for p in params.split(",")] if params else []
                if name.upper() in self.functions:
                    func_info = self.functions[name.upper()]
                    if func_info.get("expr"):
                        namespace = {p: v for p, v in zip(func_info["params"], params)}
                        return self.evaluate_expression(func_info["expr"], scope_name)
                    if len(params) != len(func_info["params"]):
                        raise Exception(f"Parametre uyuþmazlýðý: {name}")
                    self.local_scopes.append({p: v for p, v in zip(func_info["params"], params)})
                    self.call_stack.append(self.program_counter + 1)
                    return func_info["line"]
                elif name.upper() in self.subs:
                    sub_info = self.subs[name.upper()]
                    if len(params) != len(sub_info["params"]):
                        raise Exception(f"Parametre uyuþmazlýðý: {name}")
                    self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
                    self.call_stack.append(self.program_counter + 1)
                    return sub_info["line"]
                else:
                    raise Exception(f"Bilinmeyen komut veya fonksiyon: {name}")
            else:
                raise Exception(f"Geçersiz komut: {command}")

        except Exception as e:
            if self.error_handler is not None:
                self.current_scope()["ERR"] = str(e)
                return self.error_handler
            else:
                raise Exception(f"Hata: {str(e)}")

    def execute_sub(self, sub_name, params):
        if sub_name in self.subs:
            sub_info = self.subs[sub_name]
            if len(params) != len(sub_info["params"]):
                raise Exception(f"Parametre uyuþmazlýðý: {sub_name}")
            self.local_scopes.append({p: v for p, v in zip(sub_info["params"], params)})
            self.program_counter = sub_info["line"]
            while self.program_counter < len(self.program):
                command, scope = self.program[self.program_counter]
                if command.strip().upper() == "END SUB":
                    break
                next_pc = self.execute_command(command, sub_name)
                if next_pc is not None:
                    self.program_counter = next_pc
                else:
                    self.program_counter += 1
            self.local_scopes.pop()
        else:
            raise Exception(f"Alt program bulunamadý: {sub_name}")

    async def execute_sub_async(self, sub_name, params):
        return self.execute_sub(sub_name, params)

    def find_else_or_endif(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("IF"):
                nesting += 1
            elif cmd == "ENDIF":
                if nesting == 0:
                    return i
                nesting -= 1
            elif cmd == "ELSE" and nesting == 0:
                return i
            i += 1
        raise Exception("Eþleþen ELSE veya ENDIF bulunamadý")

    def find_endif(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("IF"):
                nesting += 1
            elif cmd == "ENDIF":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen ENDIF bulunamadý")

    def find_wend(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("WHILE"):
                nesting += 1
            elif cmd == "WEND":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen WEND bulunamadý")

    def find_next(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("FOR"):
                nesting += 1
            elif cmd == "NEXT":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen NEXT bulunamadý")

    def find_loop(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("DO"):
                nesting += 1
            elif cmd.startswith("LOOP"):
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen LOOP bulunamadý")

    def find_end_select(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("SELECT CASE"):
                nesting += 1
            elif cmd == "END SELECT":
                if nesting == 0:
                    return i
                nesting -= 1
            i += 1
        raise Exception("Eþleþen END SELECT bulunamadý")

    def find_next_case_or_end(self):
        i = self.program_counter + 1
        nesting = 0
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd.startswith("SELECT CASE"):
                nesting += 1
            elif cmd == "END SELECT":
                if nesting == 0:
                    return i
                nesting -= 1
            elif cmd.startswith("CASE") and nesting == 0:
                return i
            i += 1
        raise Exception("Eþleþen CASE veya END SELECT bulunamadý")

    def find_end_function(self):
        i = self.program_counter + 1
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd == "END FUNCTION":
                return i
            i += 1
        raise Exception("Eþleþen END FUNCTION bulunamadý")

    def find_end_sub(self):
        i = self.program_counter + 1
        while i < len(self.program):
            cmd = self.program[i][0].strip().upper()
            if cmd == "END SUB":
                return i
            i += 1
        raise Exception("Eþleþen END SUB bulunamadý")

    def compile_to_bytecode(self, code):
        bytecode = []
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            bytecode.append(("EXEC", line))
        return bytecode

    def run(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkmak için EXIT yazýn")
        while self.repl_mode:
            try:
                command = input(">>> ")
                if command.strip().upper() == "EXIT":
                    self.repl_mode = False
                    break
                self.execute_command(command)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="pdsXv11 Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak BASIC dosyasý")
    parser.add_argument("--repl", action="store_true", help="REPL modunda çalýþtýr")
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.repl:
        interpreter.repl()
    elif args.file:
        with open(args.file, "r", encoding="utf-8") as f:
            code = f.read()
        interpreter.run(code)
    else:
        print("Lütfen bir dosya belirtin veya --repl ile REPL modunu kullanýn")

# Dosya: pdsX.py
import sys
import subprocess
import pkg_resources

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4'
    }
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için

# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = namedtuple(current_type, [f[0] for f in type_fields[current_type]])
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        for var in self.shared_vars:
            if scope_name in self.shared_vars[var] or not self.shared_vars[var]:
                namespace[var] = self.shared_vars[var]
        namespace.update(self.function_table)
        namespace["np"] = np
        namespace["pd"] = pd
        namespace["stats"] = stats
        # Ýçe aktarýlmýþ modüllerin fonksiyon ve sýnýflarýný ekle
        for mod in self.modules.values():
            namespace.update(mod["functions"])
            namespace.update(mod["classes"])
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types:
                        self.current_scope()[var_name] = self.types[var_type](*[None for _ in self.types[var_type]._fields])
                    elif var_type in self.classes:
                        self.current_scope()[var_name] = self.classes[var_type]()
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper.startswith("JOIN"):
                match = re.match(r"JOIN\s+#(\d+),\s*(\w+)\s+WITH\s+(\w+)\s+ON\s+(.+)\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table1, table2, on_clause, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"SELECT * FROM {table1} INNER JOIN {table2} ON {on_clause}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("JOIN komutunda sözdizimi hatasý")

            if command_upper.startswith("UPDATE"):
                match = re.match(r"UPDATE\s+#(\d+),\s*(\w+)\s+SET\s+(.+)(?:\s+WHERE\s+(.+))?", command, re.IGNORECASE)
                if match:
                    file_num, table, set_clause, where = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"UPDATE {table} SET {set_clause}"
                        if where:
                            query += f" WHERE {where}"
                        conn.execute(query)
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UPDATE komutunda sözdizimi hatasý")

            if command_upper.startswith("ALTER TABLE"):
                match = re.match(r"ALTER TABLE\s+#(\d+),\s*(\w+)\s+(ADD|DROP|MODIFY)\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, table, operation, details = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"ALTER TABLE {table} {operation} {details}"
                        conn.execute(query)
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ALTER TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("CREATE VIEW"):
                match = re.match(r"CREATE VIEW\s+#(\d+),\s*(\w+)\s+AS\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, view_name, query = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"CREATE VIEW {view_name} AS {query}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("CREATE VIEW komutunda sözdizimi hatasý")

            if command_upper.startswith("DROP TABLE"):
                match = re.match(r"DROP TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DROP TABLE {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DROP TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("TRUNCATE TABLE"):
                match = re.match(r"TRUNCATE TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DELETE FROM {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("TRUNCATE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # GW-BASIC Komutlarý
            if command_upper == "LIST":
                for i, (line, _) in enumerate(self.program):
                    print(f"{i+1} {line}")
                return None

            if command_upper == "NEW":
                self.program = []
                self.global_vars.clear()
                self.shared_vars.clear()
                self.local_scopes = [{}]
                self.functions.clear()
                self.subs.clear()
                self.labels.clear()
                self.modules.clear()
                self.current_module = "main"
                self.data_list = []
                self.data_pointer = 0
                return None

            if command_upper == "SYSTEM":
                self.running = False
                sys.exit(0)

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def load_program(self, file_name):
        try:
            with open(file_name, "r", encoding='utf-8') as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
                print(error_msg)
                logging.error(error_msg)
                if self.error_handler == "RESUME":
                    self.program_counter += 1
                elif self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    self.running = False
                    break
#         def run(self):
#         self.running = True
#         self.program_counter = 0
#         while self.running and self.program_counter < len(self.program):
#             command, scope = self.program[self.program_counter]
#             if self.debug_mode:
#                 print(f"Satýr {self.program_counter + 1}: {command}")
#                 input("Devam etmek için Enter'a basýn...")
#             try:
#                 next_line = self.execute_command(command, scope)
#                 if next_line is not None:
#                     self.program_counter = next_line
#                 else:
#                     self.program_counter += 1
#                 if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
#                     if self.call_stack:
#                         self.local_scopes.pop()
#                         self.program_counter = self.call_stack.pop()
#                     else:
#                         self.running = False
#             except Exception as e:
#                 error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
#                 print(error_msg)
#                 logging.error(error_msg)
#                 if self.error_handler == "RESUME":
#                     self.program_counter += 1
#                 elif self.error_handler:
#                     self.program_counter = self.error_handler
#                 else:
#                     self.running = False
#                     break

    def repl(self):
        """REPL (Read-Eval-Print Loop) modunu baþlatýr."""
        print("PDSX Interpreter - Komut Satýrý Modu (Çýkmak için SYSTEM yazýn)")
        self.repl_mode = True
        while True:
            try:
                command = input("PDSX> ").strip()
                if command.upper() == "SYSTEM":
                    break
                if command.upper() in ("RUN", "LIST", "NEW", "SAVE", "LOAD"):
                    self.execute_command(command)
                elif command:
                    result = self.execute_command(command)
                    if result is not None and not isinstance(result, int):  # GOTO/GOSUB satýr numaralarý hariç
                        print(result)
            except KeyboardInterrupt:
                print("\nKullanýcý tarafýndan kesildi.")
                break
            except Exception as e:
                error_msg = f"REPL Hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)

    def run_file(self, file_name):
        """Terminalden dosya çalýþtýrma: pdsX dosya.basX"""
        if not file_name.endswith(".basX"):
            print("Hata: Dosya uzantýsý .basX olmalý")
            return
        if not os.path.exists(file_name):
            print(f"Hata: Dosya bulunamadý: {file_name}")
            return
        self.load_program(file_name)
        self.run()

def main():
    interpreter = pdsXInterpreter()
    parser = argparse.ArgumentParser(description="PDSX Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak .basX dosyasý")
    args = parser.parse_args()

    if args.file:
        interpreter.run_file(args.file)
    else:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsX_ilave.py
import sys
import re
import math
import struct
import random
import numpy as np
from collections import namedtuple, defaultdict

class PdsXInterpreter:
    def __init__(self):
        # Veri yapýlarý ve bellek yönetimi
        self.types = {}  # TYPE tanýmlarý
        self.structs = {}  # STRUCT tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.variables = {}  # Deðiþkenler
        self.memory_manager = MemoryManager()  # Bellek yönetimi
        self.operator_table = self._init_operator_table()  # Operatör tablosu
        self.function_table = self._init_function_table()  # Fonksiyon tablosu
        self.program_counter = 0  # Program sayacý
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.loop_stack = []  # Döngüler için yýðýn
        self.current_scope = {}  # Mevcut kapsam

    def _init_operator_table(self):
        """C tarzý operatörleri içeren tablo"""
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _init_function_table(self):
        """Matematiksel ve diðer fonksiyonlar"""
        funcs = {
            # Hiperbolik fonksiyonlar
            'SINH': math.sinh,
            'COSH': math.cosh,
            'TANH': math.tanh,
            'ASINH': math.asinh,
            'ACOSH': math.acosh,
            'ATANH': math.atanh,
            # Derece cinsinden trigonometri
            'SIND': lambda x: math.sin(math.radians(x)),
            'COSD': lambda x: math.cos(math.radians(x)),
            'TAND': lambda x: math.tan(math.radians(x)),
            # Sabitler
            'PI': math.pi,
            'E': math.e,
            # Bitwise yardýmcýlarý
            'BIN': bin,
            'HEX': hex,
            'OCT': oct,
            # Bellek iþlemleri
            'ADDR': lambda x: id(x),
            'SIZEOF': lambda x: self.memory_manager.sizeof(x),
            # Yýðýn iþlemleri
            'NEW': self.memory_manager.allocate,
            'DELETE': self.memory_manager.release
        }
        # Temel matematik fonksiyonlarýný ekle
        for name in ['sin', 'cos', 'tan', 'log', 'exp', 'sqrt', 'ceil', 'floor']:
            funcs[name.upper()] = getattr(math, name)
        return funcs

    def _increment(self, var: str, prefix: bool = False):
        """++ operatörü implementasyonu"""
        value = self.variables.get(var, 0)
        if prefix:
            self.variables[var] = value + 1
            return value + 1
        else:
            self.variables[var] = value + 1
            return value

    def _decrement(self, var: str, prefix: bool = False):
        """-- operatörü implementasyonu"""
        value = self.variables.get(var, 0)
        if prefix:
            self.variables[var] = value - 1
            return value - 1
        else:
            self.variables[var] = value - 1
            return value

    def parse_type_definition(self, lines: list):
        """TYPE veya STRUCT tanýmýný ayrýþtýr"""
        type_info = {
            'name': lines[0].split()[1],
            'fields': [],
            'is_struct': 'STRUCT' in lines[0],
            'size': 0
        }
        for line in lines[1:-1]:  # BEGIN ve END arasý
            line = line.strip()
            if not line:
                continue
            match = re.match(r'(\*?)(\w+)(?:\(([^)]+)\))?\s+AS\s+(\w+)(?:\s*=\s*(.+))?', line)
            if match:
                is_ptr, name, array_dims, type_, default = match.groups()
                field = {
                    'name': name,
                    'type': type_,
                    'is_pointer': bool(is_ptr),
                    'array_dims': self._parse_array_dims(array_dims),
                    'default': self._parse_default_value(default, type_)
                }
                type_info['fields'].append(field)
        if type_info['is_struct']:
            self._create_struct(type_info)
        else:
            self._create_type(type_info)

    def _create_struct(self, type_info: dict):
        """C uyumlu struct oluþtur"""
        struct_fields = []
        offset = 0
        for field in type_info['fields']:
            field_size = self._get_type_size(field['type'])
            if field['array_dims']:
                field_size *= np.prod(field['array_dims'])
            struct_fields.append((field['name'], field['type'], offset, field_size))
            offset += field_size
        type_info['size'] = offset
        self.structs[type_info['name']] = type_info

    def _create_type(self, type_info: dict):
        """Esnek TYPE yapýsý oluþtur"""
        field_names = [f['name'] for f in type_info['fields']]
        defaults = [f['default'] for f in type_info['fields']]
        new_type = namedtuple(type_info['name'], field_names)
        self.types[type_info['name']] = new_type
        type_info['defaults'] = defaults

    def _parse_array_dims(self, dim_str: str):
        """Dizi boyutlarýný ayrýþtýr"""
        if not dim_str:
            return []
        return [int(d.strip()) for d in dim_str.split(',')]

    def _parse_default_value(self, value_str: str, type_name: str):
        """Varsayýlan deðeri ayrýþtýr"""
        if not value_str:
            return self._get_type_default(type_name)
        try:
            if type_name == 'INTEGER':
                return int(value_str)
            elif type_name == 'SINGLE':
                return float(value_str)
            elif type_name == 'STRING':
                return value_str.strip('"')
            elif type_name == 'BOOLEAN':
                return value_str.upper() == 'TRUE'
            else:
                return value_str
        except ValueError:
            return self._get_type_default(type_name)

    def _get_type_default(self, type_name: str):
        """Tip için varsayýlan deðer döndür"""
        defaults = {
            'INTEGER': 0,
            'SINGLE': 0.0,
            'DOUBLE': 0.0,
            'STRING': '',
            'BOOLEAN': False,
            'BYTE': b'\x00'
        }
        return defaults.get(type_name.upper(), None)

    def _get_type_size(self, type_name: str):
        """Tip boyutunu byte cinsinden döndür"""
        sizes = {
            'INTEGER': 4,
            'SINGLE': 4,
            'DOUBLE': 8,
            'BYTE': 1,
            'BOOLEAN': 1
        }
        return sizes.get(type_name.upper(), 0)

    def evaluate_expression(self, expr: str):
        """Geliþmiþ ifade deðerlendirici"""
        expr = self._process_special_operators(expr)
        if expr.startswith('*'):
            ptr = self.evaluate_expression(expr[1:])
            return self.memory_manager.dereference(ptr)
        if expr.startswith('&'):
            var_name = expr[1:]
            if var_name in self.variables:
                return id(self.variables[var_name])
            raise NameError(f"Variable not found: {var_name}")
        try:
            return eval(expr, {'__builtins__': None}, {
                **self.variables,
                **self.function_table,
                **self.operator_table
            })
        except Exception as e:
            raise ValueError(f"Expression evaluation error: {str(e)}")

    def _process_special_operators(self, expr: str):
        """++, --, += gibi operatörleri iþle"""
        expr = re.sub(r'(\w+)\+\+', r'_increment("\1")', expr)
        expr = re.sub(r'\+\+(\w+)', r'_increment("\1", True)', expr)
        expr = re.sub(r'(\w+)--', r'_decrement("\1")', expr)
        expr = re.sub(r'--(\w+)', r'_decrement("\1", True)', expr)
        for op in ['+=', '-=', '*=', '/=', '%=', '&=', '|=', '^=', '<<=', '>>=']:
            if op in expr:
                var, val = expr.split(op, 1)
                expr = f"{var} = {var} {op[0]} {val}"
        return expr

    def execute_statement(self, statement: str):
        """PDSX komutlarýný çalýþtýr"""
        if statement.startswith(('TYPE ', 'STRUCT ')):
            self._parse_type_block(statement)
            return
        if statement.startswith(('DIM ', 'GLOBAL ')):
            self._process_declaration(statement)
            return
        if '=' in statement:
            var, expr = statement.split('=', 1)
            value = self.evaluate_expression(expr.strip())
            self.variables[var.strip()] = value
            return
        if statement.startswith(('IF ', 'FOR ', 'WHILE ', 'DO ')):
            self._process_control_structure(statement)
            return
        if '(' in statement and ')' in statement:
            func_name = statement.split('(', 1)[0]
            if func_name in self.function_table:
                args = self._parse_args(statement[statement.find('(')+1:-1])
                return self.function_table[func_name](*args)
        raise NotImplementedError(f"Statement not implemented: {statement}")

    def _parse_type_block(self, first_line: str):
        """TYPE/STRUCT bloðunu ayrýþtýr"""
        block_lines = [first_line]
        while not block_lines[-1].strip().startswith('END '):
            next_line = self._get_next_line()
            block_lines.append(next_line)
        self.parse_type_definition(block_lines)

    def _process_declaration(self, statement: str):
        """Deðiþken tanýmlama iþlemi"""
        parts = statement.split()
        if parts[0] in ('DIM', 'GLOBAL'):
            var_type = parts[parts.index('AS')+1]
            var_name = parts[1]
            if '(' in var_name and ')' in var_name:
                name_part, dim_part = var_name.split('(', 1)
                dims = [int(d) for d in dim_part[:-1].split(',')]
                self._create_array_variable(name_part, var_type, dims)
            else:
                self.variables[var_name] = self._get_type_default(var_type)

    def _create_array_variable(self, name: str, type_name: str, dims: list):
        """Dizi deðiþkeni oluþtur"""
        if len(dims) == 1:
            self.variables[name] = [self._get_type_default(type_name) for _ in range(dims[0])]
        else:
            self.variables[name] = np.zeros(dims, dtype=self._get_numpy_type(type_name))

    def _get_numpy_type(self, type_name: str):
        """PDSX tipinden NumPy tipine dönüþüm"""
        type_map = {
            'INTEGER': np.int32,
            'SINGLE': np.float32,
            'DOUBLE': np.float64,
            'BYTE': np.uint8,
            'BOOLEAN': np.bool_
        }
        return type_map.get(type_name.upper(), np.object_)

    def _process_control_structure(self, statement: str):
        """Kontrol yapýlarýný iþle"""
        if statement.startswith('IF '):
            condition = statement[3:statement.find('THEN')].strip()
            if self.evaluate_expression(condition):
                self._execute_block()
            else:
                self._skip_to('END IF')
        elif statement.startswith('FOR '):
            parts = statement[4:].split()
            var_name = parts[0]
            start = self.evaluate_expression(parts[2])
            end = self.evaluate_expression(parts[4])
            step = self.evaluate_expression(parts[6]) if 'STEP' in parts else 1
            self.variables[var_name] = start
            self.loop_stack.append({
                'var': var_name,
                'end': end,
                'step': step,
                'start_line': self.program_counter
            })
        elif statement.startswith('WHILE '):
            condition = statement[6:].strip()
            if self.evaluate_expression(condition):
                self.loop_stack.append({
                    'condition': condition,
                    'start_line': self.program_counter
                })
            else:
                self._skip_to('WEND')
        elif statement.startswith('DO '):
            self.loop_stack.append({
                'start_line': self.program_counter
            })

    def _execute_block(self):
        """Blok içindeki komutlarý çalýþtýr"""
        while True:
            line = self._get_next_line()
            if line.strip().startswith('END '):
                break
            self.execute_statement(line)

    def _skip_to(self, end_marker: str):
        """Belirli bir iþaretleyiciye kadar atla"""
        while True:
            line = self._get_next_line()
            if line.strip().startswith(end_marker):
                break

    def _get_next_line(self):
        """Bir sonraki program satýrýný getir"""
        self.program_counter += 1
        return self.program[self.program_counter]

    def _parse_args(self, arg_str: str):
        """Fonksiyon argümanlarýný ayrýþtýr"""
        if not arg_str.strip():
            return []
        return [self.evaluate_expression(arg.strip()) for arg in arg_str.split(',')]


class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value: Any):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj: Any):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0


def main():
    interpreter = PdsXInterpreter()
    if len(sys.argv) > 1:
        with open(sys.argv[1], 'r') as f:
            program = f.read().splitlines()
        interpreter.program = program
        interpreter.execute_program()
    else:
        print("pdsX Interpreter (v2.0)")
        print("Type 'EXIT' to quit")
        while True:
            try:
                line = input("> ").strip()
                if line.upper() == 'EXIT':
                    break
                interpreter.execute_statement(line)
            except Exception as e:
                print(f"Error: {str(e)}")


if __name__ == "__main__":
    main()

# Dosya: pdsX.py
import sys
import subprocess
import pkg_resources

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4'
    }
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için

# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }
        self.memory_manager = MemoryManager()
        self.operator_table = self._init_operator_table()
        self.function_table = self._init_function_table()

    def _init_operator_table(self):
        """C tarzý operatörleri içeren tablo"""
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _init_function_table(self):
        """Matematiksel ve diðer fonksiyonlar"""
        funcs = {
            'SINH': math.sinh,
            'COSH': math.cosh,
            'TANH': math.tanh,
            'ASINH': math.asinh,
            'ACOSH': math.acosh,
            'ATANH': math.atanh,
            'SIND': lambda x: math.sin(math.radians(x)),
            'COSD': lambda x: math.cos(math.radians(x)),
            'TAND': lambda x: math.tan(math.radians(x)),
            'PI': math.pi,
            'E': math.e,
            'BIN': bin,
            'HEX': hex,
            'OCT': oct,
            'ADDR': lambda x: id(x),
            'SIZEOF': lambda x: self.memory_manager.sizeof(x),
            'NEW': self.memory_manager.allocate,
            'DELETE': self.memory_manager.release
        }
        for name in ['sin', 'cos', 'tan', 'log', 'exp', 'sqrt', 'ceil', 'floor']:
            funcs[name.upper()] = getattr(math, name)
        return funcs

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = namedtuple(current_type, [f[0] for f in type_fields[current_type]])
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        for var in self.shared_vars:
            if scope_name in self.shared_vars[var] or not self.shared_vars[var]:
                namespace[var] = self.shared_vars[var]
        namespace.update(self.function_table)
        namespace["np"] = np
        namespace["pd"] = pd
        namespace["stats"] = stats
        # Ýçe aktarýlmýþ modüllerin fonksiyon ve sýnýflarýný ekle
        for mod in self.modules.values():
            namespace.update(mod["functions"])
            namespace.update(mod["classes"])
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types:
                        self.current_scope()[var_name] = self.types[var_type](*[None for _ in self.types[var_type]._fields])
                    elif var_type in self.classes:
                        self.current_scope()[var_name] = self.classes[var_type]()
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper.startswith("JOIN"):
                match = re.match(r"JOIN\s+#(\d+),\s*(\w+)\s+WITH\s+(\w+)\s+ON\s+(.+)\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table1, table2, on_clause, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"SELECT * FROM {table1} INNER JOIN {table2} ON {on_clause}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("JOIN komutunda sözdizimi hatasý")

            if command_upper.startswith("UPDATE"):
                match = re.match(r"UPDATE\s+#(\d+),\s*(\w+)\s+SET\s+(.+)(?:\s+WHERE\s+(.+))?", command, re.IGNORECASE)
                if match:
                    file_num, table, set_clause, where = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"UPDATE {table} SET {set_clause}"
                        if where:
                            query += f" WHERE {where}"
                        conn.execute(query)
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UPDATE komutunda sözdizimi hatasý")

            if command_upper.startswith("ALTER TABLE"):
                match = re.match(r"ALTER TABLE\s+#(\d+),\s*(\w+)\s+(ADD|DROP|MODIFY)\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, table, operation, details = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"ALTER TABLE {table} {operation} {details}"
                        conn.execute(query)
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ALTER TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("CREATE VIEW"):
                match = re.match(r"CREATE VIEW\s+#(\d+),\s*(\w+)\s+AS\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, view_name, query = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"CREATE VIEW {view_name} AS {query}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("CREATE VIEW komutunda sözdizimi hatasý")

            if command_upper.startswith("DROP TABLE"):
                match = re.match(r"DROP TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DROP TABLE {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DROP TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("TRUNCATE TABLE"):
                match = re.match(r"TRUNCATE TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DELETE FROM {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("TRUNCATE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # GW-BASIC Komutlarý
            if command_upper == "LIST":
                for i, (line, _) in enumerate(self.program):
                    print(f"{i+1} {line}")
                return None

            if command_upper == "NEW":
                self.program = []
                self.global_vars.clear()
                self.shared_vars.clear()
                self.local_scopes = [{}]
                self.functions.clear()
                self.subs.clear()
                self.labels.clear()
                self.modules.clear()
                self.current_module = "main"
                self.data_list = []
                self.data_pointer = 0
                return None

            if command_upper == "SYSTEM":
                self.running = False
                sys.exit(0)

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def load_program(self, file_name):
        try:
            with open(file_name, "r", encoding='utf-8') as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
                print(error_msg)
                logging.error(error_msg)
                if self.error_handler == "RESUME":
                    self.program_counter += 1
                elif self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    self.running = False
                    break

    def repl(self):
        """REPL (Read-Eval-Print Loop) modunu baþlatýr."""
        print("PDSX Interpreter - Komut Satýrý Modu (Çýkmak için SYSTEM yazýn)")
        self.repl_mode = True
        while True:
            try:
                command = input("PDSX> ").strip()
                if command.upper() == "SYSTEM":
                    break
                if command.upper() in ("RUN", "LIST", "NEW", "SAVE", "LOAD"):
                    self.execute_command(command)
                elif command:
                    result = self.execute_command(command)
                    if result is not None and not isinstance(result, int):  # GOTO/GOSUB satýr numaralarý hariç
                        print(result)
            except KeyboardInterrupt:
                print("\nKullanýcý tarafýndan kesildi.")
                break
            except Exception as e:
                error_msg = f"REPL Hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)

    def run_file(self, file_name):
        """Terminalden dosya çalýþtýrma: pdsX dosya.basX"""
        if not file_name.endswith(".basX"):
            print("Hata: Dosya uzantýsý .basX olmalý")
            return
        if not os.path.exists(file_name):
            print(f"Hata: Dosya bulunamadý: {file_name}")
            return
        self.load_program(file_name)
        self.run()

def main():
    interpreter = pdsXInterpreter()
    parser = argparse.ArgumentParser(description="PDSX Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak .basX dosyasý")
    args = parser.parse_args()

    if args.file:
        interpreter.run_file(args.file)
    else:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsX_v10.py
import sys
import subprocess
import importlib.metadata
import platform
import json  # Çoklu dil desteði için gerekli
import threading  # Paralel programlama için gerekli
import asyncio  # Asenkron programlama için gerekli
import ast  # AST modülü ifadeleri önbelleðe almak için kullanýlacak
import math  # Matematiksel fonksiyonlar için gerekli
import re
import logging
import struct as py_struct
from collections import namedtuple

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4',
        'readline': 'pyreadline3' if platform.system() == 'Windows' else 'readline'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    if platform.system() == 'Windows':
        import pyreadline3 as readline
    else:
        import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için
import time  # Performans ölçümü için gerekli
import struct as py_struct
from collections import namedtuple
# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)  # Maksimum alan boyutu
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = py_struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }
        self.memory_manager = MemoryManager()
        self.operator_table = self._init_operator_table()
        self.function_table = self._init_function_table()
        self.memory_pool = {}  # Sanal bellek havuzu
        self.next_address = 1000  # Baþlangýç adresi
        self.expr_cache = {}  # Ýfade önbelleði
        self.variable_cache = {}  # Deðiþken eriþim önbelleði
        self.language = "en"  # Varsayýlan dil
        self.translations = self.load_translations("lang.json")
        self.bytecode = []  # Bayt kodu depolamak için

    def load_translations(self, file_path):
        """Dil dosyasýný yükler."""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {}

    def translate(self, key):
        """Anahtar kelimeleri ve mesajlarý çevirir."""
        return self.translations.get(self.language, {}).get(key, key)

    def _init_operator_table(self):
        """C tarzý operatörleri içeren tablo"""
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _init_function_table(self):
        """Matematiksel ve diðer fonksiyonlar"""
        funcs = {
            'SINH': math.sinh,
            'COSH': math.cosh,
            'TANH': math.tanh,
            'ASINH': math.asinh,
            'ACOSH': math.acosh,
            'ATANH': math.atanh,
            'SIND': lambda x: math.sin(math.radians(x)),
            'COSD': lambda x: math.cos(math.radians(x)),
            'TAND': lambda x: math.tan(math.radians(x)),
            'PI': math.pi,
            'E': math.e,
            'BIN': bin,
            'HEX': hex,
            'OCT': oct,
            'ADDR': lambda x: id(x),
            'SIZEOF': lambda x: self.memory_manager.sizeof(x),
            'NEW': self.memory_manager.allocate,
            'DELETE': self.memory_manager.release
        }
        for name in ['sin', 'cos', 'tan', 'log', 'exp', 'sqrt', 'ceil', 'floor']:
            funcs[name.upper()] = getattr(math, name)
        return funcs

    def _increment(self, x):
        """Bir deðeri bir artýrýr."""
        if isinstance(x, (int, float)):
            return x + 1
        raise TypeError("_increment sadece sayýsal deðerler için geçerlidir.")

    def _decrement(self, x):
        """Bir deðeri bir azaltýr."""
        if isinstance(x, (int, float)):
            return x - 1
        raise TypeError("_decrement sadece sayýsal deðerler için geçerlidir.")

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        """Ýfadeleri AST ile önbelleðe alarak deðerlendirir."""
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        # Deðiþken eriþimlerini optimize etmek için mevcut kapsamý önbelleðe al
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types and self.types[var_type]["kind"] == "STRUCT":
                        self.current_scope()[var_name] = StructInstance(self.types[var_type]["fields"], self.type_table)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper.startswith("JOIN"):
                match = re.match(r"JOIN\s+#(\d+),\s*(\w+)\s+WITH\s+(\w+)\s+ON\s+(.+)\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table1, table2, on_clause, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"SELECT * FROM {table1} INNER JOIN {table2} ON {on_clause}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("JOIN komutunda sözdizimi hatasý")

            if command_upper.startswith("UPDATE"):
                match = re.match(r"UPDATE\s+#(\d+),\s*(\w+)\s+SET\s+(.+)(?:\s+WHERE\s+(.+))?", command, re.IGNORECASE)
                if match:
                    file_num, table, set_clause, where = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"UPDATE {table} SET {set_clause}"
                        if where:
                            query += f" WHERE {where}"
                        conn.execute(query)
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UPDATE komutunda sözdizimi hatasý")

            if command_upper.startswith("ALTER TABLE"):
                match = re.match(r"ALTER TABLE\s+#(\d+),\s*(\w+)\s+(ADD|DROP|MODIFY)\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, table, operation, details = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"ALTER TABLE {table} {operation} {details}"
                        conn.execute(query)
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ALTER TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("CREATE VIEW"):
                match = re.match(r"CREATE VIEW\s+#(\d+),\s*(\w+)\s+AS\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, view_name, query = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"CREATE VIEW {view_name} AS {query}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("CREATE VIEW komutunda sözdizimi hatasý")

            if command_upper.startswith("DROP TABLE"):
                match = re.match(r"DROP TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DROP TABLE {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DROP TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("TRUNCATE TABLE"):
                match = re.match(r"TRUNCATE TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DELETE FROM {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("TRUNCATE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # GW-BASIC Komutlarý
            if command_upper == "LIST":
                for i, (line, _) in enumerate(self.program):
                    print(f"{i+1} {line}")
                return None

            if command_upper == "NEW":
                self.program = []
                self.global_vars.clear()
                self.shared_vars.clear()
                self.local_scopes = [{}]
                self.functions.clear()
                self.subs.clear()
                self.labels.clear()
                self.modules.clear()
                self.current_module = "main"
                self.data_list = []
                self.data_pointer = 0
                return None

            if command_upper == "SYSTEM":
                self.running = False
                sys.exit(0)

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            if command_upper.startswith(self.translate("THREAD")):
                match = re.match(r"THREAD\s+(\w+)\s+AS\s+SUB", command, re.IGNORECASE)
                if match:
                    thread_name = match.group(1)
                    thread_body = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].upper().startswith("END SUB"):
                        thread_body.append(self.program[i][0])
                        i += 1
                    thread = threading.Thread(target=self.run_thread, args=(thread_body,))
                    thread.start()
                    self.program_counter = i
                    return None

            if command_upper.startswith(self.translate("ASYNC")):
                match = re.match(r"ASYNC\s+(\w+)\s+AS\s+SUB", command, re.IGNORECASE)
                if match:
                    async_name = match.group(1)
                    async_body = []
                    i = self.program_counter + 1
                    while i < len(self.program) and not self.program[i][0].upper().startswith("END SUB"):
                        async_body.append(self.program[i][0])
                        i += 1
                    asyncio.run(self.run_async(async_body))
                    self.program_counter = i
                    return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def run_thread(self, thread_body):
        """Bir iþ parçacýðýný çalýþtýrýr."""
        for line in thread_body:
            self.execute_command(line)

    async def run_async(self, async_body):
        """Bir asenkron alt programý çalýþtýrýr."""
        for line in async_body:
            await asyncio.sleep(0)  # Asenkron çalýþmayý simüle etmek için
            self.execute_command(line)

    def compile_to_bytecode(self, code):
        """Koddan bayt kodu üretir."""
        bytecode = []
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if line:
                bytecode.append((line, self.program_counter))
        return bytecode

    def run_bytecode(self):
        """Bayt kodunu çalýþtýrýr."""
        for command, _ in self.bytecode:
            self.execute_command(command)

    def load_program(self, file_name):
        try:
            with open(file_name, "r", encoding='utf-8') as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        """Programý çalýþtýrýr ve durum bilgisi verir."""
        print("Program çalýþtýrýlýyor...")
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
                print(error_msg)
                logging.error(error_msg)
                if self.error_handler == "RESUME":
                    self.program_counter += 1
                elif self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    self.running = False
                    break
        print("Program sonlandý.")

    def repl(self):
        """REPL (Read-Eval-Print Loop) modunu baþlatýr."""
        print("PDSX Interpreter - Komut Satýrý Modu (Çýkmak için SYSTEM yazýn)")
        self.repl_mode = True
        while True:
            try:
                prompt = f"pdsx>>satir {self.program_counter + 1}> "  # Satýr numarasýný güncel tut
                command = input(prompt).strip()
                if command.upper() == "SYSTEM":
                    print("Program sonlandýrýlýyor...")
                    break
                if command.upper() in ("RUN", "LIST", "NEW", "SAVE", "LOAD"):
                    self.execute_command(command)
                elif command:
                    result = self.execute_command(command)
                    self.program_counter += 1  # Komut çalýþtýrýldýðýnda program_counter'ý artýr
                    if result is not None and not isinstance(result, int):  # GOTO/GOSUB satýr numaralarý hariç
                        print(result)
            except KeyboardInterrupt:
                print("\nKullanýcý tarafýndan kesildi.")
                break
            except Exception as e:
                error_msg = f"REPL Hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)

    def run_file(self, file_name):
        """Terminalden dosya çalýþtýrma: pdsX dosya.basX"""
        if not file_name.endswith(".basX"):
            print("Hata: Dosya uzantýsý .basX olmalý")
            return
        if not os.path.exists(file_name):
            print(f"Hata: Dosya bulunamadý: {file_name}")
            return
        self.load_program(file_name)
        self.run()
    def measure_performance(self, command, scope_name=None):
        """Bir komutun çalýþma süresini ölçer."""
        start_time = time.time()
        result = self.execute_command(command, scope_name)
        end_time = time.time()
        print(f"Komut süresi: {end_time - start_time:.4f} saniye")
        return result
def main():
    interpreter = pdsXInterpreter()
    parser = argparse.ArgumentParser(description="PDSX Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak .basX dosyasý")
    args = parser.parse_args()

    if args.file:
        interpreter.run_file(args.file)
    else:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsx_v11.py
# grok ile yazildi

# 2023-10-01 20:00:00
# eldeki librarylerden core librarysi eklendi. ama eklenip eklenmedigini kontrol etmedim.

import sys
import subprocess
import importlib.metadata
import platform
import json
import threading
import asyncio
import ast
import math
import re
import logging
import struct as py_struct
from collections import namedtuple, defaultdict, Counter
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from types import SimpleNamespace
import os
import time
import argparse
import pdfplumber
import requests
from bs4 import BeautifulSoup
import readline

# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4',
        'readline': 'pyreadline3' if platform.system() == 'Windows' else 'readline'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()

class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = py_struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)  # Maksimum alan boyutu
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = py_struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {}
        self.current_module = "main"
        self.repl_mode = False
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.ndarray, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: py_struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: py_struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: py_struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text,
            # Yeni Eklenen Matematiksel Fonksiyonlar
            "SINH": math.sinh, "COSH": math.cosh, "TANH": math.tanh,
            "ASINH": math.asinh, "ACOSH": math.acosh, "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": lambda: math.pi, "E": lambda: math.e,
            "BIN": bin, "HEX": hex, "OCT": oct,
            "ADDR": lambda x: id(x), "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate, "DELETE": self.memory_manager.release,
            # Asenkron ve Paralel Ýþlemler
            "ASYNC_WAIT": lambda seconds: asyncio.sleep(seconds),
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.current_thread().name
        }
        self.memory_manager = MemoryManager()
        self.operator_table = self._init_operator_table()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.bytecode = []
        self.performance_metrics = {"exec_time": 0, "memory_usage": 0}

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def _init_operator_table(self):
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _increment(self, x):
        if isinstance(x, (int, float)):
            return x + 1
        raise TypeError("_increment sadece sayýsal deðerler için geçerlidir.")

    def _decrement(self, x):
        if isinstance(x, (int, float)):
            return x - 1
        raise TypeError("_decrement sadece sayýsal deðerler için geçerlidir.")

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def execute_command_async(self, command, scope_name=None):
        """Asenkron komut yürütme"""
        result = self.execute_command(command, scope_name)
        if asyncio.iscoroutine(result):
            return await result
        return result

    def execute_command(self, command, scope_name=None):
        start_time = time.time()
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # Yeni Komut: PERFORMANCE
            if command_upper == "PERFORMANCE":
                print(f"Çalýþma Süresi: {self.performance_metrics['exec_time']:.2f} saniye")
                print(f"Bellek Kullanýmý: {self.performance_metrics['memory_usage']} byte")
                return None

            # Yeni Komut: SET LANGUAGE
            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                        print(f"Dil {lang} olarak ayarlandý.")
                    else:
                        print(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types and self.types[var_type]["kind"] == "STRUCT":
                        self.current_scope()[var_name] = StructInstance(self.types[var_type]["fields"], self.type_table)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            raise Exception(f"Tanýnmayan komut: {command}")

        except Exception as e:
            if self.error_handler:
                if self.error_handler == "RESUME":
                    print(f"Hata: {e}")
                    return None
                else:
                    print(f"Hata: {e}")
                    return self.error_handler
            else:
                raise
        finally:
            exec_time = time.time() - start_time
            self.performance_metrics["exec_time"] += exec_time
            self.performance_metrics["memory_usage"] = sum(self.memory_manager.sizeof(v) for v in self.global_vars.values()) + \
                                                       sum(self.memory_manager.sizeof(v) for scope in self.local_scopes for v in scope.values())

    def run(self, code=None):
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                input("Devam için Enter...")
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    async def run_async(self, code=None):
        """Asenkron program çalýþtýrma"""
        if code:
            self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                input("Devam için Enter...")
            next_pc = await self.execute_command_async(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsX Etkileþimli Yorumlayýcý v1.0")
        print("Çýkýþ için 'EXIT' yazýn.")
        while True:
            try:
                command = input("> ")
                if command.upper() == "EXIT":
                    break
                result = self.execute_command(command)
                if result is not None and result != self.program_counter + 1:
                    print(f"Sonuç: {result}")
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        bytecode = []
        lines = code.split("\n")
        for line in lines:
            line = line.strip()
            if not line:
                continue
            tokens = line.split()
            if tokens:
                opcode = tokens[0].upper()
                operands = tokens[1:] if len(tokens) > 1 else []
                bytecode.append((opcode, operands))
        return bytecode

    def execute_bytecode(self):
        if not self.bytecode:
            raise Exception("Bayt kodu bulunamadý")
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.bytecode):
            opcode, operands = self.bytecode[self.program_counter]
            if opcode == "PRINT":
                print(" ".join(operands))
            elif opcode == "LET":
                var_name = operands[0]
                value = " ".join(operands[2:])
                self.current_scope()[var_name] = self.evaluate_expression(value)
            self.program_counter += 1
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsX Yorumlayýcý')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    parser.add_argument('-d', '--debug', action='store_true', help='Hata ayýklama modu')
    parser.add_argument('-t', '--trace', action='store_true', help='Ýzleme modu')
    parser.add_argument('-c', '--compile', action='store_true', help='Derleme modu')
    parser.add_argument('-a', '--async', action='store_true', help='Asenkron mod')
    args = parser.parse_args()

    interpreter = pdsXInterpreter()
    
    if args.debug:
        interpreter.debug_mode = True
    
    if args.trace:
        interpreter.trace_mode = True
    
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        if args.compile:
            interpreter.bytecode = interpreter.compile_to_bytecode(code)
            interpreter.execute_bytecode()
        elif args.async:
            asyncio.run(interpreter.run_async(code))
        else:
            interpreter.run(code)
    
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsX_v110.py
import sys
import subprocess
import pkg_resources

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4'
    }
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için
import time  # Performans ölçümü için gerekli
import struct as py_struct
from collections import namedtuple
import ast  # AST modülü ifadeleri önbelleðe almak için kullanýlacak
# Hata loglama için logging ayarý

class MemoryManager:
    """Bellek yönetimi ve iþaretçi aritmetiði"""
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        """Bellek ayýrma"""
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        """Bellek serbest býrakma"""
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        """Ýþaretçi dereferansý"""
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        """Ýþaretçi konumuna deðer yaz"""
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        """Nesne boyutunu byte cinsinden döndür"""
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)  # Maksimum alan boyutu
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = py_struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return py_struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }
        self.memory_manager = MemoryManager()
        self.operator_table = self._init_operator_table()
        self.function_table = self._init_function_table()
        self.memory_pool = {}  # Sanal bellek havuzu
        self.next_address = 1000  # Baþlangýç adresi

    def _init_operator_table(self):
        """C tarzý operatörleri içeren tablo"""
        return {
            '++': self._increment,
            '--': self._decrement,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def _init_function_table(self):
        """Matematiksel ve diðer fonksiyonlar"""
        funcs = {
            'SINH': math.sinh,
            'COSH': math.cosh,
            'TANH': math.tanh,
            'ASINH': math.asinh,
            'ACOSH': math.acosh,
            'ATANH': math.atanh,
            'SIND': lambda x: math.sin(math.radians(x)),
            'COSD': lambda x: math.cos(math.radians(x)),
            'TAND': lambda x: math.tan(math.radians(x)),
            'PI': math.pi,
            'E': math.e,
            'BIN': bin,
            'HEX': hex,
            'OCT': oct,
            'ADDR': lambda x: id(x),
            'SIZEOF': lambda x: self.memory_manager.sizeof(x),
            'NEW': self.memory_manager.allocate,
            'DELETE': self.memory_manager.release
        }
        for name in ['sin', 'cos', 'tan', 'log', 'exp', 'sqrt', 'ceil', 'floor']:
            funcs[name.upper()] = getattr(math, name)
        return funcs

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower()):
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        for var in self.shared_vars:
            if scope_name in self.shared_vars[var] or not self.shared_vars[var]:
                namespace[var] = self.shared_vars[var]
        namespace.update(self.function_table)
        namespace["np"] = np
        namespace["pd"] = pd
        namespace["stats"] = stats
        # Ýçe aktarýlmýþ modüllerin fonksiyon ve sýnýflarýný ekle
        for mod in self.modules.values():
            namespace.update(mod["functions"])
            namespace.update(mod["classes"])
        try:
            if "." in expr:
                var_name, field_name = expr.split(".")
                if var_name in self.current_scope():
                    instance = self.current_scope()[var_name]
                    if isinstance(instance, (StructInstance, UnionInstance)):
                        return instance.get_field(field_name)
            elif "*" in expr:
                ptr_name = expr.replace("*", "").strip()
                if ptr_name in self.current_scope():
                    ptr = self.current_scope()[ptr_name]
                    if isinstance(ptr, Pointer):
                        return ptr.dereference()
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types and self.types[var_type]["kind"] == "STRUCT":
                        self.current_scope()[var_name] = StructInstance(self.types[var_type]["fields"], self.type_table)
                    elif var_type in self.types:
                        type_info = self.types[var_type]
                        if type_info["kind"] == "STRUCT":
                            self.current_scope()[var_name] = StructInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "UNION":
                            self.current_scope()[var_name] = UnionInstance(type_info["fields"], self.type_table)
                        elif type_info["kind"] == "ENUM":
                            self.current_scope()[var_name] = None
                    elif var_type == "POINTER":
                        match_ptr = re.match(r"DIM\s+(\w+)\s+AS\s+POINTER\s+TO\s+(\w+)", command, re.IGNORECASE)
                        if match_ptr:
                            var_name, target_type = match_ptr.groups()
                            self.current_scope()[var_name] = Pointer(None, target_type, self)
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper.startswith("JOIN"):
                match = re.match(r"JOIN\s+#(\d+),\s*(\w+)\s+WITH\s+(\w+)\s+ON\s+(.+)\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table1, table2, on_clause, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"SELECT * FROM {table1} INNER JOIN {table2} ON {on_clause}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("JOIN komutunda sözdizimi hatasý")

            if command_upper.startswith("UPDATE"):
                match = re.match(r"UPDATE\s+#(\d+),\s*(\w+)\s+SET\s+(.+)(?:\s+WHERE\s+(.+))?", command, re.IGNORECASE)
                if match:
                    file_num, table, set_clause, where = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"UPDATE {table} SET {set_clause}"
                        if where:
                            query += f" WHERE {where}"
                        conn.execute(query)
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UPDATE komutunda sözdizimi hatasý")

            if command_upper.startswith("ALTER TABLE"):
                match = re.match(r"ALTER TABLE\s+#(\d+),\s*(\w+)\s+(ADD|DROP|MODIFY)\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, table, operation, details = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"ALTER TABLE {table} {operation} {details}"
                        conn.execute(query)
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ALTER TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("CREATE VIEW"):
                match = re.match(r"CREATE VIEW\s+#(\d+),\s*(\w+)\s+AS\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, view_name, query = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"CREATE VIEW {view_name} AS {query}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("CREATE VIEW komutunda sözdizimi hatasý")

            if command_upper.startswith("DROP TABLE"):
                match = re.match(r"DROP TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DROP TABLE {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DROP TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("TRUNCATE TABLE"):
                match = re.match(r"TRUNCATE TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DELETE FROM {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("TRUNCATE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # GW-BASIC Komutlarý
            if command_upper == "LIST":
                for i, (line, _) in enumerate(self.program):
                    print(f"{i+1} {line}")
                return None

            if command_upper == "NEW":
                self.program = []
                self.global_vars.clear()
                self.shared_vars.clear()
                self.local_scopes = [{}]
                self.functions.clear()
                self.subs.clear()
                self.labels.clear()
                self.modules.clear()
                self.current_module = "main"
                self.data_list = []
                self.data_pointer = 0
                return None

            if command_upper == "SYSTEM":
                self.running = False
                sys.exit(0)

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def load_program(self, file_name):
        try:
            with open(file_name, "r", encoding='utf-8') as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
                print(error_msg)
                logging.error(error_msg)
                if self.error_handler == "RESUME":
                    self.program_counter += 1
                elif self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    self.running = False
                    break

    def repl(self):
        """REPL (Read-Eval-Print Loop) modunu baþlatýr."""
        print("PDSX Interpreter - Komut Satýrý Modu (Çýkmak için SYSTEM yazýn)")
        self.repl_mode = True
        while True:
            try:
                command = input("PDSX> ").strip()
                if command.upper() == "SYSTEM":
                    break
                if command.upper() in ("RUN", "LIST", "NEW", "SAVE", "LOAD"):
                    self.execute_command(command)
                elif command:
                    result = self.execute_command(command)
                    if result is not None and not isinstance(result, int):  # GOTO/GOSUB satýr numaralarý hariç
                        print(result)
            except KeyboardInterrupt:
                print("\nKullanýcý tarafýndan kesildi.")
                break
            except Exception as e:
                error_msg = f"REPL Hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)

    def run_file(self, file_name):
        """Terminalden dosya çalýþtýrma: pdsX dosya.basX"""
        if not file_name.endswith(".basX"):
            print("Hata: Dosya uzantýsý .basX olmalý")
            return
        if not os.path.exists(file_name):
            print(f"Hata: Dosya bulunamadý: {file_name}")
            return
        self.load_program(file_name)
        self.run()
    def measure_performance(self, command, scope_name=None):
        """Bir komutun çalýþma süresini ölçer."""
        start_time = time.time()
        result = self.execute_command(command, scope_name)
        end_time = time.time()
        print(f"Komut süresi: {end_time - start_time:.4f} saniye")
        return result
def main():
    interpreter = pdsXInterpreter()
    parser = argparse.ArgumentParser(description="PDSX Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak .basX dosyasý")
    args = parser.parse_args()

    if args.file:
        interpreter.run_file(args.file)
    else:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: QBasicPDSInterpreter 6.py
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct

# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.type_table = {  # Veri tipleri tablosu
            "STRING": str,
            "INTEGER": int,
            "LONG": int,
            "SINGLE": float,
            "DOUBLE": float,
            "BYTE": int,
            "SHORT": int,
            "UNSIGNED INTEGER": int,
            "CHAR": str,
            "LIST": list,
            "DICT": dict,
            "SET": set,
            "TUPLE": tuple,
            "ARRAY": np.array,
            "DATAFRAME": pd.DataFrame,
            "POINTER": None,  # Bellek simülasyonu
            "STRUCT": dict,  # Basit struct simülasyonu
            "UNION": None,  # Tek deðer depolama
            "ENUM": dict,
            "VOID": None,
            "BITFIELD": int
        }
        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len,
            "RND": random.random,
            "ABS": abs,
            "INT": int,
            "LEFT$": lambda s, n: s[:n],
            "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(),
            "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n,
            "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(),
            "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n),
            "SQR": np.sqrt,
            "SIN": np.sin,
            "COS": np.cos,
            "TAN": np.tan,
            "LOG": np.log,
            "EXP": np.exp,
            "ATN": np.arctan,
            "FIX": lambda x: int(x),
            "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y,
            "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args),
            "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1],
            "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1,  # Basit simülasyon
            "POS": lambda x: 1,  # Basit simülasyon
            "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean,
            "MEDIAN": np.median,
            "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std,
            "VAR": np.var,
            "SUM": np.sum,
            "PROD": np.prod,
            "PERCENTILE": np.percentile,
            "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1],
            "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(),
            "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond),
            "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n),
            "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "EOF": lambda n: self.file_handles[n].eof(),
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1')
        }

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code):
        self.program = []
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_methods = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = namedtuple(current_type, [f[0] for f in type_fields[current_type]])
                current_type = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                class_name = line[6:].strip()
                current_class = class_name
                class_methods[class_name] = {}
                i += 1
            elif line_upper.startswith("END CLASS"):
                class_def = type(current_class, (), {
                    **class_methods[current_class],
                    '_vars': {},
                    '__init__': lambda self: None
                })
                self.classes[current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith("SUB "):
                method_name = line[4:].split("(")[0].strip()
                class_methods[current_class][method_name] = lambda self, *args: self._vars.get(method_name, lambda: None)(*args)
                i += 1
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                i += 1

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        for var in self.shared_vars:
            if scope_name in self.shared_vars[var] or not self.shared_vars[var]:
                namespace[var] = self.shared_vars[var]
        namespace.update(self.function_table)
        namespace["np"] = np
        namespace["pd"] = pd
        namespace["stats"] = stats
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        try:
            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper == "RESUME":
                if self.error_handler is not None:
                    return self.error_handler
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types:
                        self.current_scope()[var_name] = self.types[var_type](*[None for _ in self.types[var_type]._fields])
                    elif var_type in self.classes:
                        self.current_scope()[var_name] = self.classes[var_type]()
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    sub_name = match.group(1)
                    if sub_name in self.subs:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[sub_name]
                    else:
                        raise Exception(f"Alt program bulunamadý: {sub_name}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        return self.function_table[func_name](*args_tuple)
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper == "BEGIN TRANSACTION":
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper == "COMMIT":
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper == "ROLLBACK":
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def load_program(self, file_name):
        try:
            with open(file_name, "r") as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)
                self.running = False
        for conn in self.db_connections.values():
            conn.close()
        for file in self.file_handles.values():
            file.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="pdsX Interpreter")
    parser.add_argument("file", nargs='?', help="The .basX file to run")
    args = parser.parse_args()

    interpreter = pdsXInterpreter()

    if args.file:
        if args.file.endswith(".basX"):
            interpreter.load_program(args.file)
            interpreter.run()
        else:
            print("Hata: Dosya uzantýsý .basX olmalý")
    else:
        print("Kullaným: pdsX dosya_adi.basX")

# Dosya: QBasicPDSInterpreter9.py
import sys
import subprocess
import pkg_resources

def install_missing_libraries():
    """Gerekli kütüphaneleri kontrol eder ve eksik olanlarý yükler."""
    required_libraries = {
        'numpy': 'numpy',
        'pandas': 'pandas',
        'scipy': 'scipy',
        'pdfplumber': 'pdfplumber',
        'requests': 'requests',
        'beautifulsoup4': 'bs4'
    }
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = [lib for lib, pkg_name in required_libraries.items() if lib not in installed]

    if missing:
        print(f"Eksik kütüphaneler tespit edildi: {missing}")
        print("Yükleniyor...")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required_libraries[lib]])
                print(f"{lib} baþarýyla yüklendi.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi. Lütfen manuel olarak yükleyin.")
                sys.exit(1)
    else:
        print("Tüm gerekli kütüphaneler zaten yüklü.")

# Kütüphaneleri kontrol et ve yükle
install_missing_libraries()
try:
    import readline
except ImportError:
    print("Uyarý: readline kütüphanesi bulunamadý. Komut geçmiþi devre dýþý.")
    readline = None
import re
import random
import sqlite3
import numpy as np
import pandas as pd
import scipy.stats as stats
from collections import defaultdict, namedtuple
from types import SimpleNamespace
import os
import logging
import time
import sys
import argparse
import struct
import pdfplumber
import requests
from bs4 import BeautifulSoup
from collections import Counter
import readline  # Komut geçmiþi için

# Hata loglama için logging ayarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

class pdsXInterpreter:
    def __init__(self):
        self.global_vars = {}  # GLOBAL deðiþkenler
        self.shared_vars = defaultdict(list)  # DIM SHARED deðiþkenler
        self.local_scopes = [{}]  # Yerel kapsam yýðýný
        self.types = {}  # TYPE tanýmlarý
        self.classes = {}  # CLASS tanýmlarý
        self.functions = {}  # FUNCTION tanýmlarý
        self.subs = {}  # SUB tanýmlarý
        self.labels = {}  # Etiketler
        self.program = []  # Program satýrlarý
        self.program_counter = 0
        self.call_stack = []  # GOSUB, SUB, FUNCTION için yýðýn
        self.running = False
        self.db_connections = {}  # Veritabaný baðlantýlarý
        self.file_handles = {}  # Dosya kollarý
        self.error_handler = None  # ON ERROR GOTO için
        self.debug_mode = False  # DEBUG modu
        self.trace_mode = False  # TRACE ON/OFF için
        self.loop_stack = []  # DO...LOOP, FOR...NEXT için yýðýn
        self.select_stack = []  # SELECT CASE için yýðýn
        self.if_stack = []  # IF...THEN...ELSE için yýðýn
        self.data_list = []  # DATA komutlarý için liste
        self.data_pointer = 0  # READ komutu için iþaretçi
        self.transaction_active = {}  # Transaction durumlarý
        self.modules = {}  # Ýçe aktarýlmýþ modüller
        self.current_module = "main"  # Aktif modül adý
        self.repl_mode = False  # REPL modu aktif mi
        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }
        self.function_table = {
            # PDS Fonksiyonlarý
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            # Veri Bilimi Fonksiyonlarý
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            # NumPy Fonksiyonlarý
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            # Pandas Fonksiyonlarý
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            # Dosya ve Sistem Ýþlemleri
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            # PDF ve Web Fonksiyonlarý
            "PDF_READ_TEXT": self.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.pdf_extract_tables,
            "PDF_SEARCH_KEYWORD": self.pdf_search_keyword,
            "TXT_SEARCH": self.txt_search,
            "TXT_ANALYZE": self.txt_analyze,
            "WEB_GET": self.web_get,
            "WEB_POST": self.web_post,
            "SCRAPE_LINKS": self.scrape_links,
            "SCRAPE_TEXT": self.scrape_text
        }

    # PDF ve Web Ýþlemleri için Yardýmcý Fonksiyonlar
    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def pdf_search_keyword(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with pdfplumber.open(file_path) as pdf:
            for i, page in enumerate(pdf.pages):
                text = page.extract_text()
                if text and keyword.lower() in text.lower():
                    results.append((i + 1, text))
        return results

    def txt_search(self, file_path, keyword):
        if not os.path.exists(file_path):
            return []
        results = []
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                if keyword.lower() in line.lower():
                    results.append((i, line.strip()))
        return results

    def txt_analyze(self, file_path):
        if not os.path.exists(file_path):
            return {}
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        words = re.findall(r'\b\w+\b', content.lower())
        return Counter(words).most_common(20)

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def web_post(self, url, data):
        try:
            response = requests.post(url, data=data)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def scrape_links(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return [a['href'] for a in soup.find_all('a', href=True)]

    def scrape_text(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        return soup.get_text(separator='\n')

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main"):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = namedtuple(current_type, [f[0] for f in type_fields[current_type]])
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                class_def = type(current_class, (self.classes.get(parent_class, object),), {
                    '_vars': {},
                    '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                    '__init__': lambda self: None,
                    'private_methods': class_info[current_class]['private_methods'],
                    **{k: v for k, v in class_info[current_class]['methods'].items()},
                    **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\((.*)\))?", line, re.IGNORECASE)
                if match:
                    method_name, params = match.groups()
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = params.split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        if not file_name.endswith(('.basX', '.libX', '.hX')):
            raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX veya .hX olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        # Mevcut durumlarý yedekle
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        # Yeni modülü ayrýþtýr
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        self.parse_program(code, module_name)
        # Yedekleri geri yükle
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        expr = expr.strip()
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        for var in self.shared_vars:
            if scope_name in self.shared_vars[var] or not self.shared_vars[var]:
                namespace[var] = self.shared_vars[var]
        namespace.update(self.function_table)
        namespace["np"] = np
        namespace["pd"] = pd
        namespace["stats"] = stats
        # Ýçe aktarýlmýþ modüllerin fonksiyon ve sýnýflarýný ekle
        for mod in self.modules.values():
            namespace.update(mod["functions"])
            namespace.update(mod["classes"])
        try:
            return eval(expr, namespace)
        except Exception as e:
            raise Exception(f"Ýfade deðerlendirme hatasý: {expr}, Hata: {str(e)}")

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            # IMPORT Komutu
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+\"(.+)\"(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            # Hata Yönetimi
            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR RESUME"):
                self.error_handler = "RESUME"
                return None

            if command_upper == "RESUME":
                if self.error_handler and self.error_handler != "RESUME":
                    return self.error_handler
                elif self.error_handler == "RESUME":
                    return None
                else:
                    raise Exception("RESUME için hata iþleyicisi tanýmlý deðil")

            if command_upper == "RESUME NEXT":
                return self.program_counter + 1

            if command_upper.startswith("RESUME LABEL"):
                match = re.match(r"RESUME LABEL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("RESUME LABEL komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            # WHILE...WEND Desteði
            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            # FOR...NEXT Desteði
            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = start
                    else:
                        self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.global_vars.get(var_name, self.current_scope().get(var_name))
                    current_value += loop_info["step"]
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = current_value
                    else:
                        self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            # DO...LOOP Desteði
            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                match = re.match(r"LOOP\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match and self.loop_stack:
                    loop_type, condition = match.groups()
                    loop_info = self.loop_stack[-1]
                    if loop_type and condition:
                        cond_result = self.evaluate_expression(condition, scope_name)
                        if (loop_type == "WHILE" and cond_result) or (loop_type == "UNTIL" and not cond_result):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "WHILE":
                        if self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL":
                        if not self.evaluate_expression(loop_info["condition"], scope_name):
                            return loop_info["start"]
                        else:
                            self.loop_stack.pop()
                    else:
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            # SELECT CASE Desteði
            if command_upper.startswith("SELECT CASE"):
                match = re.match(r"SELECT CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    self.select_stack.append({"value": value, "matched": False, "start": self.program_counter})
                    return None
                else:
                    raise Exception("SELECT CASE komutunda sözdizimi hatasý")

            if command_upper.startswith("CASE"):
                if not self.select_stack:
                    raise Exception("CASE için eþleþen SELECT CASE bulunamadý")
                select_info = self.select_stack[-1]
                match = re.match(r"CASE\s+(.+)", command, re.IGNORECASE)
                if match:
                    case_expr = match.group(1)
                    if case_expr.upper() == "ELSE":
                        if not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() != "END SELECT":
                                self.program_counter += 1
                    else:
                        case_value = self.evaluate_expression(case_expr, scope_name)
                        if select_info["value"] == case_value and not select_info["matched"]:
                            select_info["matched"] = True
                        else:
                            while self.program_counter < len(self.program) and \
                                  self.program[self.program_counter][0].upper() not in ("CASE", "END SELECT"):
                                self.program_counter += 1
                    return None
                else:
                    raise Exception("CASE komutunda sözdizimi hatasý")

            if command_upper == "END SELECT":
                if self.select_stack:
                    self.select_stack.pop()
                    return None
                else:
                    raise Exception("END SELECT için eþleþen SELECT CASE bulunamadý")

            # IF...THEN...ELSE...END IF Desteði
            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    cond_result = self.evaluate_expression(condition, scope_name)
                    self.if_stack.append({"condition": cond_result, "start": self.program_counter, "else_found": False})
                    if not cond_result:
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() not in ("ELSE", "END IF"):
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper == "ELSE":
                if not self.if_stack:
                    raise Exception("ELSE için eþleþen IF bulunamadý")
                if_info = self.if_stack[-1]
                if if_info["condition"] or if_info["else_found"]:
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "END IF":
                        self.program_counter += 1
                if_info["else_found"] = True
                return None

            if command_upper == "END IF":
                if self.if_stack:
                    self.if_stack.pop()
                    return None
                else:
                    raise Exception("END IF için eþleþen IF bulunamadý")

            # Test Desteði
            if command_upper.startswith("ASSERT"):
                match = re.match(r"ASSERT\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    if not self.evaluate_expression(condition, scope_name):
                        raise Exception(f"ASSERT baþarýsýz: {condition}")
                    return None
                else:
                    raise Exception("ASSERT komutunda sözdizimi hatasý")

            # Deðiþken ve Veri Yönetimi
            if command_upper.startswith("DEFINT"):
                match = re.match(r"DEFINT\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0
                    return None
                else:
                    raise Exception("DEFINT komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSNG"):
                match = re.match(r"DEFSNG\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFSNG komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFDBL"):
                match = re.match(r"DEFDBL\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = 0.0
                    return None
                else:
                    raise Exception("DEFDBL komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFSTR"):
                match = re.match(r"DEFSTR\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    self.current_scope()[var_name] = ""
                    return None
                else:
                    raise Exception("DEFSTR komutunda sözdizimi hatasý")

            if command_upper.startswith("GLOBAL"):
                match = re.match(r"GLOBAL\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    self.global_vars[var_name] = self.type_table.get(var_type, None)()
                    return None
                else:
                    raise Exception("GLOBAL komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM SHARED"):
                match = re.match(r"DIM SHARED\s+(.+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    scopes, var_type = match.groups()
                    var_name = scopes.split(",")[-1].strip()
                    scope_list = [s.strip() for s in scopes.split(",")[:-1]]
                    self.shared_vars[var_name] = scope_list
                    return None
                else:
                    raise Exception("DIM SHARED komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type in self.types:
                        self.current_scope()[var_name] = self.types[var_type](*[None for _ in self.types[var_type]._fields])
                    elif var_type in self.classes:
                        self.current_scope()[var_name] = self.classes[var_type]()
                    elif var_type == "ARRAY":
                        self.current_scope()[var_name] = np.array([])
                    elif var_type == "DATAFRAME":
                        self.current_scope()[var_name] = pd.DataFrame()
                    elif var_type == "STRING":
                        self.current_scope()[var_name] = ""
                    elif var_type in ("INTEGER", "LONG"):
                        self.current_scope()[var_name] = 0
                    elif var_type in ("SINGLE", "DOUBLE"):
                        self.current_scope()[var_name] = 0.0
                    elif var_type == "BYTE":
                        self.current_scope()[var_name] = 0
                    elif var_type == "SHORT":
                        self.current_scope()[var_name] = 0
                    elif var_type == "UNSIGNED INTEGER":
                        self.current_scope()[var_name] = 0
                    elif var_type == "CHAR":
                        self.current_scope()[var_name] = ''
                    elif var_type == "LIST":
                        self.current_scope()[var_name] = []
                    elif var_type == "DICT":
                        self.current_scope()[var_name] = {}
                    elif var_type == "SET":
                        self.current_scope()[var_name] = set()
                    elif var_type == "TUPLE":
                        self.current_scope()[var_name] = ()
                    else:
                        raise Exception(f"Tanýmlanamayan veri tipi: {var_type}")
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            # Girdi/Çýktý
            if command_upper.startswith("PRINT"):
                print_str = command[5:].strip()
                parts = re.split(r'([;,])', print_str)
                output = ""
                for j in range(0, len(parts), 2):
                    arg = parts[j].strip()
                    if arg:
                        value = self.evaluate_expression(arg, scope_name)
                        output += str(value)
                    if j + 1 < len(parts) and parts[j+1] == ',':
                        output += " "
                if print_str.strip().endswith(';'):
                    print(output, end='')
                else:
                    print(output)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT"):
                match = re.match(r"LINE INPUT\s+\"(.+)\"?,\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    if prompt:
                        value = input(prompt + " ")
                    else:
                        value = input("> ")
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LINE INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE"):
                match = re.match(r"WRITE\s+(.+)", command, re.IGNORECASE)
                if match:
                    expr = match.group(1)
                    value = self.evaluate_expression(expr, scope_name)
                    print(f'"{value}"' if isinstance(value, str) else value)
                    return None
                else:
                    raise Exception("WRITE komutunda sözdizimi hatasý")

            # Atama
            if re.match(r"\w+\s*=\s*.+", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    if var_name in self.global_vars:
                        self.global_vars[var_name] = value
                    elif var_name in self.shared_vars and (scope_name in self.shared_vars[var_name] or not self.shared_vars[var_name]):
                        self.shared_vars[var_name] = value
                    elif var_name in self.current_scope():
                        self.current_scope()[var_name] = value
                    else:
                        raise Exception(f"Tanýmlanmamýþ deðiþken: {var_name}")
                    return None

            # Alt Programlar
            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("CALL"):
                match = re.match(r"CALL\s+(\w+)(?:\.(\w+))?(?:\((.*)\))?", command, re.IGNORECASE)
                if match:
                    target, method_name, args_str = match.groups()
                    if method_name:  # Sýnýf yöntemi çaðrýsý
                        if target in self.current_scope():
                            obj = self.current_scope()[target]
                            args = self.evaluate_expression(f"({args_str})", scope_name) if args_str else []
                            args = args if isinstance(args, (list, tuple)) else [args]
                            method = obj.__dict__.get(method_name) or obj.__dict__.get('private_methods', {}).get(method_name)
                            if method:
                                return method(obj, *args)
                            else:
                                raise Exception(f"Yöntem bulunamadý: {method_name}")
                        else:
                            raise Exception(f"Sýnýf örneði bulunamadý: {target}")
                    elif target in self.subs:  # Alt program çaðrýsý
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.subs[target]
                    else:
                        raise Exception(f"Alt program bulunamadý: {target}")
                else:
                    raise Exception("CALL komutunda sözdizimi hatasý")

            # Fonksiyon Çaðrýsý
            if re.match(r"\w+\s*\(.+\)", command, re.IGNORECASE):
                match = re.match(r"(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    func_name, args_str = match.groups()
                    if func_name in self.functions:
                        self.call_stack.append(self.program_counter)
                        self.local_scopes.append({})
                        return self.functions[func_name]
                    elif func_name in self.function_table:
                        args_tuple = self.evaluate_expression(f"({args_str})", scope_name)
                        args_tuple = args_tuple if isinstance(args_tuple, (list, tuple)) else [args_tuple]
                        result = self.function_table[func_name](*args_tuple)
                        if self.repl_mode:
                            print(result)
                        return result
                    else:
                        raise Exception(f"Fonksiyon bulunamadý: {func_name}")
                else:
                    raise Exception("Fonksiyon çaðrýsýnda sözdizimi hatasý")

            # Sýnýf Meta Veri Ýnceleme
            if command_upper.startswith("DESCRIBE"):
                match = re.match(r"DESCRIBE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    class_name = match.group(1)
                    if class_name in self.classes:
                        cls = self.classes[class_name]
                        attrs = cls._vars.keys()
                        methods = [k for k, v in cls.__dict__.items() if callable(v) and k != '__init__' and k != 'private_methods']
                        private_methods = cls.__dict__.get('private_methods', {}).keys()
                        static_vars = cls._static_vars.keys()
                        print(f"Sýnýf: {class_name}")
                        print(f"Nitelikler: {', '.join(attrs) or 'Yok'}")
                        print(f"Yöntemler: {', '.join(methods) or 'Yok'}")
                        print(f"Özel Yöntemler: {', '.join(private_methods) or 'Yok'}")
                        print(f"Statik Deðiþkenler: {', '.join(static_vars) or 'Yok'}")
                    else:
                        raise Exception(f"Sýnýf bulunamadý: {class_name}")
                    return None
                else:
                    raise Exception("DESCRIBE komutunda sözdizimi hatasý")

            # Dosya Ýþlemleri
            if command_upper.startswith("OPEN"):
                if "FOR ISAM" not in command_upper:
                    match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+(INPUT|OUTPUT|APPEND|BINARY)\s+AS\s+#(\d+)", command, re.IGNORECASE)
                    if match:
                        file_path, mode, file_num = match.groups()
                        mode_map = {"INPUT": "r", "OUTPUT": "w", "APPEND": "a", "BINARY": "rb+"}
                        self.file_handles[int(file_num)] = open(file_path, mode_map[mode])
                        return None
                    else:
                        raise Exception("OPEN komutunda sözdizimi hatasý")

            if command_upper.startswith("WRITE #"):
                match = re.match(r"WRITE\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("WRITE # komutunda sözdizimi hatasý")

            if command_upper.startswith("APPEND #"):
                match = re.match(r"APPEND\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(0, 2)  # Dosya sonuna git
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("APPEND # komutunda sözdizimi hatasý")

            if command_upper.startswith("READ #"):
                match = re.match(r"READ\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("READ # komutunda sözdizimi hatasý")

            if command_upper.startswith("LOCK"):
                match = re.match(r"LOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Basit kilit simülasyonu
                        self.file_handles[int(file_num)].write("\0")
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("UNLOCK"):
                match = re.match(r"UNLOCK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    if int(file_num) in self.file_handles:
                        # Kilit kaldýrma simülasyonu
                        pass
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UNLOCK komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT #"):
                match = re.match(r"PRINT\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.write(str(self.evaluate_expression(data, scope_name)) + "\n")
                        file.flush()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PRINT # komutunda sözdizimi hatasý")

            if command_upper.startswith("INPUT #"):
                match = re.match(r"INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("LINE INPUT #"):
                match = re.match(r"LINE INPUT\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        self.current_scope()[var_name] = file.readline().strip()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("LINE INPUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("SEEK"):
                match = re.match(r"SEEK\s+#(\d+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("SEEK komutunda sözdizimi hatasý")

            if command_upper.startswith("GET #"):
                match = re.match(r"GET\s+#(\d+),\s*(.+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, position, var_name = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        self.current_scope()[var_name] = file.read(1)  # Basit okuma
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET # komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT #"):
                match = re.match(r"PUT\s+#(\d+),\s*(.+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, position, data = match.groups()
                    file = self.file_handles.get(int(file_num))
                    if file:
                        file.seek(self.evaluate_expression(position, scope_name))
                        file.write(str(self.evaluate_expression(data, scope_name)))
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT # komutunda sözdizimi hatasý")

            if command_upper.startswith("CLOSE"):
                match = re.match(r"CLOSE\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = match.group(1)
                    num = int(file_num)
                    if num in self.file_handles:
                        self.file_handles[num].close()
                        del self.file_handles[num]
                    elif num in self.db_connections:
                        self.db_connections[num].close()
                        del self.db_connections[num]
                    else:
                        raise Exception(f"Kapatýlacak dosya #{file_num} bulunamadý")
                    return None
                else:
                    raise Exception("CLOSE komutunda sözdizimi hatasý")

            if command_upper.startswith("KILL"):
                match = re.match(r"KILL\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    os.remove(file_name)
                    return None
                else:
                    raise Exception("KILL komutunda sözdizimi hatasý")

            if command_upper.startswith("NAME"):
                match = re.match(r"NAME\s+\"(.+)\"\s+AS\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    old_name, new_name = match.groups()
                    os.rename(old_name, new_name)
                    return None
                else:
                    raise Exception("NAME komutunda sözdizimi hatasý")

            if command_upper.startswith("FILES"):
                match = re.match(r"FILES\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    pattern = match.group(1)
                    print("\n".join(os.listdir(pattern)))
                    return None
                else:
                    raise Exception("FILES komutunda sözdizimi hatasý")

            if command_upper.startswith("CHDIR"):
                match = re.match(r"CHDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.chdir(path)
                    return None
                else:
                    raise Exception("CHDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("MKDIR"):
                match = re.match(r"MKDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.mkdir(path)
                    return None
                else:
                    raise Exception("MKDIR komutunda sözdizimi hatasý")

            if command_upper.startswith("RMDIR"):
                match = re.match(r"RMDIR\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    path = match.group(1)
                    os.rmdir(path)
                    return None
                else:
                    raise Exception("RMDIR komutunda sözdizimi hatasý")

            # Veritabaný Ýþlemleri
            if command_upper.startswith("OPEN") and "FOR ISAM" in command_upper:
                match = re.match(r"OPEN\s+\"(.+)\"\s+FOR\s+ISAM\s+AS\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    db_file, file_num = match.groups()
                    conn = sqlite3.connect(db_file)
                    self.db_connections[int(file_num)] = conn
                    self.transaction_active[int(file_num)] = False
                    return None
                else:
                    raise Exception("OPEN FOR ISAM komutunda sözdizimi hatasý")

            if command_upper.startswith("DEFINE TABLE"):
                match = re.match(r"DEFINE TABLE\s+(\w+)\s*\((.+)\)", command, re.IGNORECASE)
                if match:
                    table_name, fields = match.groups()
                    fields = [f.strip() for f in fields.split(",")]
                    columns = []
                    for field in fields:
                        match_field = re.match(r"(\w+)\s+AS\s+(\w+)(?:\s+CHECK\((.+)\))?", field, re.IGNORECASE)
                        if match_field:
                            col_name, col_type, constraint = match_field.groups()
                            sql_type = {"STRING": "TEXT", "INTEGER": "INTEGER", "DOUBLE": "REAL"}.get(col_type.upper(), "TEXT")
                            column_def = f"{col_name} {sql_type}"
                            if constraint:
                                column_def += f" CHECK({constraint})"
                            columns.append(column_def)
                        else:
                            raise Exception(f"Alan tanýmý hatasý: {field}")
                    sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
                    for conn in self.db_connections.values():
                        conn.execute(sql)
                        conn.commit()
                    return None
                else:
                    raise Exception("DEFINE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("PUT"):
                match = re.match(r"PUT\s+#(\d+),\s*(AUTOKEY|\w+),\s*(.+)", command, re.IGNORECASE)
                if match:
                    file_num, key, value = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        if key.upper() == "AUTOKEY":
                            conn.execute("INSERT INTO data (value) VALUES (?)", (value,))
                        else:
                            conn.execute("INSERT OR REPLACE INTO data (key, value) VALUES (?, ?)", (key, value))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("PUT komutunda sözdizimi hatasý")

            if command_upper.startswith("GET"):
                match = re.match(r"GET\s+#(\d+),\s*(\w+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        cursor = conn.execute("SELECT value FROM data WHERE key = ?", (key,))
                        result = cursor.fetchone()
                        self.current_scope()[var_name] = result[0] if result else None
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("GET komutunda sözdizimi hatasý")

            if command_upper.startswith("DELETE"):
                match = re.match(r"DELETE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, key = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute("DELETE FROM data WHERE key = ?", (key,))
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DELETE komutunda sözdizimi hatasý")

            if command_upper.startswith("SELECT"):
                match = re.match(r"SELECT\s+(.+)\s+FROM\s+(\w+)\s*(?:WHERE\s+(.+))?\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    columns, table, where, var_name = match.groups()
                    for num, conn in self.db_connections.items():
                        query = f"SELECT {columns} FROM {table}"
                        if where:
                            query += f" WHERE {where}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                        break
                    return None
                else:
                    raise Exception("SELECT komutunda sözdizimi hatasý")

            if command_upper.startswith("JOIN"):
                match = re.match(r"JOIN\s+#(\d+),\s*(\w+)\s+WITH\s+(\w+)\s+ON\s+(.+)\s+INTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table1, table2, on_clause, var_name = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"SELECT * FROM {table1} INNER JOIN {table2} ON {on_clause}"
                        df = pd.read_sql_query(query, conn)
                        self.current_scope()[var_name] = df
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("JOIN komutunda sözdizimi hatasý")

            if command_upper.startswith("UPDATE"):
                match = re.match(r"UPDATE\s+#(\d+),\s*(\w+)\s+SET\s+(.+)(?:\s+WHERE\s+(.+))?", command, re.IGNORECASE)
                if match:
                    file_num, table, set_clause, where = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"UPDATE {table} SET {set_clause}"
                        if where:
                            query += f" WHERE {where}"
                        conn.execute(query)
                        if not self.transaction_active.get(int(file_num), False):
                            conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("UPDATE komutunda sözdizimi hatasý")

            if command_upper.startswith("ALTER TABLE"):
                match = re.match(r"ALTER TABLE\s+#(\d+),\s*(\w+)\s+(ADD|DROP|MODIFY)\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, table, operation, details = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        query = f"ALTER TABLE {table} {operation} {details}"
                        conn.execute(query)
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ALTER TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("CREATE VIEW"):
                match = re.match(r"CREATE VIEW\s+#(\d+),\s*(\w+)\s+AS\s+(.+)", command, re.IGNORECASE)
                if match:
                    file_num, view_name, query = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"CREATE VIEW {view_name} AS {query}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("CREATE VIEW komutunda sözdizimi hatasý")

            if command_upper.startswith("DROP TABLE"):
                match = re.match(r"DROP TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DROP TABLE {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("DROP TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("TRUNCATE TABLE"):
                match = re.match(r"TRUNCATE TABLE\s+#(\d+),\s*(\w+)", command, re.IGNORECASE)
                if match:
                    file_num, table = match.groups()
                    conn = self.db_connections.get(int(file_num))
                    if conn:
                        conn.execute(f"DELETE FROM {table}")
                        conn.commit()
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("TRUNCATE TABLE komutunda sözdizimi hatasý")

            if command_upper.startswith("BEGIN TRANSACTION"):
                match = re.match(r"BEGIN TRANSACTION\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.transaction_active[file_num] = True
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("BEGIN TRANSACTION komutunda sözdizimi hatasý")

            if command_upper.startswith("COMMIT"):
                match = re.match(r"COMMIT\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].commit()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("COMMIT komutunda sözdizimi hatasý")

            if command_upper.startswith("ROLLBACK"):
                match = re.match(r"ROLLBACK\s+#(\d+)", command, re.IGNORECASE)
                if match:
                    file_num = int(match.group(1))
                    if file_num in self.db_connections:
                        self.db_connections[file_num].rollback()
                        self.transaction_active[file_num] = False
                    else:
                        raise Exception(f"Dosya #{file_num} açýk deðil")
                    return None
                else:
                    raise Exception("ROLLBACK komutunda sözdizimi hatasý")

            if command_upper.startswith("INDEX"):
                match = re.match(r"INDEX\s+(\w+)\s+ON\s+(\w+)", command, re.IGNORECASE)
                if match:
                    table, column = match.groups()
                    for conn in self.db_connections.values():
                        conn.execute(f"CREATE INDEX idx_{column} ON {table} ({column})")
                        conn.commit()
                    return None
                else:
                    raise Exception("INDEX komutunda sözdizimi hatasý")

            # GW-BASIC Komutlarý
            if command_upper == "LIST":
                for i, (line, _) in enumerate(self.program):
                    print(f"{i+1} {line}")
                return None

            if command_upper == "NEW":
                self.program = []
                self.global_vars.clear()
                self.shared_vars.clear()
                self.local_scopes = [{}]
                self.functions.clear()
                self.subs.clear()
                self.labels.clear()
                self.modules.clear()
                self.current_module = "main"
                self.data_list = []
                self.data_pointer = 0
                return None

            if command_upper == "SYSTEM":
                self.running = False
                sys.exit(0)

            # Diðer Komutlar
            if command_upper.startswith("RANDOMIZE"):
                random.seed()
                return None

            if command_upper.startswith("READ"):
                match = re.match(r"READ\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name = match.group(1)
                    if self.data_pointer < len(self.data_list):
                        self.current_scope()[var_name] = self.data_list[self.data_pointer]
                        self.data_pointer += 1
                    else:
                        raise Exception("DATA listesi tükendi")
                    return None
                else:
                    raise Exception("READ komutunda sözdizimi hatasý")

            if command_upper.startswith("RESTORE"):
                self.data_pointer = 0
                return None

            if command_upper.startswith("LOAD"):
                match = re.match(r"LOAD\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    if file_name.endswith(".basX"):
                        self.load_program(file_name)
                        return 0
                    else:
                        raise Exception("Dosya uzantýsý .basX olmalý")
                else:
                    raise Exception("LOAD komutunda sözdizimi hatasý")

            if command_upper.startswith("SAVE"):
                match = re.match(r"SAVE\s+\"(.+)\"", command, re.IGNORECASE)
                if match:
                    file_name = match.group(1)
                    with open(file_name, "w") as f:
                        f.write("\n".join([line[0] for line in self.program]))
                    return None
                else:
                    raise Exception("SAVE komutunda sözdizimi hatasý")

            if command_upper == "RUN":
                self.run()
                return None

            if command_upper == "END":
                self.running = False
                return None

            raise Exception(f"Bilinmeyen komut: {command}")
        except Exception as e:
            error_msg = f"PDSX Hatasý: {str(e)}, Satýr {self.program_counter + 1 if not self.repl_mode else 'REPL'}"
            print(error_msg)
            logging.error(error_msg)
            if self.error_handler and self.debug_mode:
                print(f"Hata iþleyicisine gidiliyor: {self.error_handler}")
            if self.error_handler == "RESUME":
                return None
            elif self.error_handler:
                self.program_counter = self.error_handler
            else:
                self.running = False
            return None

    def load_program(self, file_name):
        try:
            with open(file_name, "r", encoding='utf-8') as f:
                code = f.read()
            self.parse_program(code)
        except Exception as e:
            error_msg = f"Dosya yükleme hatasý: {str(e)}"
            print(error_msg)
            logging.error(error_msg)

    def run(self):
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"Satýr {self.program_counter + 1}: {command}")
                input("Devam etmek için Enter'a basýn...")
            try:
                next_line = self.execute_command(command, scope)
                if next_line is not None:
                    self.program_counter = next_line
                else:
                    self.program_counter += 1
                if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
                    if self.call_stack:
                        self.local_scopes.pop()
                        self.program_counter = self.call_stack.pop()
                    else:
                        self.running = False
            except Exception as e:
                error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
                print(error_msg)
                logging.error(error_msg)
                if self.error_handler == "RESUME":
                    self.program_counter += 1
                elif self.error_handler:
                    self.program_counter = self.error_handler
                else:
                    self.running = False
                    break
#         def run(self):
#         self.running = True
#         self.program_counter = 0
#         while self.running and self.program_counter < len(self.program):
#             command, scope = self.program[self.program_counter]
#             if self.debug_mode:
#                 print(f"Satýr {self.program_counter + 1}: {command}")
#                 input("Devam etmek için Enter'a basýn...")
#             try:
#                 next_line = self.execute_command(command, scope)
#                 if next_line is not None:
#                     self.program_counter = next_line
#                 else:
#                     self.program_counter += 1
#                 if scope and self.program_counter < len(self.program) and self.program[self.program_counter][0].upper() in ("END SUB", "END FUNCTION"):
#                     if self.call_stack:
#                         self.local_scopes.pop()
#                         self.program_counter = self.call_stack.pop()
#                     else:
#                         self.running = False
#             except Exception as e:
#                 error_msg = f"Çalýþtýrma hatasý: {str(e)}, Satýr {self.program_counter + 1}"
#                 print(error_msg)
#                 logging.error(error_msg)
#                 if self.error_handler == "RESUME":
#                     self.program_counter += 1
#                 elif self.error_handler:
#                     self.program_counter = self.error_handler
#                 else:
#                     self.running = False
#                     break

    def repl(self):
        """REPL (Read-Eval-Print Loop) modunu baþlatýr."""
        print("PDSX Interpreter - Komut Satýrý Modu (Çýkmak için SYSTEM yazýn)")
        self.repl_mode = True
        while True:
            try:
                command = input("PDSX> ").strip()
                if command.upper() == "SYSTEM":
                    break
                if command.upper() in ("RUN", "LIST", "NEW", "SAVE", "LOAD"):
                    self.execute_command(command)
                elif command:
                    result = self.execute_command(command)
                    if result is not None and not isinstance(result, int):  # GOTO/GOSUB satýr numaralarý hariç
                        print(result)
            except KeyboardInterrupt:
                print("\nKullanýcý tarafýndan kesildi.")
                break
            except Exception as e:
                error_msg = f"REPL Hatasý: {str(e)}"
                print(error_msg)
                logging.error(error_msg)

    def run_file(self, file_name):
        """Terminalden dosya çalýþtýrma: pdsX dosya.basX"""
        if not file_name.endswith(".basX"):
            print("Hata: Dosya uzantýsý .basX olmalý")
            return
        if not os.path.exists(file_name):
            print(f"Hata: Dosya bulunamadý: {file_name}")
            return
        self.load_program(file_name)
        self.run()

def main():
    interpreter = pdsXInterpreter()
    parser = argparse.ArgumentParser(description="PDSX Interpreter")
    parser.add_argument("file", nargs="?", help="Çalýþtýrýlacak .basX dosyasý")
    args = parser.parse_args()

    if args.file:
        interpreter.run_file(args.file)
    else:
        interpreter.repl()

if __name__ == "__main__":
    main()

# Dosya: pdsX.py
# pdsXv12u.py
# Ultimate Professional Development System
# Program: pdsXv12u
# Author: Mete Dinler (fikir) & ChatGPT (programlama)

import os
import sys
import time
import math
import glob
import json
import ast
import re
import shutil
import random
import socket
import struct
import logging
import ctypes
import threading
import asyncio
import sqlite3
import requests
import pdfplumber
import numpy as np
import pandas as pd
import psutil
from types import SimpleNamespace
from datetime import datetime
from bs4 import BeautifulSoup
from collections import defaultdict, namedtuple
from packaging import version
from threading import Thread
import multiprocessing
import subprocess
import importlib.metadata
import argparse
from abc import ABC, abstractmethod

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    """Gerekli baðýmlýlýklarý kontrol eder ve eksik olanlarý yükler."""
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy',
        'psutil': 'psutil', 'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4',
        'requests': 'requests', 'packaging': 'packaging'
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", required[lib]])
                print(f"{lib} kuruldu.")
            except subprocess.CalledProcessError:
                print(f"Hata: {lib} yüklenemedi, elle kurun.")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR,
                    format='%(asctime)s - %(message)s')

# Yardýmcý Sýnýflar
class ClassDef:
    def __init__(self, name, parent=None, abstract=False, interfaces=None):
        self.name = name
        self.parent = parent
        self.abstract = abstract
        self.interfaces = interfaces if interfaces else []
        self.constructor = None
        self.destructor = None
        self.methods = {}
        self.static_vars = {}
        self.is_mixin = False

class InterfaceDef:
    def __init__(self, name):
        self.name = name
        self.methods = []

class MethodDef:
    def __init__(self, name, body, params, private=False):
        self.name = name
        self.body = body
        self.params = params
        self.private = private

# Hafýza Yönetimi
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

# Yapýlar (Struct ve Union)
class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

# Pointer Sýnýfý
class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Temel Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}
        self.pipes = {}
        self.databases = {}
        self.pipe_id_counter = 0

    # Genel yardýmcý metodlar...
    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()),
                "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False
    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

    def database_open(self, name, path=":memory:"):
        conn = sqlite3.connect(path)
        self.databases[name] = conn

    def database_close(self, name):
        if name in self.databases:
            self.databases[name].close()
            del self.databases[name]

    def database_execute(self, name, sql, params=None):
        if name not in self.databases:
            raise Exception("Database açýk deðil")
        cur = self.databases[name].cursor()
        cur.execute(sql, params or [])
        self.databases[name].commit()

    def database_query(self, name, sql, params=None):
        if name not in self.databases:
            raise Exception("Database açýk deðil")
        cur = self.databases[name].cursor()
        cur.execute(sql, params or [])
        return cur.fetchall()

    def save_pipe(self, pipe_id, file_path, compressed=False):
        if pipe_id not in self.pipes:
            raise Exception("Boru hattý bulunamadý")
        data = self.pipes[pipe_id]
        if compressed:
            import gzip
            with gzip.open(file_path, "wt", encoding="utf-8") as f:
                json.dump(data, f)
        else:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f)

    def load_pipe(self, file_path, compressed=False):
        if compressed:
            import gzip
            with gzip.open(file_path, "rt", encoding="utf-8") as f:
                data = json.load(f)
        else:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
        pipe_id = self.pipe_id_counter
        self.pipes[pipe_id] = data
        self.pipe_id_counter += 1
        return pipe_id
# Event Sistemi - Geliþmiþ
class Event:
    def __init__(self, event_id, trigger, action, priority=0, enabled=True, delay=0):
        self.event_id = event_id
        self.trigger = trigger
        self.action = action
        self.priority = priority
        self.enabled = enabled
        self.delay = delay
        self.last_trigger_time = 0

class EventManager:
    def __init__(self):
        self.events = {}
        self.max_events = 64
        self.active_limit = 32

    def add_event(self, trigger, action, priority=0, delay=0):
        if len(self.events) >= self.max_events:
            raise Exception("Maksimum event sayýsýna ulaþýldý")
        event_id = len(self.events)
        event = Event(event_id, trigger, action, priority, enabled=True, delay=delay)
        self.events[event_id] = event
        return event_id

    def remove_event(self, event_id):
        if event_id in self.events:
            del self.events[event_id]

    def enable_event(self, event_id):
        if event_id in self.events:
            self.events[event_id].enabled = True

    def disable_event(self, event_id):
        if event_id in self.events:
            self.events[event_id].enabled = False

    def trigger_event(self, event_id):
        if event_id in self.events:
            event = self.events[event_id]
            if event.enabled:
                now = time.time()
                if now - event.last_trigger_time >= event.delay:
                    event.action()
                    event.last_trigger_time = now

    def process_events(self):
        active_events = [e for e in self.events.values() if e.enabled]
        active_events.sort(key=lambda e: e.priority)
        for event in active_events[:self.active_limit]:
            if event.trigger():
                self.trigger_event(event.event_id)

    def clear(self):
        self.events.clear()

# Interpreter'de Event Manager Entegrasyonu
class pdsXv12(pdsXv11):
    def __init__(self):
        super().__init__()
        self.event_manager = EventManager()
        self.pipe_storage = {}
        self.databases = {}
        self.pipe_id_counter = 0
        self.pipes = {}
        self.auto_database = None

    def define_event(self, trigger_expr, action_expr, priority=0, delay=0):
        trigger = lambda: self.evaluate_expression(trigger_expr)
        action = lambda: self.execute_command(action_expr)
        return self.event_manager.add_event(trigger, action, priority=priority, delay=delay)

    def process_all_events(self):
        self.event_manager.process_events()

    def save_pipeline(self, varname, filename, compressed=False):
        if varname not in self.current_scope():
            raise Exception("Boru hattý bulunamadý")
        data = self.current_scope()[varname]
        if compressed:
            import gzip
            with gzip.open(filename, "wt", encoding="utf-8") as f:
                json.dump(data, f)
        else:
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(data, f)

    def load_pipeline(self, filename, compressed=False):
        if compressed:
            import gzip
            with gzip.open(filename, "rt", encoding="utf-8") as f:
                data = json.load(f)
        else:
            with open(filename, "r", encoding="utf-8") as f:
                data = json.load(f)
        varname = f"pipe_{self.pipe_id_counter}"
        self.current_scope()[varname] = data
        self.pipe_id_counter += 1
        return varname

    def open_database(self, name, path=":memory:"):
        conn = sqlite3.connect(path)
        self.databases[name] = conn
        if self.auto_database is None:
            self.auto_database = name

    def close_database(self, name):
        if name in self.databases:
            self.databases[name].close()
            del self.databases[name]
            if self.auto_database == name:
                self.auto_database = None

    def exec_sql(self, sql, params=None, db=None):
        if db is None:
            db = self.auto_database
        if db not in self.databases:
            raise Exception(f"Database bulunamadý: {db}")
        cur = self.databases[db].cursor()
        cur.execute(sql, params or [])
        self.databases[db].commit()

    def query_sql(self, sql, params=None, db=None):
        if db is None:
            db = self.auto_database
        if db not in self.databases:
            raise Exception(f"Database bulunamadý: {db}")
        cur = self.databases[db].cursor()
        cur.execute(sql, params or [])
        return cur.fetchall()

    def sql_pipeline(self, sql, db=None, map_func=None, filter_func=None):
        rows = self.query_sql(sql, db=db)
        if map_func:
            rows = [map_func(row) for row in rows]
        if filter_func:
            rows = [row for row in rows if filter_func(row)]
        return rows

# Ana Çalýþtýrýcý
def main():
    parser = argparse.ArgumentParser(description='pdsXv12 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv12()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()
# Yardýmcý Utilities
def parse_params(params_str):
    if not params_str:
        return []
    return [param.strip() for param in params_str.split(",") if param.strip()]

def safe_eval(expr, interpreter):
    try:
        return interpreter.evaluate_expression(expr)
    except Exception as e:
        print(f"Deðerlendirme hatasý: {expr} -> {e}")
        return None

# Interpreter Ekstra Fonksiyonlar
def patch_interpreter(interpreter):
    def print_vars():
        print("Global Deðiþkenler:")
        for k, v in interpreter.global_vars.items():
            print(f"  {k}: {v}")
        print("Yerel Deðiþkenler:")
        for k, v in interpreter.current_scope().items():
            print(f"  {k}: {v}")

    def show_pipes():
        print("Mevcut PIPE'lar:")
        for name, value in interpreter.pipe_storage.items():
            print(f"  {name} -> {len(value)} kayýt")

    def list_databases():
        print("Açýk Veritabanlarý:")
        for name in interpreter.databases.keys():
            print(f"  {name}")

    interpreter.print_vars = print_vars
    interpreter.show_pipes = show_pipes
    interpreter.list_databases = list_databases

# pdsXv12 Ana Yapý Baþlatýcý
class pdsXv12Final(pdsXv12):
    def __init__(self):
        super().__init__()
        patch_interpreter(self)
        self.gc_enabled = True

    def garbage_collect(self):
        if not self.gc_enabled:
            return
        print("Hafýza temizleniyor...")
        self.event_manager.clear()
        self.pipe_storage.clear()
        self.memory_pool.clear()
        self.variable_cache.clear()

    def save_state(self, filename="pdsx_state.json"):
        state = {
            "globals": self.global_vars,
            "shared_vars": dict(self.shared_vars),
            "pipes": self.pipe_storage,
        }
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(state, f, indent=4)

    def load_state(self, filename="pdsx_state.json"):
        with open(filename, "r", encoding="utf-8") as f:
            state = json.load(f)
        self.global_vars.update(state.get("globals", {}))
        self.shared_vars.update(state.get("shared_vars", {}))
        self.pipe_storage.update(state.get("pipes", {}))

    def delay(self, seconds):
        time.sleep(seconds)

# Yeni Ana Çalýþtýrýcý
def main():
    parser = argparse.ArgumentParser(description='pdsXv12 Ultimate Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    parser.add_argument('--save-state', action='store_true', help='Çýkarken state kaydet')
    parser.add_argument('--load-state', action='store_true', help='Baþlarken state yükle')
    args = parser.parse_args()

    interpreter = pdsXv12Final()
    if args.load_state:
        interpreter.load_state()

    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)

    if args.interactive or not args.file:
        interpreter.repl()

    if args.save_state:
        interpreter.save_state()

if __name__ == "__main__":
    main()
# pdsXv12 Ultimate Interpreter

# Dosya: pdsXv11g.py
# Pdsx v11g.py

import json
import os
import requests
import ctypes
import logging
import traceback
import time
from datetime import datetime
from types import SimpleNamespace
from threading import Thread
import psutil
import multiprocessing
from packaging import version
import random
import math
import shutil
import glob
import socket
import numpy as np
import pandas as pd
import scipy.stats as stats
import pdfplumber
from bs4 import BeautifulSoup
import sqlite3
import ast
import re
import struct
import asyncio
import argparse
from collections import defaultdict, namedtuple
from abc import ABC, abstractmethod
import sys
import subprocess
import importlib.metadata

# Baðýmlýlýk Yönetimi
def install_missing_libraries():
    required = {
        'numpy': 'numpy', 'pandas': 'pandas', 'scipy': 'scipy', 'psutil': 'psutil',
        'pdfplumber': 'pdfplumber', 'bs4': 'beautifulsoup4', 'requests': 'requests',
        'packaging': 'packaging' 'psutil': 'psutil', 'sqlite3': 'sqlite3', 'glob': 'glob',
    }
    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}
    missing = [lib for lib, pkg in required.items() if lib not in installed]
    if missing:
        print(f"Eksik kütüphaneler yükleniyor: {missing}")
        for lib in missing:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', required[lib]])
            except subprocess.CalledProcessError:
                print(f"Kütüphane yüklenemedi: {lib}")

install_missing_libraries()

# Loglama Ayarlarý
logging.basicConfig(filename='interpreter_errors.log', level=logging.ERROR, format='%(asctime)s - %(message)s')

# Yardýmcý Sýnýflar
class MemoryManager:
    def __init__(self):
        self.heap = {}
        self.ref_counts = {}

    def allocate(self, size: int):
        ptr = id(bytearray(size))
        self.heap[ptr] = bytearray(size)
        self.ref_counts[ptr] = 1
        return ptr

    def release(self, ptr: int):
        if ptr in self.ref_counts:
            self.ref_counts[ptr] -= 1
            if self.ref_counts[ptr] == 0:
                del self.heap[ptr]
                del self.ref_counts[ptr]

    def dereference(self, ptr: int):
        return self.heap.get(ptr, None)

    def set_value(self, ptr: int, value):
        if ptr in self.heap:
            if isinstance(value, (int, float)):
                self.heap[ptr][:] = struct.pack('d', float(value))
            elif isinstance(value, str):
                self.heap[ptr][:] = value.encode()

    def sizeof(self, obj):
        if isinstance(obj, (int, float)):
            return 8
        elif isinstance(obj, str):
            return len(obj.encode())
        elif isinstance(obj, (list, np.ndarray)):
            return obj.nbytes if hasattr(obj, 'nbytes') else len(obj) * 8
        return 0

class StructInstance:
    def __init__(self, fields, type_table):
        self.fields = {name: None for name, _ in fields}
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}
        self.offsets = {}
        offset = 0
        for name in self.fields:
            self.offsets[name] = offset
            offset += self.sizes[name]

    def set_field(self, field_name, value):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.fields[field_name] = value

    def get_field(self, field_name):
        if field_name not in self.fields:
            raise ValueError(f"Geçersiz alan: {field_name}")
        return self.fields[field_name]

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class UnionInstance:
    def __init__(self, fields, type_table):
        self.field_types = {name: type_name for name, type_name in fields}
        self.type_table = type_table
        self.active_field = None
        self.value = bytearray(8)
        self.sizes = {name: self._get_size(type_name) for name, type_name in fields}

    def set_field(self, field_name, value):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        expected_type = self.type_table.get(self.field_types[field_name].upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"{field_name} için beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.active_field = field_name
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        if fmt == "8s":
            value = str(value).encode('utf-8')[:8].ljust(8, b'\0')
        else:
            value = struct.pack(fmt, value)
        self.value[:len(value)] = value

    def get_field(self, field_name):
        if field_name not in self.field_types:
            raise ValueError(f"Geçersiz alan: {field_name}")
        if self.active_field != field_name:
            raise ValueError(f"{field_name} alaný aktif deðil")
        fmt = {"INTEGER": "i", "DOUBLE": "d", "STRING": "8s", "BYTE": "b",
               "SHORT": "h", "LONG": "q", "SINGLE": "f"}.get(self.field_types[field_name].upper(), "8s")
        try:
            if fmt == "8s":
                return self.value.decode('utf-8').rstrip('\0')
            return struct.unpack(fmt, self.value[:self.sizes[field_name]])[0]
        except:
            raise ValueError(f"{field_name} alanýndan veri okunamadý")

    def _get_size(self, type_name):
        size_map = {
            "INTEGER": 4, "DOUBLE": 8, "STRING": 8, "BYTE": 1,
            "SHORT": 2, "LONG": 8, "SINGLE": 4, "LIST": 8, "ARRAY": 8, "DICT": 8
        }
        return size_map.get(type_name.upper(), 8)

class Pointer:
    def __init__(self, address, target_type, interpreter):
        self.address = address
        self.target_type = target_type
        self.interpreter = interpreter

    def dereference(self):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        value = self.interpreter.memory_pool[self.address]["value"]
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} bulundu")
        return value

    def set(self, value):
        if self.address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi adresi: {self.address}")
        expected_type = self.interpreter.type_table.get(self.target_type.upper(), object)
        if not isinstance(value, expected_type):
            try:
                value = expected_type(value)
            except:
                raise TypeError(f"Beklenen tip {expected_type.__name__}, ancak {type(value).__name__} alýndý")
        self.interpreter.memory_pool[self.address]["value"] = value

    def add_offset(self, offset):
        new_address = self.address + offset
        if new_address not in self.interpreter.memory_pool:
            raise ValueError(f"Geçersiz iþaretçi aritmetiði: {new_address}")
        return Pointer(new_address, self.target_type, self.interpreter)

# LibXCore Sýnýfý
class LibXCore:
    def __init__(self, interpreter):
        self.interpreter = interpreter
        self.default_encoding = "utf-8"
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]
        self.metadata = {"libx_core": {"version": "1.0.0", "dependencies": []}}
        self.stacks = {}
        self.queues = {}

    def omega(self, *args):
        params = args[:-1]
        expr = args[-1]
        return lambda *values: eval(expr, {p: v for p, v in zip(params, values)})

    def list_lib(self, lib_name):
        module = self.interpreter.modules.get(lib_name, {})
        return {"functions": list(module.get("functions", {}).keys()), "classes": list(module.get("classes", {}).keys())}

    def each(self, func, iterable):
        for item in iterable:
            func(item)

    def select(self, func, iterable):
        return [item for item in iterable if func(item)]

    def insert(self, collection, value, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                collection.append(value)
            else:
                collection.insert(index, value)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection[key] = value
        else:
            raise Exception("Geçersiz veri tipi")

    def remove(self, collection, index=None, key=None):
        if isinstance(collection, list):
            if index is None:
                raise Exception("Liste için indeks gerekli")
            collection.pop(index)
        elif isinstance(collection, dict):
            if key is None:
                raise Exception("DICT için anahtar gerekli")
            collection.pop(key, None)
        else:
            raise Exception("Geçersiz veri tipi")

    def pop(self, collection):
        if isinstance(collection, list):
            return collection.pop()
        raise Exception("Yalnýzca liste için geçerli")

    def clear(self, collection):
        if isinstance(collection, (list, dict)):
            collection.clear()
        else:
            raise Exception("Geçersiz veri tipi")

    def slice(self, iterable, start, end=None):
        return iterable[start:end]

    def keys(self, obj):
        if isinstance(obj, dict):
            return list(obj.keys())
        raise Exception("Yalnýzca DICT için geçerli")

    def time_now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def date_now(self):
        return datetime.now().strftime("%Y-%m-%d")

    def timer(self):
        return time.time()

    def random_int(self, min_val, max_val):
        return random.randint(min_val, max_val)

    def assert_(self, condition, message):
        if not condition:
            raise Exception(f"Assert hatasý: {message}")

    def log(self, message, level="INFO", target=None):
        log_message = f"[{level}] {message}"
        if target:
            with open(target, "a", encoding=self.default_encoding) as f:
                f.write(log_message + "\n")
        else:
            print(log_message)

    def ifthen(self, condition, value1, value2):
        return value1 if condition else value2

    def exists(self, path):
        return os.path.exists(path)

    def mkdir(self, path):
        os.makedirs(path, exist_ok=True)

    def getenv(self, name):
        return os.getenv(name)

    def exit(self, code):
        sys.exit(code)

    def join_path(self, *parts):
        return os.path.join(*parts)

    def copy_file(self, src, dst):
        shutil.copy(src, dst)

    def move_file(self, src, dst):
        shutil.move(src, dst)

    def delete_file(self, path):
        os.remove(path)

    def floor(self, x):
        return math.floor(x)

    def ceil(self, x):
        return math.ceil(x)

    def split(self, s, sep):
        return s.split(sep)

    def join(self, iterable, sep):
        return sep.join(iterable)

    def read_lines(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.readlines()

    def write_json(self, obj, path):
        with open(path, "w", encoding=self.default_encoding) as f:
            json.dump(obj, f)

    def read_json(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return json.load(f)

    def list_dir(self, path):
        return os.listdir(path)

    def ping(self, host):
        try:
            socket.gethostbyname(host)
            return True
        except socket.error:
            return False

    def sum(self, iterable):
        return sum(iterable)

    def mean(self, iterable):
        return sum(iterable) / len(iterable) if iterable else 0

    def min(self, iterable):
        return min(iterable) if iterable else None

    def max(self, iterable):
        return max(iterable) if iterable else None

    def round(self, x, digits=0):
        return round(x, digits)

    def trim(self, s):
        return s.strip()

    def replace(self, s, old, new):
        return s.replace(old, new)

    def format(self, s, *args):
        return s.format(*args)

    def trace(self):
        return traceback.format_stack()

    def try_catch(self, block, handler):
        try:
            return block()
        except Exception as e:
            return handler(str(e))

    def sleep(self, seconds):
        time.sleep(seconds)

    def date_diff(self, date1, date2, unit="days"):
        d1 = datetime.strptime(date1, "%Y-%m-%d")
        d2 = datetime.strptime(date2, "%Y-%m-%d")
        delta = d2 - d1
        if unit == "days":
            return delta.days
        elif unit == "seconds":
            return delta.total_seconds()
        raise Exception("Geçersiz birim")

    async def run_async(self, func):
        return await asyncio.to_thread(func)

    def wait(self, tasks):
        for t in tasks:
            t.join()

    def merge(self, col1, col2):
        if isinstance(col1, list) and isinstance(col2, list):
            return col1 + col2
        elif isinstance(col1, dict) and isinstance(col2, dict):
            return {**col1, **col2}
        raise Exception("Geçersiz veri tipi")

    def sort(self, iterable, key=None):
        return sorted(iterable, key=key)

    def memory_usage(self):
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def cpu_count(self):
        return multiprocessing.cpu_count()

    def type_of(self, value):
        if isinstance(value, int):
            return "INTEGER"
        elif isinstance(value, float):
            return "FLOAT"
        elif isinstance(value, str):
            return "STRING"
        elif isinstance(value, list):
            return "LIST"
        elif isinstance(value, dict):
            return "DICT"
        return "UNKNOWN"

    def is_empty(self, collection):
        return len(collection) == 0

    def len(self, obj):
        return len(obj)

    def val(self, s):
        try:
            return int(s)
        except ValueError:
            try:
                return float(s)
            except ValueError:
                raise Exception(f"Geçersiz deðer: {s}")

    def str(self, value):
        return str(value)

    def listfile(self, path, pattern="*"):
        files = glob.glob(os.path.join(path, pattern))
        return [{"name": f, "metadata": {"compressed": f.endswith(".hz")}} for f in files]

    def stack(self):
        stack_id = id([])
        self.stacks[stack_id] = []
        return stack_id

    def push(self, stack_id, item):
        if stack_id in self.stacks:
            self.stacks[stack_id].append(item)
        else:
            raise Exception("Geçersiz yýðýn")

    def pop(self, stack_id):
        if stack_id in self.stacks and self.stacks[stack_id]:
            return self.stacks[stack_id].pop()
        raise Exception("Yýðýn boþ veya geçersiz")

    def queue(self):
        queue_id = id([])
        self.queues[queue_id] = []
        return queue_id

    def enqueue(self, queue_id, item):
        if queue_id in self.queues:
            self.queues[queue_id].append(item)
        else:
            raise Exception("Geçersiz kuyruk")

    def dequeue(self, queue_id):
        if queue_id in self.queues and self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        raise Exception("Kuyruk boþ veya geçersiz")

    def map(self, func, iterable):
        return [func(x) for x in iterable]

    def filter(self, func, iterable):
        return [x for x in iterable if func(x)]

    def reduce(self, func, iterable, initial):
        result = initial
        for x in iterable:
            result = func(result, x)
        return result

    def load_hz(self, path):
        with open(path, "r", encoding=self.default_encoding) as f:
            return f.read()

    def open(self, file_path, mode, encoding="utf-8"):
        return open(file_path, mode, encoding=encoding)

    def load_dll(self, dll_name):
        try:
            return ctypes.WinDLL(dll_name)
        except Exception as e:
            logging.error(f"DLL yükleme hatasý: {dll_name}, {e}")
            raise Exception(f"DLL yükleme hatasý: {e}")

    def load_api(self, url):
        return SimpleNamespace(
            ask=lambda query: requests.post(url, json={"query": query}).json().get("response", "")
        )

    def version(self, lib_name):
        return self.metadata.get(lib_name, {}).get("version", "unknown")

    def require_version(self, lib_name, required_version):
        current = self.version(lib_name)
        if not self._check_version(current, required_version):
            raise Exception(f"Versiyon uyumsuzluðu: {lib_name} {required_version} gerekli, {current} bulundu")

    def _check_version(self, current, required):
        return version.parse(current) >= version.parse(required)

    def set_encoding(self, encoding):
        if encoding in self.supported_encodings:
            self.default_encoding = encoding
        else:
            raise Exception(f"Desteklenmeyen encoding: {encoding}")

    async def async_wait(self, seconds):
        await asyncio.sleep(seconds)

    def pdf_read_text(self, file_path):
        if not os.path.exists(file_path):
            return "PDF bulunamadý"
        text = ""
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text

    def pdf_extract_tables(self, file_path):
        if not os.path.exists(file_path):
            return []
        tables = []
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                page_tables = page.extract_tables()
                tables.extend(page_tables)
        return tables

    def web_get(self, url):
        try:
            response = requests.get(url)
            return response.text
        except Exception as e:
            return f"Hata: {e}"

# Interpreter Çekirdeði
class pdsXv11:
    def __init__(self):
        self.global_vars = {}
        self.shared_vars = defaultdict(list)
        self.local_scopes = [{}]
        self.types = {}
        self.classes = {}
        self.functions = {}
        self.subs = {}
        self.labels = {}
        self.program = []
        self.program_counter = 0
        self.call_stack = []
        self.running = False
        self.db_connections = {}
        self.file_handles = {}
        self.error_handler = None
        self.gosub_handler = None
        self.debug_mode = False
        self.trace_mode = False
        self.loop_stack = []
        self.select_stack = []
        self.if_stack = []
        self.data_list = []
        self.data_pointer = 0
        self.transaction_active = {}
        self.modules = {"core": {"functions": {}, "classes": {}, "program": []}}
        self.current_module = "main"
        self.repl_mode = False
        self.language = "en"
        self.translations = self.load_translations("lang.json")
        self.memory_manager = MemoryManager()
        self.memory_pool = {}
        self.next_address = 1000
        self.expr_cache = {}
        self.variable_cache = {}
        self.bytecode = []
        self.core = LibXCore(self)
        self.async_tasks = []
        self.performance_metrics = {"start_time": time.time(), "memory_usage": 0}
        self.supported_encodings = [
            "utf-8", "cp1254", "iso-8859-9", "ascii", "utf-16", "utf-32",
            "cp1252", "iso-8859-1", "windows-1250", "latin-9",
            "cp932", "gb2312", "gbk", "euc-kr", "cp1251", "iso-8859-5",
            "cp1256", "iso-8859-6", "cp874", "iso-8859-7", "cp1257", "iso-8859-8"
        ]

        self.type_table = {
            "STRING": str, "INTEGER": int, "LONG": int, "SINGLE": float, "DOUBLE": float,
            "BYTE": int, "SHORT": int, "UNSIGNED INTEGER": int, "CHAR": str,
            "LIST": list, "DICT": dict, "SET": set, "TUPLE": tuple,
            "ARRAY": np.array, "DATAFRAME": pd.DataFrame, "POINTER": None,
            "STRUCT": dict, "UNION": None, "ENUM": dict, "VOID": None, "BITFIELD": int
        }

        self.function_table = {
            "MID$": lambda s, start, length: s[start-1:start-1+length],
            "LEN": len, "RND": random.random, "ABS": abs, "INT": int,
            "LEFT$": lambda s, n: s[:n], "RIGHT$": lambda s, n: s[-n:],
            "LTRIM$": lambda s: s.lstrip(), "RTRIM$": lambda s: s.rstrip(),
            "STRING$": lambda n, c: c * n, "SPACE$": lambda n: " " * n,
            "INSTR": lambda start, s, sub: s.find(sub, start-1) + 1,
            "UCASE$": lambda s: s.upper(), "LCASE$": lambda s: s.lower(),
            "STR$": lambda n: str(n), "SQR": np.sqrt, "SIN": np.sin,
            "COS": np.cos, "TAN": np.tan, "LOG": np.log, "EXP": np.exp,
            "ATN": np.arctan, "FIX": lambda x: int(x), "ROUND": lambda x, n=0: round(x, n),
            "SGN": lambda x: -1 if x < 0 else (1 if x > 0 else 0),
            "MOD": lambda x, y: x % y, "MIN": lambda *args: min(args),
            "MAX": lambda *args: max(args), "TIMER": lambda: time.time(),
            "DATE$": lambda: time.strftime("%m-%d-%Y"),
            "TIME$": lambda: time.strftime("%H:%M:%S"),
            "INKEY$": lambda: input()[:1], "ENVIRON$": lambda var: os.environ.get(var, ""),
            "COMMAND$": lambda: " ".join(sys.argv[1:]),
            "CSRLIN": lambda: 1, "POS": lambda x: 1, "VAL": lambda s: float(s) if s.replace(".", "").isdigit() else 0,
            "ASC": lambda c: ord(c[0]),
            "MEAN": np.mean, "MEDIAN": np.median, "MODE": lambda x: stats.mode(x)[0][0],
            "STD": np.std, "VAR": np.var, "SUM": np.sum, "PROD": np.prod,
            "PERCENTILE": np.percentile, "QUANTILE": np.quantile,
            "CORR": lambda x, y: np.corrcoef(x, y)[0, 1], "COV": np.cov,
            "DESCRIBE": lambda df: df.describe(), "GROUPBY": lambda df, col: df.groupby(col),
            "FILTER": lambda df, cond: df.query(cond), "SORT": lambda df, col: df.sort_values(col),
            "HEAD": lambda df, n=5: df.head(n), "TAIL": lambda df, n=5: df.tail(n),
            "MERGE": lambda df1, df2, on: pd.merge(df1, df2, on=on),
            "TTEST": lambda sample1, sample2: stats.ttest_ind(sample1, sample2),
            "CHISQUARE": lambda observed: stats.chisquare(observed),
            "ANOVA": lambda *groups: stats.f_oneway(*groups),
            "REGRESS": lambda x, y: stats.linregress(x, y),
            "CONCATENATE": np.concatenate, "STACK": np.stack, "VSTACK": np.vstack,
            "HSTACK": np.hstack, "DOT": np.dot, "CROSS": np.cross,
            "NORM": np.linalg.norm, "INV": np.linalg.inv, "SOLVE": np.linalg.solve,
            "LINSPACE": np.linspace, "ARANGE": np.arange, "ZEROS": np.zeros,
            "ONES": np.ones, "FULL": np.full, "EYE": np.eye, "DIAG": np.diag,
            "RESHAPE": np.reshape, "TRANSPOSE": np.transpose, "FLIP": np.flip,
            "ROLL": np.roll,
            "PIVOT_TABLE": lambda df, **kwargs: df.pivot_table(**kwargs),
            "CROSSTAB": pd.crosstab, "FILLNA": lambda df, value: df.fillna(value),
            "DROPNA": lambda df, **kwargs: df.dropna(**kwargs),
            "ASTYPE": lambda df, dtype: df.astype(dtype),
            "MELT": lambda df, **kwargs: pd.melt(df, **kwargs),
            "CUT": pd.cut, "QCUT": pd.qcut, "TO_DATETIME": pd.to_datetime,
            "RESAMPLE": lambda df, rule, **kwargs: df.resample(rule, **kwargs),
            "ROLLING": lambda df, window: df.rolling(window),
            "EWMA": lambda df, **kwargs: df.ewm(**kwargs).mean(),
            "SHIFT": lambda df, periods: df.shift(periods),
            "DIFF": lambda df, periods=1: df.diff(periods),
            "PCT_CHANGE": lambda df: df.pct_change(),
            "EOF": lambda n: self.file_handles[n].eof() if hasattr(self.file_handles[n], 'eof') else False,
            "LOC": lambda n: self.file_handles[n].tell(),
            "LOF": lambda n: os.path.getsize(self.file_handles[n].name),
            "FREEFILE": lambda: min(set(range(1, 100)) - set(self.file_handles.keys())),
            "CHR$": lambda n: chr(n),
            "INPUT$": lambda n, f: self.file_handles[f].read(n),
            "MKI$": lambda n: struct.pack("i", n).decode('latin1'),
            "MKS$": lambda n: struct.pack("f", n).decode('latin1'),
            "MKD$": lambda n: struct.pack("d", n).decode('latin1'),
            "DIR$": lambda path: os.listdir(path),
            "ISDIR": lambda path: os.path.isdir(path),
            "PDF_READ_TEXT": self.core.pdf_read_text,
            "PDF_EXTRACT_TABLES": self.core.pdf_extract_tables,
            "WEB_GET": self.core.web_get,
            "SINH": math.sinh,
            "COSH": math.cosh,
            "TANH": math.tanh,
            "ASINH": math.asinh,
            "ACOSH": math.acosh,
            "ATANH": math.atanh,
            "SIND": lambda x: math.sin(math.radians(x)),
            "COSD": lambda x: math.cos(math.radians(x)),
            "TAND": lambda x: math.tan(math.radians(x)),
            "PI": math.pi,
            "E": math.e,
            "BIN": bin,
            "HEX": hex,
            "OCT": oct,
            "ADDR": lambda x: id(x),
            "SIZEOF": lambda x: self.memory_manager.sizeof(x),
            "NEW": self.memory_manager.allocate,
            "DELETE": self.memory_manager.release,
            "ASYNC_WAIT": self.core.async_wait,
            "THREAD_COUNT": lambda: threading.active_count(),
            "CURRENT_THREAD": lambda: threading.get_ident(),
            "MAP": self.core.map,
            "FILTER": self.core.filter,
            "REDUCE": self.core.reduce
        }

        self.operator_table = {
            '++': lambda x: x + 1,
            '--': lambda x: x - 1,
            '<<': lambda x, y: x << y,
            '>>': lambda x, y: x >> y,
            '&': lambda x, y: x & y,
            '|': lambda x, y: x | y,
            '^': lambda x, y: x ^ y,
            '~': lambda x: ~x,
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'XOR': lambda x, y: bool(x) != bool(y),
            'NOT': lambda x: not x,
            '+=': lambda x, y: x + y,
            '-=': lambda x, y: x - y,
            '*=': lambda x, y: x * y,
            '/=': lambda x, y: x / y,
            '%=': lambda x, y: x % y,
            '&=': lambda x, y: x & y,
            '|=': lambda x, y: x | y,
            '^=': lambda x, y: x ^ y,
            '<<=': lambda x, y: x << y,
            '>>=': lambda x, y: x >> y
        }

    def load_translations(self, file_path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Dil dosyasý bulunamadý. Varsayýlan Ýngilizce kullanýlacak.")
            return {"en": {"PRINT": "Print", "ERROR": "Error"}}

    def translate(self, key):
        return self.translations.get(self.language, {}).get(key, key)

    def current_scope(self):
        return self.local_scopes[-1]

    def parse_program(self, code, module_name="main", lightweight=False, as_library=False):
        self.current_module = module_name
        self.modules[module_name] = {
            "program": [],
            "functions": {},
            "subs": {},
            "classes": {},
            "types": {},
            "labels": {}
        }
        current_sub = None
        current_function = None
        current_type = None
        current_class = None
        type_fields = {}
        class_info = {}
        enum_values = {}
        lines = code.split("\n")
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            line_upper = line.upper()
            if line_upper.startswith("SUB "):
                sub_name = line[4:].split("(")[0].strip()
                self.subs[sub_name] = i + 1
                self.modules[module_name]["subs"][sub_name] = i + 1
                current_sub = sub_name
                i += 1
            elif line_upper.startswith("FUNCTION "):
                func_name = line[8:].split("(")[0].strip()
                self.functions[func_name] = i + 1
                self.modules[module_name]["functions"][func_name] = i + 1
                current_function = func_name
                i += 1
            elif line_upper.startswith("TYPE "):
                type_name = line[5:].strip()
                current_type = type_name
                type_fields[type_name] = []
                i += 1
            elif line_upper.startswith("END TYPE"):
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("UNION "):
                union_name = line[6:].strip()
                current_type = union_name
                type_fields[union_name] = []
                i += 1
            elif line_upper.startswith("END UNION"):
                self.types[current_type] = {"kind": "UNION", "fields": type_fields[current_type]}
                self.modules[module_name]["types"][current_type] = self.types[current_type]
                current_type = None
                i += 1
            elif line_upper.startswith("ENUM "):
                enum_name = line[5:].strip()
                current_enum = enum_name
                enum_values[enum_name] = {}
                i += 1
            elif line_upper.startswith("END ENUM"):
                self.types[current_enum] = {"kind": "ENUM", "values": enum_values[current_enum]}
                self.modules[module_name]["types"][current_enum] = self.types[current_enum]
                current_enum = None
                i += 1
            elif current_type:
                match = re.match(r"(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    field_name, field_type = match.groups()
                    type_fields[current_type].append((field_name, field_type))
                else:
                    raise Exception(f"TYPE tanýmý hatasý: {line}")
                i += 1
            elif line_upper.startswith("ABSTRACT CLASS "):
                match = re.match(r"ABSTRACT CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': True
                    }
                    i += 1
                else:
                    raise Exception("ABSTRACT CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("CLASS "):
                match = re.match(r"CLASS\s+(\w+)(?:\s+EXTENDS\s+(\w+))?", line, re.IGNORECASE)
                if match:
                    class_name, parent_name = match.groups()
                    current_class = class_name
                    class_info[class_name] = {
                        'methods': {},
                        'private_methods': {},
                        'static_vars': {},
                        'parent': parent_name,
                        'abstract': False
                    }
                    i += 1
                else:
                    raise Exception("CLASS komutunda sözdizimi hatasý")
            elif line_upper.startswith("END CLASS"):
                parent_class = class_info[current_class]['parent']
                parent_methods = self.classes.get(parent_class, type('', (), {'_vars': {}})()).__dict__ if parent_class else {}
                parent_static_vars = class_info.get(parent_class, {}).get('static_vars', {})
                if class_info[current_class]['abstract']:
                    class_def = type(current_class, (ABC, self.classes.get(parent_class, object)), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: abstractmethod(v) if k.startswith('_') else v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                else:
                    class_def = type(current_class, (self.classes.get(parent_class, object),), {
                        '_vars': {},
                        '_static_vars': {**parent_static_vars, **class_info[current_class]['static_vars']},
                        '__init__': lambda self: None,
                        'private_methods': class_info[current_class]['private_methods'],
                        **{k: v for k, v in class_info[current_class]['methods'].items()},
                        **{k: v for k, v in parent_methods.items() if k not in class_info[current_class]['methods'] and k != 'private_methods'}
                    })
                self.classes[current_class] = class_def
                self.modules[module_name]["classes"][current_class] = class_def
                current_class = None
                i += 1
            elif current_class and line_upper.startswith(("SUB ", "PRIVATE SUB ", "FUNCTION ", "PRIVATE FUNCTION ")):
                is_private = line_upper.startswith(("PRIVATE SUB ", "PRIVATE FUNCTION "))
                prefix = "PRIVATE " if is_private else ""
                method_type = "SUB" if line_upper.startswith((prefix + "SUB ")) else "FUNCTION"
                match = re.match(rf"{prefix}{method_type}\s+(\w+)(?:\(.*\))?", line, re.IGNORECASE)
                if match:
                    method_name = match.group(1)
                    method_body = []
                    j = i + 1
                    while j < len(lines) and lines[j].strip().upper() != f"END {method_type}":
                        method_body.append(lines[j].strip())
                        j += 1
                    params = re.search(r"\((.*?)\)", line, re.IGNORECASE)
                    params = params.group(1).split(",") if params else []
                    params = [p.strip() for p in params]
                    method_lambda = lambda self, *args, **kwargs: self.execute_method(method_name, method_body, params, args, scope_name=current_class)
                    if is_private:
                        class_info[current_class]['private_methods'][method_name] = method_lambda
                    else:
                        class_info[current_class]['methods'][method_name] = method_lambda
                    i = j + 1
                else:
                    raise Exception(f"{method_type} tanýmý hatasý: {line}")
            elif current_class and line_upper.startswith("STATIC "):
                match = re.match(r"STATIC\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['static_vars'][var_name] = self.type_table.get(var_type, None)()
                    i += 1
                else:
                    raise Exception("STATIC komutunda sözdizimi hatasý")
            elif current_class and line_upper.startswith("DIM "):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", line, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    class_info[current_class]['methods']['__init__'] = lambda self: self._vars.update({var_name: self.type_table.get(var_type, None)()})
                    i += 1
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")
            elif line_upper == "END SUB" or line_upper == "END FUNCTION":
                current_sub = None
                current_function = None
                i += 1
            elif line_upper.startswith("LABEL "):
                label_name = line[6:].strip()
                self.labels[label_name] = i
                self.modules[module_name]["labels"][label_name] = i
                i += 1
            elif line_upper.startswith("DATA "):
                data_items = line[5:].split(",")
                self.data_list.extend([item.strip() for item in data_items])
                i += 1
            elif line_upper.startswith("STRUCT "):
                struct_name = line[7:].strip()
                current_type = struct_name
                type_fields[struct_name] = []
                i += 1
                while i < len(lines) and not lines[i].strip().upper().startswith("END STRUCT"):
                    field_line = lines[i].strip()
                    if field_line:
                        field_name, field_type = [x.strip() for x in field_line.split("AS")]
                        type_fields[struct_name].append((field_name, field_type))
                    i += 1
                self.types[current_type] = {"kind": "STRUCT", "fields": type_fields[current_type]}
            elif line_upper.startswith("COMPILE"):
                self.bytecode = self.compile_to_bytecode(code)
                return None
            else:
                if current_sub or current_function:
                    self.program.append((line, current_sub or current_function))
                    self.modules[module_name]["program"].append((line, current_sub or current_function))
                else:
                    self.program.append((line, None))
                    self.modules[module_name]["program"].append((line, None))
                i += 1

    def import_module(self, file_name, module_name=None):
        ext = os.path.splitext(file_name)[1].lower()
        if ext not in (".basx", ".libx", ".hx", ".hz"):
            for try_ext in [".hz", ".hx"]:
                if os.path.exists(file_name + try_ext):
                    file_name = file_name + try_ext
                    ext = try_ext
                    break
            else:
                raise Exception("Desteklenmeyen dosya uzantýsý. Uzantý .basX, .libX, .hX veya .hz olmalý")
        if not os.path.exists(file_name):
            raise Exception(f"Dosya bulunamadý: {file_name}")
        module_name = module_name or os.path.splitext(os.path.basename(file_name))[0]
        if module_name in self.modules:
            raise Exception(f"Modül zaten yüklü: {module_name}")
        with open(file_name, 'r', encoding='utf-8') as f:
            code = f.read()
        old_program = self.program
        old_functions = self.functions.copy()
        old_subs = self.subs.copy()
        old_classes = self.classes.copy()
        old_types = self.types.copy()
        old_labels = self.labels.copy()
        old_module = self.current_module
        self.program = []
        self.functions.clear()
        self.subs.clear()
        self.classes.clear()
        self.types.clear()
        self.labels.clear()
        if ext == ".hz":
            self.parse_program(code, module_name, lightweight=True)
        elif ext == ".hx":
            self.parse_definitions(code, module_name)
        elif ext == ".libx":
            self.parse_program(code, module_name, as_library=True)
        else:
            self.parse_program(code, module_name)
        self.program = old_program
        self.functions.update(old_functions)
        self.subs.update(old_subs)
        self.classes.update(old_classes)
        self.types.update(old_types)
        self.labels.update(old_labels)
        self.current_module = old_module

    def parse_definitions(self, code, module_name):
        pass

    def execute_method(self, method_name, method_body, params, args, scope_name):
        if len(args) != len(params):
            raise Exception(f"Parametre uyuþmazlýðý: {method_name}")
        local_scope = {p: a for p, a in zip(params, args)}
        self.local_scopes.append(local_scope)
        for line in method_body:
            self.execute_command(line, scope_name)
        self.local_scopes.pop()
        return local_scope.get('RETURN', None)

    def evaluate_expression(self, expr, scope_name=None):
        cache_key = (expr, scope_name)
        if cache_key not in self.expr_cache:
            tree = ast.parse(expr, mode='eval')
            self.expr_cache[cache_key] = compile(tree, '<string>', 'eval')
        namespace = {}
        namespace.update(self.global_vars)
        namespace.update(self.current_scope())
        namespace.update(self.function_table)
        return eval(self.expr_cache[cache_key], namespace)

    async def run_async(self, code):
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        while self.running and self.program_counter < len(self.program):
            command, scope = self.program[self.program_counter]
            if self.debug_mode:
                print(f"DEBUG: Satýr {self.program_counter + 1}: {command}")
                await asyncio.sleep(0)
            next_pc = self.execute_command(command, scope)
            if next_pc is not None:
                self.program_counter = next_pc
            else:
                self.program_counter += 1
        self.running = False

    def execute_command(self, command, scope_name=None):
        command = command.strip()
        if not command:
            return None
        command_upper = command.upper()

        if self.trace_mode:
            print(f"TRACE: Satýr {self.program_counter + 1}: {command}")

        try:
            if command_upper.startswith("IMPORT"):
                match = re.match(r"IMPORT\s+([^\s]+)(?:\s+AS\s+(\w+))?", command, re.IGNORECASE)
                if match:
                    file_name, alias = match.groups()
                    module_name = alias or os.path.splitext(os.path.basename(file_name))[0]
                    self.import_module(file_name, module_name)
                    return None
                else:
                    raise Exception("IMPORT komutunda sözdizimi hatasý")

            if command_upper.startswith("ON ERROR GOTO"):
                match = re.match(r"ON ERROR GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.error_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON ERROR GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("ON GOSUB"):
                match = re.match(r"ON GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.gosub_handler = self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                    return None
                else:
                    raise Exception("ON GOSUB komutunda sözdizimi hatasý")

            if command_upper.startswith("PRINT"):
                parts = command[5:].strip().split()
                args = [self.evaluate_expression(arg, scope_name) for arg in parts]
                print(*args)
                return None

            if command_upper.startswith("INPUT"):
                match = re.match(r"INPUT\s+\"([^\"]+)\",\s*(\w+)", command, re.IGNORECASE)
                if match:
                    prompt, var_name = match.groups()
                    value = input(prompt)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("INPUT komutunda sözdizimi hatasý")

            if command_upper.startswith("LET"):
                match = re.match(r"LET\s+(\w+)\s*=\s*(.+)", command, re.IGNORECASE)
                if match:
                    var_name, expr = match.groups()
                    value = self.evaluate_expression(expr, scope_name)
                    self.current_scope()[var_name] = value
                    return None
                else:
                    raise Exception("LET komutunda sözdizimi hatasý")

            if command_upper.startswith("DIM"):
                match = re.match(r"DIM\s+(\w+)\s+AS\s+(\w+)", command, re.IGNORECASE)
                if match:
                    var_name, var_type = match.groups()
                    if var_type.upper() == "STRUCT":
                        self.current_scope()[var_name] = StructInstance([], self.type_table)
                    elif var_type.upper() == "UNION":
                        self.current_scope()[var_name] = UnionInstance([], self.type_table)
                    else:
                        self.current_scope()[var_name] = self.type_table.get(var_type.upper(), object)()
                    return None
                else:
                    raise Exception("DIM komutunda sözdizimi hatasý")

            if command_upper.startswith("IF"):
                match = re.match(r"IF\s+(.+)\s+THEN\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition, then_cmd = match.groups()
                    if self.evaluate_expression(condition, scope_name):
                        return self.execute_command(then_cmd, scope_name)
                    return None
                else:
                    raise Exception("IF komutunda sözdizimi hatasý")

            if command_upper.startswith("FOR"):
                match = re.match(r"FOR\s+(\w+)\s*=\s*(.+)\s+TO\s+(.+)(?:\s+STEP\s+(.+))?", command, re.IGNORECASE)
                if match:
                    var_name, start_expr, end_expr, step_expr = match.groups()
                    start = self.evaluate_expression(start_expr, scope_name)
                    end = self.evaluate_expression(end_expr, scope_name)
                    step = self.evaluate_expression(step_expr, scope_name) if step_expr else 1
                    self.current_scope()[var_name] = start
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "FOR",
                        "var": var_name,
                        "end": end,
                        "step": step
                    })
                    return None
                else:
                    raise Exception("FOR komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "NEXT":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("CONTINUE FOR"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    return loop_info["start"]
                else:
                    raise Exception("CONTINUE FOR için eþleþen FOR bulunamadý")

            if command_upper.startswith("NEXT"):
                if self.loop_stack and self.loop_stack[-1]["type"] == "FOR":
                    loop_info = self.loop_stack[-1]
                    var_name = loop_info["var"]
                    current_value = self.current_scope()[var_name]
                    current_value += loop_info["step"]
                    self.current_scope()[var_name] = current_value
                    if (loop_info["step"] > 0 and current_value <= loop_info["end"]) or \
                       (loop_info["step"] < 0 and current_value >= loop_info["end"]):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("NEXT için eþleþen FOR bulunamadý")

            if command_upper.startswith("WHILE"):
                match = re.match(r"WHILE\s+(.+)", command, re.IGNORECASE)
                if match:
                    condition = match.group(1)
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": "WHILE",
                        "condition": condition
                    })
                    if not self.evaluate_expression(condition, scope_name):
                        while self.program_counter < len(self.program) and \
                              self.program[self.program_counter][0].upper() != "WEND":
                            self.program_counter += 1
                    return None
                else:
                    raise Exception("WHILE komutunda sözdizimi hatasý")

            if command_upper == "WEND":
                if self.loop_stack and self.loop_stack[-1]["type"] == "WHILE":
                    loop_info = self.loop_stack[-1]
                    if self.evaluate_expression(loop_info["condition"], scope_name):
                        return loop_info["start"]
                    else:
                        self.loop_stack.pop()
                    return None
                else:
                    raise Exception("WEND için eþleþen WHILE bulunamadý")

            if command_upper.startswith("DO"):
                match = re.match(r"DO\s+(WHILE|UNTIL)?\s*(.+)?", command, re.IGNORECASE)
                if match:
                    loop_type, condition = match.groups()
                    self.loop_stack.append({
                        "start": self.program_counter,
                        "type": loop_type or "NONE",
                        "condition": condition or "True"
                    })
                    return None
                else:
                    raise Exception("DO komutunda sözdizimi hatasý")

            if command_upper.startswith("EXIT DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    while self.program_counter < len(self.program) and \
                          self.program[self.program_counter][0].upper() != "LOOP":
                        self.program_counter += 1
                    self.loop_stack.pop()
                    return None
                else:
                    raise Exception("EXIT DO için eþleþen DO bulunamadý")

            if command_upper.startswith("CONTINUE DO"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    return self.loop_stack[-1]["start"]
                else:
                    raise Exception("CONTINUE DO için eþleþen DO bulunamadý")

            if command_upper.startswith("LOOP"):
                if self.loop_stack and self.loop_stack[-1]["type"] in ("WHILE", "UNTIL", "NONE"):
                    loop_info = self.loop_stack[-1]
                    condition = loop_info["condition"]
                    if loop_info["type"] == "WHILE" and not self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "UNTIL" and self.evaluate_expression(condition, scope_name):
                        self.loop_stack.pop()
                    elif loop_info["type"] == "NONE":
                        return loop_info["start"]
                    return None
                else:
                    raise Exception("LOOP için eþleþen DO bulunamadý")

            if command_upper.startswith("GOTO"):
                match = re.match(r"GOTO\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOTO komutunda sözdizimi hatasý")

            if command_upper.startswith("GOSUB"):
                match = re.match(r"GOSUB\s+(\w+)", command, re.IGNORECASE)
                if match:
                    label = match.group(1)
                    if label in self.labels:
                        self.call_stack.append(self.program_counter + 1)
                        return self.labels[label]
                    else:
                        raise Exception(f"Etiket bulunamadý: {label}")
                else:
                    raise Exception("GOSUB komutunda sözdizimi hatasý")

            if command_upper == "RETURN":
                if self.call_stack:
                    return self.call_stack.pop()
                else:
                    raise Exception("RETURN için eþleþen GOSUB bulunamadý")

            if command_upper.startswith("TRY"):
                match = re.match(r"TRY\s+(.+)\s+CATCH\s+(\w+)\s+DO\s+(.+)", command, re.IGNORECASE)
                if match:
                    try_block, error_var, catch_block = match.groups()
                    try:
                        self.execute_command(try_block, scope_name)
                    except Exception as e:
                        self.current_scope()[error_var] = str(e)
                        self.execute_command(catch_block, scope_name)
                    return None
                else:
                    raise Exception("TRY...CATCH komutunda sözdizimi hatasý")

            if command_upper == "DEBUG ON":
                self.debug_mode = True
                return None
            if command_upper == "DEBUG OFF":
                self.debug_mode = False
                return None
            if command_upper == "TRACE ON":
                self.trace_mode = True
                return None
            if command_upper == "TRACE OFF":
                self.trace_mode = False
                return None
            if command_upper == "STEP DEBUG":
                self.debug_mode = True
                input(f"Satýr {self.program_counter + 1}: {command}\nDevam için Enter...")
                return None

            if command_upper.startswith("PERFORMANCE"):
                process = psutil.Process()
                memory = process.memory_info().rss / 1024 / 1024
                cpu = psutil.cpu_percent()
                elapsed = time.time() - self.performance_metrics["start_time"]
                print(f"Performans: Bellek: {memory:.2f} MB, CPU: {cpu:.2f}%, Süre: {elapsed:.2f}s")
                return None

            if command_upper.startswith("SET LANGUAGE"):
                match = re.match(r"SET LANGUAGE\s+(\w+)", command, re.IGNORECASE)
                if match:
                    lang = match.group(1).lower()
                    if lang in self.translations:
                        self.language = lang
                    else:
                        raise Exception(f"Desteklenmeyen dil: {lang}")
                    return None
                else:
                    raise Exception("SET LANGUAGE komutunda sözdizimi hatasý")

            if command_upper.startswith("CALL"):
                if command_upper.startswith("CALL API::GET"):
                    match = re.match(r"CALL API::GET\s+(.+)", command, re.IGNORECASE)
                    if match:
                        url = match.group(1)
                        return requests.get(url).json()
                elif command_upper.startswith("CALL"):
                    match = re.match(r"CALL\s+(\w+)::(\w+)\((.*)\)", command, re.IGNORECASE)
                    if match:
                        dll_name, func_name, args = match.groups()
                        dll = self.core.load_dll(dll_name)
                        func = getattr(dll, func_name)
                        arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in args.split(",") if arg.strip()]
                        return func(*arg_list)
                raise Exception("CALL komutunda sözdizimi hatasý")

            if command_upper.startswith("HELP"):
                match = re.match(r"HELP\s*(\w+)?", command, re.IGNORECASE)
                if match:
                    lib_name = match.group(1)
                    self.show_help(lib_name)
                    return None
                else:
                    raise Exception("HELP komutunda sözdizimi hatasý")

            if command_upper.startswith("CORE."):
                func_name = command_upper.split(".")[1]
                args = re.match(r"CORE\.(\w+)\((.*)\)", command, re.IGNORECASE)
                if args:
                    _, arg_str = args.groups()
                    arg_list = [self.evaluate_expression(arg.strip(), scope_name) for arg in arg_str.split(",") if arg.strip()]
                    return getattr(self.core, func_name.lower())(*arg_list)
                else:
                    return getattr(self.core, func_name.lower())()

            raise Exception(f"Bilinmeyen komut: {command}")

        except Exception as e:
            logging.error(f"Hata: {str(e)}\n{''.join(traceback.format_stack())}")
            if self.error_handler:
                return self.error_handler
            elif self.gosub_handler:
                return self.gosub_handler
            else:
                raise e

    def show_help(self, lib_name=None):
        if lib_name:
            help_file = f"{lib_name}/{lib_name}_help.json"
            if os.path.exists(help_file):
                with open(help_file, "r", encoding="utf-8") as f:
                    help_data = json.load(f)
                for cmd in help_data.get(lib_name, {}).get("commands", []):
                    print(f"Komut: {cmd['name']}")
                    print(f"Kullaným: {cmd['usage']}")
                    print(f"Amaç: {cmd['purpose']}")
                    print(f"Örnek: {cmd['example']}")
                    print("-" * 50)
            else:
                print(f"Yardým dosyasý bulunamadý: {lib_name}")
        else:
            print("Kullaným: HELP [kütüphane_adý]")
            print("Örnek: HELP libx_core")

    def run(self, code):
        self.program = []
        self.parse_program(code)
        self.running = True
        self.program_counter = 0
        try:
            while self.running and self.program_counter < len(self.program):
                cmd, scope = self.program[self.program_counter]
                next_pc = self.execute_command(cmd, scope)
                self.program_counter = next_pc if next_pc is not None else self.program_counter + 1
        except Exception as e:
            if self.error_handler:
                self.program_counter = self.error_handler
            elif self.gosub_handler:
                self.program_counter = self.gosub_handler
            else:
                raise e
        self.running = False

    def repl(self):
        self.repl_mode = True
        print("pdsXv11 REPL - Çýkýþ için 'EXIT'")
        while True:
            try:
                cmd = input("> ")
                if cmd.upper() == "EXIT":
                    break
                self.execute_command(cmd)
            except Exception as e:
                print(f"Hata: {e}")
        self.repl_mode = False

    def compile_to_bytecode(self, code):
        self.bytecode = []
        lines = code.split("\n")
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            tokens = line.split(maxsplit=1)
            opcode = tokens[0].upper()
            operands = tokens[1] if len(tokens) > 1 else ""
            self.bytecode.append({"opcode": opcode, "operands": operands, "line": i + 1})
        return self.bytecode

    def execute_bytecode(self):
        self.running = True
        pc = 0
        while self.running and pc < len(self.bytecode):
            instruction = self.bytecode[pc]
            opcode = instruction["opcode"]
            operands = instruction["operands"]
            try:
                if opcode == "PRINT":
                    print(self.evaluate_expression(operands))
                elif opcode == "LET":
                    var, val = operands.split("=", 1)
                    self.current_scope()[var.strip()] = self.evaluate_expression(val.strip())
                elif opcode == "DIM":
                    var_name, var_type = operands.split("AS")
                    self.current_scope()[var_name.strip()] = self.type_table.get(var_type.strip().upper(), object)()
                elif opcode == "IF":
                    condition, then_cmd = operands.split("THEN")
                    if self.evaluate_expression(condition.strip()):
                        self.execute_command(then_cmd.strip())
                elif opcode == "GOTO":
                    label = operands.strip()
                    for i, instr in enumerate(self.bytecode):
                        if instr["opcode"] == "LABEL" and instr["operands"] == label:
                            pc = i
                            break
                pc += 1
            except Exception as e:
                logging.error(f"Bayt kodu hatasý: Satýr {instruction['line']}, {str(e)}")
                if self.error_handler:
                    pc = self.error_handler
                else:
                    raise e
        self.running = False

def main():
    parser = argparse.ArgumentParser(description='pdsXv11 Interpreter')
    parser.add_argument('file', nargs='?', help='Çalýþtýrýlacak dosya')
    parser.add_argument('-i', '--interactive', action='store_true', help='Etkileþimli mod')
    args = parser.parse_args()

    interpreter = pdsXv11()
    if args.file:
        with open(args.file, 'r', encoding='utf-8') as f:
            code = f.read()
        interpreter.run(code)
    if args.interactive or not args.file:
        interpreter.repl()

if __name__ == "__main__":
    main()

